<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Project 63 - Slot Blackjack</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
  /* Film Noir â€” Default Theme */
  --bg-primary: #0f0f0f;
  --bg-secondary: #1a1a1a;
  --bg-card: #262626;
  --bg-hover: #2c2c2c;

  --text-primary: #f5f5f5;
  --text-secondary: #b8b8b8;
  --text-muted: #737373;

  --accent-gold: #d4af37;
  --accent-gold-dim: #8a6f1f;

  --accent-red: #a83232;
  --accent-green: #5e8c61;
  --accent-blue: #5f7d95;
  --accent-purple: #7d6a82;

  --border-color: #404040;

  /* Playing card ink (used on white cards) */
  --card-red: #b13b3b;
  --card-black: #111111;

  /* Typography */
  --font-display: 'Bebas Neue', sans-serif;
  --font-mono: 'Space Mono', monospace;
  --font-body: 'Inter', sans-serif;

  /* Derived â€œwashâ€ colors (keeps hover/bust backgrounds consistent) */
  --wash-gold: rgba(212, 175, 55, 0.14);
  --wash-red: rgba(168, 50, 50, 0.18);
  --wash-green: rgba(94, 140, 97, 0.18);
  --wash-blue: rgba(95, 125, 149, 0.16);
  --wash-purple: rgba(125, 106, 130, 0.16);

  /* Intro / Home / Calling-Card presentation polish */
  --noir-bg-primary: #0f1119;
  --noir-bg-secondary: #141820;
  --noir-shadow-gold: #261d0d;
  --noir-muted-gold: #6c5b21;
  --noir-soft-gold: #d4af37;
  --noir-text-primary: #e4e4e7;
  --noir-text-secondary: #a1a1aa;
  --fade-duration: 0.8s;
  --slide-duration: 0.6s;
  --slide-delay: 0.2s;
  --transition-speed: 0.3s;
}

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: var(--font-body);
      font-size: 15px;
      line-height: 1.35;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-tap-highlight-color: transparent;
      isolation: isolate;
    }

    /* Ambient (subtle, non-gimmicky) */
    body::before{
      content:"";
      position: fixed;
      inset: -20%;
      z-index: -2;
      pointer-events: none;
      background:
        radial-gradient(600px 420px at 18% 12%, rgba(212,175,55,0.18), transparent 60%),
        radial-gradient(700px 520px at 82% 18%, rgba(95,125,149,0.16), transparent 62%),
        radial-gradient(720px 520px at 50% 86%, rgba(125,106,130,0.14), transparent 62%);
      filter: blur(36px) saturate(115%);
      opacity: 0.9;
    }

    /* Vignette + faint texture */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(ellipse at center, transparent 45%, rgba(0,0,0,0.55) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 2px, transparent 6px);
      opacity: 0.35;
      mix-blend-mode: overlay;
    }

        .hud-bank {
      min-width: 220px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: var(--bg-card);
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .hud-bank-main { font-family: var(--font-mono); font-size: 18px; color: var(--accent-green); font-weight: 800; }
    .hud-bank-sub { font-size: 11px; color: var(--text-secondary); }

    .proc-banner { margin: 8px auto 12px; max-width: 680px; padding: 10px 12px; border: 1px solid var(--accent-blue); border-radius: 12px; background: rgba(95,125,149,0.16); font-family: var(--font-mono); }
    .proc-banner-title { font-weight: 800; color: var(--accent-gold); }
    .proc-banner-desc { font-size: 12px; color: var(--text-secondary); margin-top: 2px; }

    .end-chart-wrap { width: min(980px, 96vw); display:grid; grid-template-columns: 1fr; gap: 14px; margin: 18px 0 24px; }
    .end-chart-card { background: var(--bg-card); border:1px solid var(--border-color); border-radius:12px; padding:12px; }
    .end-chart-title { font-family: var(--font-display); letter-spacing: 1px; color: var(--accent-gold); margin-bottom: 8px; }
    .sparkline { width: 100%; height: 120px; }
    .run-end-card { width: min(980px, 96vw); background: var(--bg-card); border:1px solid var(--border-color); border-radius:12px; padding:14px; margin: 14px 0 20px; }
    .run-end-head { display:flex; align-items:flex-start; justify-content:space-between; gap:10px; margin-bottom:10px; }
    .run-end-title { font-family: var(--font-display); letter-spacing: 1px; color: var(--accent-gold); font-size: 30px; line-height: 1; }
    .run-end-sub { color: var(--text-muted); font-size: 12px; }
    .run-end-lore { font-weight: 700; margin-bottom: 6px; }
    .run-end-tiny { font-size: 12px; }
    .run-end-muted { color: var(--text-muted); }
    .run-end-cols { display:grid; grid-template-columns: repeat(2,minmax(220px,1fr)); gap:10px; margin:10px 0; }
    .run-end-block { border: 1px solid var(--border-color); border-radius:10px; padding:8px 10px; background: rgba(0,0,0,0.15); }
    .run-end-block div { margin:2px 0; }
    #chartEndChips, #chartEndKarma { width:100%; height:220px; display:block; border:1px solid var(--border-color); border-radius:10px; background: rgba(0,0,0,0.12); }
    @media (max-width: 760px){ .run-end-cols { grid-template-columns: 1fr; } }
    .bar-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap:8px; }
    .bar-item { text-align:center; }
    .bar-col { height: 88px; display:flex; align-items:flex-end; justify-content:center; }
    .bar-fill { width: 22px; background: var(--accent-blue); border-radius: 6px 6px 0 0; }
    .bar-label { font-family: var(--font-mono); font-size: 11px; color: var(--text-secondary); margin-top: 4px; }

    .start-screen{
      position: fixed; inset: 0;
      z-index: 400;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(1000px 700px at 20% 8%, rgba(108,91,33,0.24), transparent 62%),
        linear-gradient(180deg, var(--noir-bg-secondary) 0%, var(--noir-bg-primary) 100%);
    }
    .start-plasma{ position:absolute; inset:0; width:100%; height:100%; }
    .start-shell{
      position: relative;
      width: min(560px, calc(100vw - 28px));
      padding: 18px;
      border: 1px solid rgba(212, 175, 55, 0.32);
      border-radius: 16px;
      background: rgba(20, 24, 32, 0.86);
      backdrop-filter: blur(10px) saturate(120%);
      box-shadow: 0 24px 60px rgba(0,0,0,0.55);
      animation: fadeIn var(--fade-duration) ease-out both, slideUp var(--slide-duration) ease-out var(--slide-delay) both;
    }
    .start-shell::before{
      content:"";
      position:absolute; left:0; right:0; top:0; height:3px;
      border-top-left-radius:16px; border-top-right-radius:16px;
      background: linear-gradient(90deg, var(--noir-soft-gold), #ffda70);
      opacity:.9;
    }
    .start-h1{
      font-family: var(--font-display);
      letter-spacing: 1.2px;
      font-size: 44px;
      line-height: 1;
      background: linear-gradient(135deg, var(--noir-soft-gold) 0%, #ffda70 50%, var(--noir-soft-gold) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-size: 200% auto;
      animation: shimmer 3s linear infinite;
    }
    .start-h2{ font-family: var(--font-display); letter-spacing: 1px; font-size: 18px; color: var(--noir-text-secondary); margin-top: 4px; }
    .start-lore{ font-family: var(--font-body); color: var(--noir-text-secondary); margin-top: 10px; font-size: 14px; }
    .start-card{ margin-top:14px; padding:14px; border:1px solid rgba(212, 175, 55, 0.26); border-radius:14px; background: rgba(10, 14, 23, 0.58); }
    .start-card-top{ font-family: var(--font-display); letter-spacing: 1px; color: var(--text-muted); }
    .start-card-row{ margin-top:8px; font-family: var(--font-mono); color: var(--text-secondary); font-size:12px; min-height: 16px; }
    .start-actions{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    .start-grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    @media (max-width: 420px){ .start-grid{ grid-template-columns:1fr; } .start-actions{ grid-template-columns:1fr; } }

    .intro-plasma-layer{
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      opacity: 0;
      transition: opacity 420ms ease;
    }
    .intro-plasma-layer.show{ opacity: 1; }
    .intro-plasma-layer.fade-out{ opacity: 0; }
    .intro-plasma-canvas{ position:absolute; inset:0; width:100%; height:100%; }

    .intro-screen-wrap{
      position: relative;
      min-height: calc(100vh - var(--hud-offset) - 24px);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px 10px 30px;
      z-index: 2;
    }

    .rules-wrap{ display:flex; flex-direction:column; gap:12px; }
    .rules-h{ font-family: var(--font-display); letter-spacing: 1px; margin: 0; }
    .rules-ul{ margin: 0; padding-left: 18px; color: var(--text-secondary); }
    .rules-ul li{ margin: 6px 0; }

    /* HUD Styles */
    #hud {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: linear-gradient(180deg, var(--bg-secondary) 0%, rgba(18, 26, 42, 0.95) 100%);
      border-bottom: 1px solid var(--border-color);
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      backdrop-filter: blur(10px);
    }

    .hud-primary {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      width: 100%;
    }

    .hud-primary-left {
      display: flex;
      align-items: baseline;
      gap: 14px;
      flex-wrap: nowrap;
      min-width: 0;
      white-space: nowrap;
    }

    .hud-primary-right {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: nowrap;
      white-space: nowrap;
    }

    .hud-secondary {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 12px;
      width: 100%;
      padding-top: 10px;
      border-top: 1px solid var(--border-color);
    }

    #hud.hud-collapsed .hud-secondary { display: none; }

    .hud-left, .hud-right {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .hud-center{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .hud-icon-btn{
      width: 38px;
      height: 38px;
      display:flex;
      align-items:center;
      justify-content:center;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor:pointer;
      transition: all 0.18s;
      border-radius: 10px;
      font-size: 18px;
      user-select: none;
    }
    .hud-icon-btn:hover{
      background: var(--bg-hover);
      border-color: var(--accent-gold);
      transform: translateY(-1px);
    }

    .hud-stat {
      display: flex;
      align-items: center;
      gap: 8px;
      font-family: 'Fira Code', monospace;
      font-size: 14px;
    }

    .hud-stat-label {
      color: var(--text-muted);
      text-transform: uppercase;
      font-size: clamp(11px, 2.2vw, 12px);
      letter-spacing: 0.9px;
    }

    .hud-stat-value {
      color: var(--accent-gold);
      font-weight: 600;
      font-size: clamp(16px, 3.2vw, 18px);
    }

    .hud-stat-value.chips { color: var(--accent-green); }
    .hud-stat-value.debt { color: var(--accent-red); }
    .hud-stat-value.tokens { color: var(--accent-purple); }
    .hud-stat-value.karma { color: var(--accent-blue); }

    .hud-btn {
      font-family: var(--font-display);
      font-size: 13px;
      padding: 10px 16px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 10px;
    }

    .hud-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .hud-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .hud-btn.danger { border-color: var(--accent-red); color: var(--accent-red); }
    .hud-btn.danger:hover:not(:disabled) { background: var(--wash-red); }

    .hud-btn.success { border-color: var(--accent-green); color: var(--accent-green); }
    .hud-btn.success:hover:not(:disabled) { background: var(--wash-green); }

    :root { --hud-offset: 70px; }

    /* Main App Container */
    #app { padding-top: var(--hud-offset); min-height: 100vh; }
    .hidden { display: none !important; }

    /* Board View */
    #boardView { display: flex; flex-direction: column; align-items: center; padding: 20px; }
    #boardSvg { max-width: 100%; height: auto; }

    .board-shell { width: min(640px, 96vw); display: flex; flex-direction: column; align-items: center; gap: 12px; }
    .board-toprow { width: min(640px, 96vw); display: flex; align-items: stretch; justify-content: space-between; gap: 12px; }
    .board-toprow .board-instructions { margin-bottom: 0; flex: 1; }
    .legend-toggle { padding: 14px 14px; min-width: 92px; border-radius: 12px; }

    .board-legend { width: min(640px, 96vw); background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; padding: 12px 12px 10px; }
    .legend-title { font-family: var(--font-display); font-size: 13px; text-transform: uppercase; letter-spacing: 1px; color: var(--text-primary); display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .legend-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(170px, 1fr)); gap: 8px; margin-top: 10px; }
    .legend-item { display: flex; align-items: flex-start; gap: 10px; padding: 8px 10px; border: 1px solid rgba(148,163,184,0.18); border-radius: 10px; background: rgba(15,23,42,0.35); }
    .legend-swatch { width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.25); margin-top: 2px; flex: 0 0 auto; }
    .legend-item .k { font-weight: 800; color: var(--text-primary); }
    .legend-item .v { color: var(--text-secondary); font-size: 12px; line-height: 1.35; margin-top: 2px; }
    .legend-note { margin-top: 10px; color: var(--text-secondary); font-size: 12px; line-height: 1.35; }
    .legend-note code { background: rgba(0,0,0,0.25); border: 1px solid rgba(148,163,184,0.22); border-radius: 8px; padding: 1px 6px; }

    .board-edge { stroke: rgba(148,163,184,0.22); stroke-width: 2; opacity: 0.85; stroke-linecap: round; pointer-events: none; }
    .board-edge.base { stroke-dasharray: 4 7; }
    .board-edge.available-edge { stroke: var(--accent-gold); opacity: 0.9; stroke-dasharray: none; }


    .hex-tile { cursor: default; transition: all 0.2s; }
    .hex-tile.available { cursor: pointer; }

    .hex-tile { transform-box: fill-box; transform-origin: center; }
    .hex-tile:hover .hex-bg { filter: brightness(1.08); }
    .hex-tile.available:hover { transform: translateY(-2px) scale(1.03); }
    .hex-tile.available:active { transform: translateY(-1px) scale(1.01); }
    .hex-tile.visited { opacity: 0.5; }

    .hex-tile.current .hex-bg {
      stroke: var(--accent-blue);
      stroke-width: 4;
      filter: drop-shadow(0 0 10px var(--accent-blue));
    }

    .hex-tile.available .hex-bg {
      stroke: var(--accent-gold);
      stroke-width: 3;
      animation: pulse-glow 1.5s ease-in-out infinite;
    }

    .hex-tile.key-roller .hex-bg {
      stroke: rgba(168, 85, 247, 0.95);
      stroke-width: 4;
      animation: key-roller-glow 1.6s ease-in-out infinite;
      filter: drop-shadow(0 0 12px rgba(168, 85, 247, 0.30));
    }

    .hex-tile.key-roller .hex-label::after {
      content: "ðŸ”‘";
    }

    @keyframes key-roller-glow {
      0%, 100% { filter: drop-shadow(0 0 8px rgba(168, 85, 247, 0.20)); }
      50% { filter: drop-shadow(0 0 22px rgba(168, 85, 247, 0.46)); }
    }

    @keyframes pulse-glow {
      0%, 100% { filter: drop-shadow(0 0 5px var(--accent-gold-dim)); }
      50% { filter: drop-shadow(0 0 15px var(--accent-gold)); }
    }

    .hex-label {
      font-family: 'Fira Code', monospace;
      font-size: clamp(11px, 2.4vw, 13px);
      fill: var(--text-primary);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      font-weight: 600;
    }
    .hex-sub {
      font-family: 'Fira Code', monospace;
      font-size: clamp(10px, 2.2vw, 12px);
      fill: var(--text-secondary);
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }

    .path-line {
      stroke: var(--accent-blue);
      stroke-width: 3;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      opacity: 0.7;
    }

    /* Modal Overlay */
    #modalOverlay {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.55), rgba(0,0,0,0.72));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 700;
      padding: 20px;
      backdrop-filter: blur(7px) saturate(120%);
    }


    #minigameOverlay{
      position: fixed;
      inset: 0;
      z-index: 9999;
      background: rgba(0,0,0,0.72);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display: flex;
      align-items: stretch;
      justify-content: stretch;
    }

    #minigameOverlay.hidden{ display:none; }

    .minigame-shell{
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

    .minigame-testbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border-color);
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(8px) saturate(120%);
      -webkit-backdrop-filter: blur(8px) saturate(120%);
    }

    .minigame-testbar.hidden{ display:none; }

    .minigame-testbar-title{
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0.95;
    }

    .minigame-testbar-actions{
      display:flex;
      gap: 8px;
    }

    #minigameFrame{
      width: 100%;
      height: 100%;
      border: 0;
      background: transparent;
    }

    #modal {
      position: relative;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.9), rgba(125,106,130,0.65)) top/100% 3px no-repeat,
        var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      max-width: 560px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }

    .modal-header {
      padding: 20px 24px;
      border-bottom: 1px solid var(--border-color);
      font-family: 'Cinzel', serif;
      font-size: 20px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .modal-body { padding: 24px; }
    .modal-footer {
      padding: 16px 24px;
      border-top: 1px solid var(--border-color);
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      flex-wrap: wrap;
    }

    .modal-btn {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      padding: 12px 18px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 10px;
    }

    .modal-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .modal-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .modal-btn.primary {
      background: var(--accent-gold);
      color: var(--bg-primary);
      border-color: var(--accent-gold);
    }
    .modal-btn.primary:hover:not(:disabled) { background: #ffda70; }

    .modal-btn.danger { border-color: var(--accent-red); color: var(--accent-red); }
    .modal-btn.danger:hover:not(:disabled) { background: var(--wash-red); }


    .help-block{
      margin: 0 0 12px;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 12px;
      background: var(--bg-secondary);
    }
    .help-block summary{
      cursor: pointer;
      font-weight: 800;
      color: var(--text-primary);
      user-select: none;
    }
    .help-block ul{
      margin: 8px 0 0 18px;
      padding: 0;
    }
    .help-block li{
      margin: 4px 0;
      color: var(--text-secondary);
      font-size: 12px;
      line-height: 1.35;
    }

    .settings-section{
      padding: 10px 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      margin: 10px 0;
    }
    .settings-section summary{
      cursor:pointer;
      font-weight: 900;
      color: var(--text-primary);
      user-select:none;
      margin-bottom: 8px;
    }

    .reduce-motion *,
    .reduce-motion *::before,
    .reduce-motion *::after{
      animation-duration: 0.001ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.001ms !important;
      scroll-behavior: auto !important;
    }


    /* Unified button surface */
    .hud-btn, .modal-btn, .bj-btn, .log-mini-btn, .hud-icon-btn, .action-chip, .token-icon{
      background:
        linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.18));
      box-shadow:
        0 10px 24px rgba(0,0,0,0.25),
        inset 0 1px 0 rgba(255,255,255,0.05);
    }

    @media (hover:hover){
      .hud-btn:hover:not(:disabled),
      .modal-btn:hover:not(:disabled),
      .bj-btn:hover:not(:disabled),
      .log-mini-btn:hover:not(:disabled),
      .hud-icon-btn:hover:not(:disabled),
      .action-chip.ready:hover,
      .token-icon:hover:not(.spent):not(.disabled):not(.locked){
        transform: translateY(-1px);
      }
    }

    /* Mobile press feedback (important for phones) */
    .hud-btn:active:not(:disabled),
    .modal-btn:active:not(:disabled),
    .bj-btn:active:not(:disabled),
    .log-mini-btn:active:not(:disabled),
    .hud-icon-btn:active:not(:disabled),
    .action-chip:active:not(.locked):not(.used),
    .token-icon:active:not(.spent):not(.disabled):not(.locked){
      transform: translateY(0px) scale(0.99);
      filter: brightness(1.08);
    }


    /* keep semantic button colors over unified surface */
    .modal-btn.primary {
      background: var(--accent-gold);
      color: var(--bg-primary);
      border-color: var(--accent-gold);
    }
    .bj-btn.place,
    .bj-btn.apply-mod {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }
    .bj-btn.stand-pos {
      background: var(--accent-green);
      border-color: var(--accent-green);
      color: white;
    }
    .bj-btn.place-bench {
      background: rgba(95, 125, 149, 0.2);
      border-color: var(--accent-blue);
      color: white;
    }

    .modal-text {
      color: var(--text-secondary);
      line-height: 1.6;
      margin-bottom: 16px;
    }

    .modal-reward {
      font-family: 'Fira Code', monospace;
      font-size: 24px;
      color: var(--accent-green);
      text-align: center;
      padding: 20px;
      background: rgba(61, 214, 140, 0.1);
      border-radius: 10px;
      margin-bottom: 16px;
      border: 1px solid rgba(61,214,140,0.2);
    }

    /* Merchant Styles */
    .merchant-section { margin-bottom: 18px; }
    .merchant-section-title {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
    }
    .merchant-cards { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }

    .shop-purchase-counter{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:10px 12px;
      border:1px solid var(--border-color);
      border-radius:12px;
      background:rgba(255,255,255,0.03);
      margin-bottom:10px;
    }

    .merchant-card-slot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      min-width: 110px;
    }

    .merchant-card-slot .playing-card { font-size: 18px; }

    .rarity-pip {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
    }
    .rarity-common { background: #94a3b8; }
    .rarity-uncommon { background: #22c55e; }
    .rarity-rare { background: #f59e0b; }

    /* Blackjack View */
    #blackjackView {
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .bj-header { text-align: center; font-family: 'Cinzel', serif; }
    .bj-title {
      font-size: 24px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 3px;
      margin-bottom: 8px;
    }
    .bj-status {
      font-family: 'Inter', sans-serif;
      font-size: 14px;
      color: var(--text-secondary);
    }
    .bj-house-rule, .bj-style-line{
      margin-top: 4px;
      font-size: 12px;
      opacity: .85;
      letter-spacing: .2px;
    }

    .bj-board { display: flex; flex-direction: column; gap: 34px; }
    .bj-side { display: flex; flex-direction: column; gap: 12px; }
    .bj-side-label {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .bj-positions {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
    }

    @media (max-width: 768px) {
      .bj-positions { grid-template-columns: repeat(5, 1fr); gap: 6px; }
    }

    .bj-position {
      position: relative;
      overflow: visible;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 14px;
      padding: 12px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      min-height: 160px;
      transition: all 0.2s;
    }

    .bj-position.closed { opacity: 0.4; background: var(--bg-secondary); }
    .bj-position.open { border-color: var(--accent-blue); }
    .bj-position.bust { border-color: var(--accent-red); background: rgba(232, 69, 69, 0.1); }
    .bj-position.stand { border-color: var(--accent-green); }
    .bj-position.winner { border-color: var(--accent-gold); box-shadow: 0 0 20px rgba(240, 192, 64, 0.22); }

    .bj-position-num { font-family: 'Fira Code', monospace; font-size: 10px; color: var(--text-muted); }

    .bj-cards {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 4px;
      min-height: 50px;
    }

    .bj-total {
      font-family: 'Fira Code', monospace;
      font-size: 16px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .bj-total.bust { color: var(--accent-red); }

    .bj-state {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 2px 8px;
      border-radius: 999px;
      font-weight: 800;
    }

    .bj-state.open { background: var(--accent-blue); color: white; }
    .bj-state.stand { background: var(--accent-green); color: white; }
    .bj-state.bust { background: var(--accent-red); color: white; }
    .bj-state.closed { background: var(--text-muted); color: var(--bg-primary); }

    /* Playing Cards */
    .playing-card {
      width: 36px;
      height: 50px;
      background: white;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      font-family: 'Fira Code', monospace;
      font-size: 12px;
      font-weight: 700;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      border: 1px solid #ddd;
    }

    .playing-card.red { color: var(--card-red); }
    .playing-card.black { color: var(--card-black); }

    /* Modifier cards: shaded blue (per spec) */
    .playing-card.mod {
      background: rgba(95, 125, 149, 0.18);
      border-color: rgba(95, 125, 149, 0.65);
      color: #dbeafe;
    }

    .playing-card.sleeve-blue {
      background: rgba(95, 125, 149, 0.18);
      border-color: rgba(95, 125, 149, 0.65);
      color: #dbeafe;
    }

    .playing-card.sleeve-crystal {
      box-shadow: 0 2px 6px rgba(148, 163, 184, 0.8);
      background: linear-gradient(135deg, rgba(226,232,240,0.7), rgba(255,255,255,0.9));
    }

    .playing-card.sleeve-steel {
      border-color: rgba(148, 163, 184, 0.9);
      box-shadow: 0 2px 6px rgba(100, 116, 139, 0.6);
    }

    .playing-card.sleeve-gold {
      border-color: rgba(234, 179, 8, 0.9);
      box-shadow: 0 2px 6px rgba(234, 179, 8, 0.6);
      background: linear-gradient(135deg, rgba(254, 243, 199, 0.9), rgba(255,255,255,0.9));
    }

    .playing-card.fused {
      background: linear-gradient(135deg, rgba(168,85,247,0.22), rgba(77,166,255,0.22));
      border-color: rgba(168,85,247,0.65);
      color: #1f2937;
      font-size: 11px;
    }

    .stamp-icon {
      position: absolute;
      top: -6px;
      right: -6px;
      background: var(--accent-gold);
      color: #1b1f2a;
      font-size: 9px;
      font-weight: 800;
      border-radius: 999px;
      padding: 2px 5px;
      border: 1px solid rgba(0,0,0,0.2);
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      pointer-events: none;
    }

    .sleeve-icon {
      position: absolute;
      bottom: -6px;
      left: -6px;
      background: #334155;
      color: #f8fafc;
      font-size: 9px;
      font-weight: 800;
      border-radius: 999px;
      padding: 2px 5px;
      border: 1px solid rgba(0,0,0,0.25);
      box-shadow: 0 2px 4px rgba(0,0,0,0.25);
      pointer-events: none;
    }

    .card-tooltip {
      position: fixed;
      z-index: 9999;
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-primary);
      border: 1px solid rgba(148, 163, 184, 0.35);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 12px;
      max-width: 220px;
      pointer-events: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    }

    .card-tooltip.hidden { display: none; }
    .card-tooltip .tooltip-title { font-weight: 800; margin-bottom: 4px; }
    .card-tooltip .tooltip-line { color: var(--text-secondary); line-height: 1.35; }

    /* Bench styling (subtle blue â€œbenchâ€ tint) */
    .playing-card.bench {
      background: rgba(95, 125, 149, 0.10);
      border-color: rgba(95, 125, 149, 0.55);
    }

    .playing-card.face-down {
      background: linear-gradient(135deg, #1a237e 0%, #0d47a1 50%, #1a237e 100%);
      color: transparent;
    }
    .playing-card.face-down::after {
      content: '?';
      color: rgba(255,255,255,0.3);
      font-size: 20px;
    }

    /* Blackjack Controls */
    .bj-controls {
      display: flex;
      flex-direction: column;
      gap: 14px;
      align-items: center;
      padding: 16px;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55)) top/100% 3px no-repeat,
        var(--bg-secondary);
      border-radius: 14px;
      border: 1px solid var(--border-color);
    }

    .bj-turn-info {
      font-family: 'Cinzel', serif;
      font-size: 16px;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      text-align: center;
    }

    .bj-drawn-card {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: rgba(95, 125, 149, 0.1);
      border: 1px solid var(--accent-blue);
      border-radius: 12px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      max-width: 560px;
    }

    .bj-drawn-label { font-size: 14px; color: var(--text-secondary); }

    .bj-action-btns {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .bj-btn {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      padding: 12px 18px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      border-radius: 12px;
    }

    .bj-btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .bj-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    .bj-btn.place {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.stand-pos {
      background: var(--accent-green);
      border-color: var(--accent-green);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.apply-mod {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    .bj-btn.place-bench {
      background: rgba(95, 125, 149, 0.2);
      border-color: var(--accent-blue);
      color: white;
      font-size: 12px;
      padding: 7px 10px;
      border-radius: 10px;
    }

    /* Action bar */
    .action-bar {
      width: 100%;
      max-width: 560px;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 14px;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55)) top/100% 3px no-repeat,
        var(--bg-secondary);
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }

    .action-bar-title {
      width: 100%;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    .action-tokens {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    /* ACTIONS BOX (owned cocktails surfaced on-board) */
    .action-chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:center;
      padding-top:6px;
    }

    .action-chip{
      border:1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      user-select:none;
      transition: all .15s;
      display:inline-flex;
      align-items:center;
      gap:8px;
    }

    .action-chip.ready:hover{ border-color: var(--accent-gold); transform: translateY(-1px); }
    .action-chip.locked{ opacity:.45; cursor:not-allowed; transform:none; }
    .action-chip.used{ opacity:.30; cursor:not-allowed; text-decoration: line-through; }

    .action-chip .pill{
      font-family: 'Fira Code', monospace;
      font-size: 11px;
      color: var(--accent-gold);
      opacity:.9;
    }

    .token-icon {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--accent-gold);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s;
      user-select: none;
      font-family: 'Fira Code', monospace;
      font-weight: 800;
    }

    .token-icon:hover:not(.spent):not(.disabled):not(.locked) { border-color: var(--accent-gold); transform: translateY(-1px); }
    .token-icon.spent { opacity: 0.25; cursor: not-allowed; transform: none; }
    .token-icon.disabled { opacity: 0.35; cursor: not-allowed; transform: none; }
    .token-icon.locked { opacity: 0.55; border-style: dashed; cursor: not-allowed; transform: none; }

    .action-hint {
      color: var(--text-secondary);
      font-size: 12px;
      text-align: center;
      line-height: 1.4;
    }

    /* Bench block next to Actions */
    .controls-row {
      width: 100%;
      display: flex;
      gap: 12px;
      flex-wrap: nowrap;
      justify-content: center;
      align-items: stretch;
      margin-top: 14px;
    }

    .controls-row > .action-bar,
    .controls-row > .bench-bar {
      flex: 1 1 0;
      width: auto;
      max-width: 420px;
      min-width: 0;
    }

    .bench-bar {
      max-width: 380px;
      min-width: 260px;
      flex: 1;
    }

    @media (max-width: 820px){
      .controls-row{
        flex-wrap: wrap;
      }
      .controls-row > .action-bar,
      .controls-row > .bench-bar{
        flex: 1 1 260px;
        max-width: none;
      }
    }

    .bench-cards {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding-top: 6px;
    }

    .bench-card-btn {
      background: transparent;
      border: none;
      padding: 0;
      cursor: pointer;
      border-radius: 10px;
    }

    .bench-card-btn:disabled { cursor: not-allowed; opacity: 0.5; }

    .bench-armed-ring {
      outline: 2px solid rgba(95, 125, 149, 0.85);
      outline-offset: 2px;
      border-radius: 10px;
    }

    /* Action picker list */
    .action-list { display: flex; flex-direction: column; gap: 10px; }
    .action-row {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      padding: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 12px;
    }
    .action-row.disabled { opacity: 0.45; }
    .action-row-title {
      font-family: 'Cinzel', serif;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 14px;
      margin-bottom: 4px;
    }
    .action-row-desc { color: var(--text-secondary); font-size: 12px; line-height: 1.4; }
    .action-row-left { flex: 1; }
    .action-row-right { display: flex; flex-direction: column; gap: 8px; }

    /* Match Result */
    .bj-result {
      text-align: center;
      padding: 24px;
      background: var(--bg-card);
      border-radius: 14px;
      border: 1px solid var(--border-color);
    }

    .bj-result-title {
      font-family: 'Cinzel', serif;
      font-size: 28px;
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .bj-result-title.win { color: var(--accent-green); }
    .bj-result-title.lose { color: var(--accent-red); }
    .bj-result-title.tie { color: var(--accent-gold); }

    .bj-result-score {
      font-family: 'Fira Code', monospace;
      font-size: 14px;
      color: var(--text-secondary);
      margin-bottom: 10px;
      line-height: 1.5;
    }

    .bj-result-chips {
      font-family: 'Fira Code', monospace;
      font-size: 22px;
      margin-bottom: 20px;
    }

    .bj-result-chips.positive { color: var(--accent-green); }
    .bj-result-chips.negative { color: var(--accent-red); }
    .bj-result-chips.neutral { color: var(--text-muted); }

    .boss-hp {
      width: 100%;
      max-width: 360px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      margin: 6px auto 0;
      border: 1px solid var(--border-color);
    }

    .boss-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #f39c12, #e74c3c);
      transition: width 0.3s ease;
    }

    .boss-phase2 .boss-hp-fill {
      background: linear-gradient(90deg, #ff6b6b, #ff4757);
      box-shadow: 0 0 12px rgba(255, 71, 87, 0.6);
    }

    .boss-target {
      border-color: rgba(255, 107, 107, 0.9);
      box-shadow: 0 0 0 2px rgba(255, 107, 107, 0.6), 0 0 14px rgba(255, 107, 107, 0.5);
      animation: bossPulse 1.6s ease-in-out infinite;
    }

    .watcher-target {
      border-color: rgba(125, 211, 252, 0.92);
      box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.25), 0 0 20px rgba(125, 211, 252, 0.22);
      animation: watcherPulse 1.7s ease-in-out infinite;
    }

    @keyframes bossPulse {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-2px); }
    }

    @keyframes watcherPulse {
      0%, 100% { box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.20), 0 0 12px rgba(125, 211, 252, 0.16); }
      50% { box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.34), 0 0 22px rgba(125, 211, 252, 0.34); }
    }

    /* Game Over / Victory Screens */
    .end-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 70px);
      padding: 40px 20px;
      text-align: center;
    }

    .end-title {
      font-family: 'Cinzel', serif;
      font-size: 48px;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 4px;
    }

    .end-title.victory {
      color: var(--accent-gold);
      text-shadow: 0 0 40px rgba(240, 192, 64, 0.5);
    }

    .end-title.gameover {
      color: var(--accent-red);
      text-shadow: 0 0 40px rgba(232, 69, 69, 0.5);
    }

    .end-message {
      font-size: 18px;
      color: var(--text-secondary);
      margin-bottom: 30px;
      max-width: 520px;
      line-height: 1.6;
    }

    .end-stats { display: flex; gap: 26px; margin-bottom: 30px; flex-wrap: wrap; justify-content: center; }
    .end-stat { text-align: center; min-width: 120px; }

    .end-stat-value {
      font-family: 'Fira Code', monospace;
      font-size: 28px;
      color: var(--accent-gold);
      font-weight: 800;
    }

    .end-stat-label {
      font-size: 12px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-top: 4px;
    }

    /* Toast */
    #toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      padding: 12px 16px;
      border-radius: 12px;
      font-size: 14px;
      z-index: 800;
      animation: toast-in 0.3s ease-out;
      box-shadow: 0 18px 50px rgba(0,0,0,0.5);
      max-width: min(640px, 92vw);
      text-align: center;
    }

    @keyframes toast-in {
      from { opacity: 0; transform: translateX(-50%) translateY(20px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }

    /* Confirm Dialog */
    .confirm-dialog {
      position: fixed;
      inset: 0;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.55), rgba(0,0,0,0.72));
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 750;
      padding: 20px;
      backdrop-filter: blur(7px) saturate(120%);
    }

    .confirm-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 24px;
      max-width: 420px;
      width: 100%;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .confirm-message { color: var(--text-secondary); margin-bottom: 20px; line-height: 1.6; }
    .confirm-btns { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }

    /* Removal / selection picker */
    .removal-picker { display: flex; flex-direction: column; gap: 16px; }
    .removal-cards { display: flex; justify-content: center; gap: 12px; flex-wrap: wrap; }

    .removal-card-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg-card);
      border: 2px solid var(--border-color);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 72px;
    }

    .removal-card-option:hover { border-color: var(--accent-red); }
    .removal-card-option.selected { border-color: var(--accent-red); background: rgba(232, 69, 69, 0.1); }

    /* Board instructions */
    .board-instructions {
      text-align: center;
      padding: 16px;
      color: var(--text-secondary);
      font-size: 14px;
      background: var(--bg-secondary);
      border-radius: 12px;
      margin-bottom: 20px;
      max-width: 520px;
      border: 1px solid var(--border-color);
    }

    /* =============================================
       LOG PANEL (slide-in)
       ============================================= */
    #logPanel{
      position: fixed;
      top: 0;
      right: 0;
      height: 100vh;
      width: min(420px, 92vw);
      background: var(--bg-secondary);
      border-left: 1px solid var(--border-color);
      z-index: 650; /* below modal overlay */
      transform: translateX(110%);
      transition: transform 0.24s ease;
      display: flex;
      flex-direction: column;
      box-shadow: -20px 0 60px rgba(0,0,0,0.45);
    }
    #logPanel.open{ transform: translateX(0); }

    .log-panel-header{
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-color);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      background: linear-gradient(180deg, rgba(26,36,54,0.55), rgba(18,26,42,0.15));
    }
    .log-panel-title{
      font-family: 'Cinzel', serif;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: 14px;
      line-height: 1.2;
    }
    .log-panel-sub{
      margin-top: 2px;
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      color: var(--text-muted);
      letter-spacing: 0.5px;
    }
    .log-panel-actions{
      display:flex;
      align-items:center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .log-mini-btn{
      font-family: 'Cinzel', serif;
      font-size: 11px;
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.18s;
      text-transform: uppercase;
      letter-spacing: 1px;
      user-select:none;
    }
    .log-mini-btn:hover{ background: var(--bg-hover); border-color: var(--accent-gold); }
    .log-mini-btn.danger{ border-color: var(--accent-red); color: var(--accent-red); }
    .log-mini-btn.danger:hover{ background: var(--wash-red); }

    .log-tabs{
      padding: 10px 16px;
      border-bottom: 1px solid var(--border-color);
      display:flex;
      gap: 8px;
    }
    .log-tab{
      flex: 1;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-secondary);
      cursor:pointer;
      transition: all 0.18s;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 11px;
      font-family: 'Cinzel', serif;
    }
    .log-tab:hover{ background: var(--bg-hover); border-color: var(--accent-gold); color: var(--text-primary); }
    .log-tab.active{
      border-color: var(--accent-gold);
      color: var(--text-primary);
      box-shadow: 0 0 18px rgba(240,192,64,0.15);
    }

    .log-panel-body{
      padding: 14px 16px;
      overflow-y: auto;
      flex: 1;
    }
    .log-card{
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 12px;
    }
    .log-card-head{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      font-family: 'Fira Code', monospace;
      font-size: 10px;
      color: var(--text-muted);
      margin-bottom: 8px;
      align-items: baseline;
    }
    .log-type{
      color: var(--accent-blue);
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .log-card-body{
      color: var(--text-secondary);
      font-size: 12px;
      line-height: 1.45;
      word-break: break-word;
    }
    .log-kv{
      margin-top: 8px;
      font-family: 'Fira Code', monospace;
      font-size: 11px;
      color: var(--text-secondary);
      background: rgba(10,14,23,0.35);
      border: 1px solid rgba(42,58,84,0.85);
      border-radius: 12px;
      padding: 10px;
      white-space: pre-wrap;
    }
    .stats-grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .log-section-title{
      margin: 18px 0 8px;
      font-weight: 800;
      color: var(--accent-gold);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 12px;
    }
    .log-table{
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      overflow: hidden;
    }
    .log-table th,
    .log-table td{
      padding: 8px 10px;
      border-bottom: 1px solid var(--border-color);
      text-align: left;
    }
    .log-table th{
      color: var(--text-secondary);
      text-transform: uppercase;
      font-size: 10px;
      letter-spacing: 0.8px;
      background: rgba(18, 26, 42, 0.6);
    }
    .log-table tr:last-child td{ border-bottom: none; }
    .stat-box{
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 14px;
      padding: 12px;
    }
    .stat-label{
      color: var(--text-muted);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 6px;
    }
    .stat-value{
      font-family: 'Fira Code', monospace;
      font-size: 18px;
      color: var(--text-primary);
      font-weight: 800;
    }
    .stat-value.good{ color: var(--accent-green); }
    .stat-value.bad{ color: var(--accent-red); }
    .stat-value.gold{ color: var(--accent-gold); }

    .intro-panel {
      max-width: 720px;
      margin: 24px auto;
      padding: 24px;
      border-radius: 18px;
      background: rgba(20, 24, 32, 0.86);
      border: 1px solid rgba(212, 175, 55, 0.32);
      box-shadow: 0 16px 46px rgba(0,0,0,0.45);
      text-align: center;
      animation: fadeIn var(--fade-duration) ease-out both, slideUp var(--slide-duration) ease-out var(--slide-delay) both;
    }

    .intro-title { font-size: 22px; font-weight: 900; margin-bottom: 8px; }
    .intro-text { color: var(--text-secondary); line-height: 1.5; margin-bottom: 16px; }
    .intro-input {
      width: 100%;
      max-width: 360px;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(212, 175, 55, 0.30);
      background: rgba(10, 14, 23, 0.65);
      color: var(--text-primary);
      font-size: 14px;
      margin-bottom: 10px;
      transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
    }
    .intro-input:focus {
      outline: none;
      border-color: var(--noir-soft-gold);
      box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.14);
    }
    .intro-actions { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .intro-suits { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); margin-top: 12px; }
    .intro-suit-btn { text-align: left; }
    .intro-large-card { transform: scale(1.4); margin: 18px auto; }


/* =========================
   Calling Card Reveal (cc-)
   ========================= */

.cc-reveal-root{
  width: 100%;
  min-height: calc(100vh - var(--hud-offset) - 40px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 18px;
  padding: 12px 12px 26px;
}

.cc-card-stage{
  width: min(520px, 92vw);
  display: flex;
  align-items: center;
  justify-content: center;
  perspective: 1100px;
}

.cc-bounce{ transform: translateZ(0); }
.cc-bounce.cc-pop { animation: ccPop 420ms ease-out; }

.cc-float{
  animation: ccFloat 3.8s ease-in-out infinite;
  transform: translateZ(0);
}

:root{
  --cc-reveal-scale: 0.6;
}

.cc-scale{
  transform: scale(var(--cc-reveal-scale));
  transform-origin: center;
}

.cc-tilt{
  width: min(460px, 88vw);
  aspect-ratio: 300 / 420;
  border-radius: 22px;
  transform-style: preserve-3d;
  will-change: transform;
}

.cc-flip{
  position: relative;
  width: 100%;
  height: 100%;
  border-radius: 22px;
  transform-style: preserve-3d;
  transition: transform 0.8s cubic-bezier(0.2, 0.9, 0.25, 1);
  cursor: pointer;
}

.cc-flip.is-flipped{ transform: rotateY(180deg); }

.cc-face{
  position: absolute;
  inset: 0;
  border-radius: 22px;
  backface-visibility: hidden;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 20px;
}

.cc-back{
  transform: rotateY(180deg);
}

.cc-neon{
  background: linear-gradient(135deg, var(--noir-bg-secondary), var(--noir-bg-primary));
  color: var(--noir-text-primary);
  border: 2px solid var(--noir-soft-gold);
  box-shadow:
    0 0 20px rgba(212,175,55,0.42),
    inset 0 0 20px rgba(212,175,55,0.12),
    0 25px 55px rgba(0,0,0,0.55);
  text-shadow: 0 0 8px rgba(212,175,55,0.45);
}

.cc-face::before{
  content:'';
  position:absolute;
  inset:-30%;
  pointer-events:none;
  background:
    linear-gradient(130deg,
      rgba(255,255,255,0.00) 10%,
      rgba(255,255,255,0.10) 35%,
      rgba(255,255,255,0.00) 60%);
  transform: translate3d(calc((var(--mx, 50) - 50) * -0.25%), calc((var(--my, 50) - 50) * -0.25%), 40px) rotate(8deg);
  opacity: 0.35;
  mix-blend-mode: screen;
}

.cc-face::after{
  content:'';
  position:absolute;
  inset:0;
  pointer-events:none;
  background: radial-gradient(circle at calc(var(--mx, 50) * 1%) calc(var(--my, 50) * 1%),
    rgba(212,175,55,0.22) 0%,
    rgba(74,144,226,0.12) 18%,
    transparent 55%);
}

.cc-corner{
  font-family: 'Fira Code', monospace;
  font-weight: 900;
  font-size: 46px;
  line-height: 1;
}
.cc-corner.bottom{
  transform: rotate(180deg);
  align-self: flex-end;
}

.cc-suit{
  font-size: 150px;
  line-height: 1;
  margin: auto;
  transform: translateZ(30px);
}

.cc-back-title{
  font-weight: 900;
  font-size: 18px;
  margin-bottom: 8px;
}
.cc-back-lines{
  color: rgba(219, 234, 254, 0.92);
  text-shadow: none;
  font-size: 13px;
  line-height: 1.45;
}
.cc-back-lines .k{
  color: var(--noir-soft-gold);
  font-weight: 800;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

@keyframes shimmer {
  to { background-position: 200% center; }
}

.cc-reveal-meta{
  width: min(620px, 92vw);
  text-align: center;
}

.cc-name{
  font-size: 20px;
  font-weight: 900;
  margin-bottom: 6px;
}
.cc-summary{
  color: var(--text-secondary);
  line-height: 1.5;
  margin-bottom: 14px;
}

.cc-reveal-actions{
  display: flex;
  gap: 10px;
  justify-content: center;
  flex-wrap: wrap;
}

@keyframes ccFloat{
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
}

@keyframes ccPop{
  0% { transform: translateY(0px); }
  40% { transform: translateY(-18px); }
  100% { transform: translateY(0px); }
}

@media (prefers-reduced-motion: reduce){
  .cc-float{ animation: none !important; }
  .cc-flip{ transition: none !important; }
}

    .score-flash {
      animation: scorePulse 1.05s ease-in-out;
      box-shadow: 0 0 0 2px rgba(255, 215, 128, 0.72), 0 0 22px rgba(255, 215, 128, 0.44);
    }
    @keyframes scorePulse {
      0% { transform: translateY(0) scale(1); }
      35% { transform: translateY(-2px) scale(1.015); }
      100% { transform: translateY(0) scale(1); }
    }

    .karma-pop {
      animation: karmaPop 0.6s ease-out;
      box-shadow: 0 0 0 2px rgba(125, 211, 252, 0.26);
    }
    @keyframes karmaPop {
      0% { transform: scale(1); }
      35% { transform: scale(1.16); }
      100% { transform: scale(1); }
    }

    .karma-float {
      position:absolute;
      left: 50%;
      bottom: -10px;
      transform: translateX(-50%);
      font-weight: 900;
      font-size: 18px;
      color: var(--accent-gold);
      text-shadow: 0 2px 10px rgba(0,0,0,0.6);
      pointer-events: none;
      animation: karmaFloatUp 900ms ease-out forwards;
      z-index: 10;
    }
    @keyframes karmaFloatUp{
      0%{ opacity:0; transform: translate(-50%, 10px) scale(0.95); }
      15%{ opacity:1; }
      100%{ opacity:0; transform: translate(-50%, -18px) scale(1.05); }
    }

    .lane-summary{
      margin-top: 8px;
      display:flex;
      justify-content: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .lane-summary b{
      color: var(--text-primary);
      font-weight: 800;
    }

    .scoring-mode .bj-position { opacity: 0.55; }
    .scoring-mode .bj-position.score-flash { opacity: 1; }

    .hud-calling {
      min-width: 240px;
      border: 1px solid var(--border-color);
      border-radius: 10px;
      background: var(--bg-card);
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .hud-calling-row { display: flex; justify-content: space-between; align-items: baseline; gap: 8px; }
    .hud-calling-main { font-family: 'Fira Code', monospace; font-weight: 800; color: var(--accent-gold); }
    .hud-calling-sub { font-size: 11px; color: var(--text-secondary); }
    .xpbar { width: 100%; height: 8px; border-radius: 999px; background: rgba(255,255,255,0.1); overflow: hidden; }
    .xpbar-fill { height: 100%; background: linear-gradient(90deg, #60a5fa, #7dd3fc); transition: width 0.25s ease; }
    .xpbar-text { font-size: 10px; color: var(--text-muted); text-align: right; }
    .calling-rank-pulse { animation: rankPulse 0.85s ease-in-out 2; }
    @keyframes rankPulse {
      0%,100% { box-shadow: 0 0 0 rgba(125,211,252,0); }
      50% { box-shadow: 0 0 0 2px rgba(125,211,252,0.35), 0 0 18px rgba(125,211,252,0.3); }
    }


    /* =========================================================
       Film Noir Typography Map (overrides hard-coded fonts)
       ========================================================= */
    .hud-btn, .modal-btn, .bj-btn, .log-mini-btn,
    .modal-header, .bj-title, .merchant-section-title,
    .bj-side-label, .bj-turn-info,
    .action-row-title, .bj-result-title, .end-title,
    .log-panel-title, .log-tab {
      font-family: var(--font-display) !important;
    }

    .hud-stat, .hud-stat-value,
    .hex-label, .hex-sub,
    .bj-position-num, .bj-total,
    .playing-card, .modal-reward,
    .bj-result-score, .bj-result-chips,
    .end-stat-value, .stat-value,
    .log-panel-sub, .log-card-head, .log-kv {
      font-family: var(--font-mono) !important;
    }

    @media (prefers-reduced-motion: reduce){
      *{ transition: none !important; }
      .hex-tile.available .hex-bg{ animation: none !important; }
      .boss-target{ animation: none !important; }
    }

  </style>
</head>

<body>
  <div id="startScreen" class="start-screen">
    <canvas id="startPlasma" class="start-plasma" aria-hidden="true"></canvas>

    <div class="start-shell">
      <div class="start-title">
        <div class="start-h1">Project 63</div>
        <div class="start-h2">The Pit</div>
        <div class="start-lore">A casino with no address. An indecipherable ledger. Will you test fate?</div>
      </div>

      <div class="start-card" id="startRunCard">
        <div class="start-card-top">Run</div>
        <div class="start-card-row" id="startRunSummary"></div>

        <div class="start-actions">
          <button class="hud-btn primary" id="btnContinue">Continue</button>
          <button class="hud-btn" id="btnNewRun">New Run</button>
        </div>
      </div>

      <div class="start-grid">
        <button class="hud-btn" id="btnRules">Rules</button>
        <button class="hud-btn" id="btnTestGames">Test Games</button>
        <button class="hud-btn" id="btnSettings">Settings</button>
        <button class="hud-btn" id="btnFeedback">Feedback</button>
      </div>
    </div>
  </div>

  <div id="introPlasmaLayer" class="intro-plasma-layer" aria-hidden="true">
    <canvas id="introPlasma" class="intro-plasma-canvas"></canvas>
  </div>

  <header id="hud"></header>

  <main id="app">
    <section id="boardView"></section>
    <section id="blackjackView" class="hidden"></section>
    <section id="endScreen" class="hidden"></section>
  </main>

  <div id="modalOverlay" class="hidden">
    <div id="modal"></div>
  </div>


  <div id="minigameOverlay" class="hidden" aria-hidden="true">
    <div class="minigame-shell">
      <div id="minigameTestBar" class="minigame-testbar hidden">
        <div class="minigame-testbar-title" id="minigameTestTitle">TEST MODE</div>
        <div class="minigame-testbar-actions">
          <button class="hud-btn" id="btnEndTest">END TEST</button>
        </div>
      </div>
      <iframe id="minigameFrame" title="Minigame" sandbox="allow-scripts"></iframe>
    </div>
  </div>

  <div id="toast" class="hidden"></div>
  <div id="cardTooltip" class="card-tooltip hidden"></div>
  <div id="actionTooltip" class="card-tooltip hidden"></div>
  <div id="tileTooltip" class="card-tooltip hidden"></div>

  <!-- Log Panel -->
  <aside id="logPanel" aria-label="Run Log"></aside>

  <template id="tplMinigamePokerSlots">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Project 63 â€” Poker Slot (Player Screen)</title>

  <!-- Match MVP typography -->
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ------------------------------------------------------------
      P63 MVP THEME (aligned with p63_0.47.html)
      ------------------------------------------------------------ */
    :root {
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-card: #262626;
      --bg-hover: #2c2c2c;

      --text-primary: #f5f5f5;
      --text-secondary: #b8b8b8;
      --text-muted: #737373;

      --accent-gold: #d4af37;
      --accent-gold-dim: #8a6f1f;
      --accent-red: #a83232;
      --accent-green: #5e8c61;
      --accent-blue: #5f7d95;
      --accent-purple: #7d6a82;

      --border-color: #404040;

      --card-red: #b13b3b;
      --card-black: #111111;

      --font-display: 'Bebas Neue', sans-serif;
      --font-mono: 'Space Mono', monospace;
      --font-body: 'Inter', sans-serif;

      --wash-gold: rgba(212, 175, 55, 0.14);
      --wash-red: rgba(168, 50, 50, 0.18);
      --wash-green: rgba(94, 140, 97, 0.18);
      --wash-blue: rgba(95, 125, 149, 0.16);
      --wash-purple: rgba(125, 106, 130, 0.16);

      --noir-bg-primary: #0f1119;
      --noir-bg-secondary: #141820;

      --panel: rgba(255,255,255,0.03);
      --panel-border: rgba(148,163,184,0.18);
      --panel-border-strong: rgba(148,163,184,0.26);

      --shadow: 0 18px 40px rgba(0,0,0,0.60);
      --radius: 16px;
    }

    *{ box-sizing: border-box; margin: 0; padding: 0; }

    body{
      font-family: var(--font-body);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 18px 14px 28px;
      background:
        radial-gradient(ellipse at 50% -10%, rgba(212,175,55,0.18), rgba(15,17,25,0.0) 55%),
        radial-gradient(ellipse at 40% 115%, rgba(95,125,149,0.18), rgba(15,17,25,0.0) 55%),
        linear-gradient(180deg, var(--noir-bg-primary), var(--bg-primary));
      -webkit-tap-highlight-color: transparent;
      overflow-x: hidden;
    }

    /* Vignette + faint texture (MVP-like) */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(ellipse at center, transparent 45%, rgba(0,0,0,0.55) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 2px, transparent 6px);
      opacity: 0.35;
      mix-blend-mode: overlay;
    }

    .shell{
      width: min(980px, 100%);
      border: 1px solid var(--panel-border-strong);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      background: linear-gradient(180deg, rgba(20,24,32,0.95), rgba(15,15,15,0.92));
      position: relative;
    }
    .shell::before{
      content:"";
      position:absolute;
      left:0; top:0; right:0;
      height:3px;
      background: linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55));
      opacity: 0.9;
    }

    /* Header */
    .top{
      padding: 18px 18px 14px;
      border-bottom: 1px solid var(--panel-border);
      background:
        radial-gradient(700px 260px at 12% 0%, rgba(212,175,55,0.14), transparent 70%),
        radial-gradient(700px 260px at 88% 0%, rgba(95,125,149,0.14), transparent 70%),
        rgba(255,255,255,0.02);
    }
    .row{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .titleWrap{ display:flex; flex-direction:column; gap:6px; }
    h1{
      margin: 0;
      font-family: var(--font-display);
      font-size: 2.2em;
      letter-spacing: 6px;
      color: var(--accent-gold);
      text-transform: uppercase;
      text-shadow: 0 0 18px rgba(212,175,55,0.22);
      line-height: 1;
    }
    .sub{
      margin: 0;
      color: var(--text-muted);
      font-size: 0.82em;
      letter-spacing: 2px;
      text-transform: uppercase;
      line-height: 1.45;
      max-width: 72ch;
    }

    /* Tabs */
    .tabs{ display:flex; gap:8px; align-items:center; }
    .tab{
      font-family: var(--font-display);
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 0.90em;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: rgba(255,255,255,0.03);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.18s;
      user-select: none;
    }
    .tab:hover{ background: rgba(212,175,55,0.06); border-color: rgba(212,175,55,0.35); }
    .tab.active{
      background: rgba(212,175,55,0.10);
      border-color: rgba(212,175,55,0.55);
      color: var(--text-primary);
      box-shadow: 0 0 0 2px rgba(212,175,55,0.08);
    }

    /* HUD */
    .hud{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1.1fr 0.9fr 1.4fr;
      gap: 10px;
    }
    @media (max-width: 820px){
      .hud{ grid-template-columns: 1fr 1fr; }
      .hud .box:nth-child(3){ grid-column: 1 / -1; }
    }

    .box{
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
      min-height: 62px;
      display:flex;
      flex-direction: column;
      justify-content: center;
    }
    .lbl{ font-size: 0.68em; color: var(--text-muted); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; }
    .val{ font-family: var(--font-mono); font-size: 1.05em; color: var(--text-primary); }
    .val small{ font-size: 0.78em; color: var(--text-secondary); margin-left: 6px; }

    .heatRow{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .meter{
      flex: 1 1 auto;
      height: 13px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(0,0,0,0.35);
      overflow:hidden;
      min-width: 150px;
    }
    .fill{
      height: 100%;
      width: 0%;
      border-radius: 10px;
      transition: width 0.35s ease;
      background: linear-gradient(90deg, rgba(94,140,97,0.95), rgba(212,175,55,0.90), rgba(168,50,50,0.95));
    }

    /* Mid */
    .mid{ padding: 14px 18px 12px; }

    .status{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding: 10px 12px;
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
    }
    .state{ font-family: var(--font-mono); font-size: 0.88em; color: var(--text-secondary); }

    .pills{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill{
      font-family: var(--font-mono);
      font-size: 0.78em;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.22);
      color: var(--text-secondary);
      white-space: nowrap;
    }

    /* Reels */
    .reels{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
    }
    @media (max-width: 780px){
      .reels{ grid-template-columns: repeat(2, 1fr); }
      /* Keep all cards the same size in portrait: center the last card but cap it to one-column width */
      .reels .reel:nth-child(5){
        grid-column: 1 / -1;
        justify-self: center;
        width: calc((100% - 10px) / 2); /* (grid width - gap) / 2 */
      }
    }

    .reel{
      position: relative;
      border-radius: 16px;
      padding: 10px;
      border: 1px solid var(--panel-border);
      background:
        radial-gradient(420px 160px at 20% 0%, rgba(212,175,55,0.10), transparent 65%),
        radial-gradient(420px 160px at 80% 100%, rgba(95,125,149,0.10), transparent 65%),
        rgba(255,255,255,0.02);
      user-select: none;
      cursor: pointer;
      transition: transform 0.16s, box-shadow 0.16s, border-color 0.16s, opacity 0.16s;
      min-height: 176px;
      display:flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 10px;
    }
    .reel:hover{ transform: translateY(-6px); box-shadow: 0 18px 36px rgba(0,0,0,0.55); border-color: rgba(212,175,55,0.35); }
    .reel.locked{ opacity: 0.82; cursor: default; transform: none; box-shadow: none; }
    .reel.held{
      border-color: rgba(212,175,55,0.70);
      box-shadow: 0 0 0 2px rgba(212,175,55,0.14), 0 18px 36px rgba(0,0,0,0.60);
    }

    .holdTag{
      font-family: var(--font-mono);
      font-size: 0.78em;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.22);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      width: max-content;
    }
    .dot{
      width: 8px; height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.12);
    }
    .reel.held .dot{ background: var(--accent-gold); box-shadow: 0 0 0 1px rgba(212,175,55,0.35), 0 0 14px rgba(212,175,55,0.25); }
    .reel.held .holdTag{ color: rgba(212,175,55,0.95); border-color: rgba(212,175,55,0.30); }

    .cardFace{ flex: 1; display:flex; align-items:center; justify-content:center; }

    /* Card itself (white) */
    .card{
      width: 100%;
      aspect-ratio: 2.5 / 3.5;
      border-radius: 14px;
      background: linear-gradient(180deg, #ffffff, #f3f3f5);
      color: var(--card-black);
      box-shadow: 0 10px 18px rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.10);
      isolation: isolate;
    }

    .corner{
      position:absolute;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap: 4px;
      font-weight: 800;
      font-family: var(--font-mono);
      font-size: 1.02em;
      line-height: 1;
      padding: 10px;
    }
    .corner.br{ right: 0; bottom: 0; transform: rotate(180deg); }

    .pip{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 3.2em;
      opacity: 0.92;
      text-shadow: 0 1px 0 rgba(0,0,0,0.08);
    }

    .shine{
      position:absolute;
      inset:-40% -60%;
      background: linear-gradient(110deg, transparent 0%, rgba(255,255,255,0.55) 35%, transparent 70%);
      transform: rotate(12deg) translateX(-40%);
      opacity: 0.32;
      pointer-events:none;
      mix-blend-mode: screen;
    }

    .spin .shine{ animation: shine 700ms linear infinite; }
    @keyframes shine{ 0%{ transform: rotate(12deg) translateX(-40%); } 100%{ transform: rotate(12deg) translateX(40%); } }

    .red{ color: var(--card-red) !important; }
    .blk{ color: var(--card-black) !important; }

    /* END GAME button row (below cards) */
    .endRow{
      margin-top: 12px;
      display:flex;
      justify-content:center;
      align-items:center;
    }

    /* Bottom controls */
    .bottom{
      padding: 12px 18px 16px;
      border-top: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.12);
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .btnGroup{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .btn{
      font-family: var(--font-display);
      font-size: 0.92em;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.18s;
      border: 1px solid var(--border-color);
      background: rgba(255,255,255,0.03);
      color: var(--text-primary);
    }
    .btn:hover:not(:disabled){ background: rgba(212,175,55,0.06); border-color: rgba(212,175,55,0.55); }
    .btn:disabled{ opacity: 0.40; cursor: not-allowed; }

    .btn-primary{
      background: rgba(95,125,149,0.22);
      border-color: rgba(95,125,149,0.70);
    }
    .btn-primary:hover:not(:disabled){ background: rgba(95,125,149,0.30); border-color: rgba(212,175,55,0.70); }

    .btn-warn{
      background: rgba(212,175,55,0.12);
      border-color: rgba(212,175,55,0.55);
    }
    .btn-warn:hover:not(:disabled){ background: rgba(212,175,55,0.18); }

    .btn-danger{
      background: rgba(168,50,50,0.10);
      border-color: rgba(168,50,50,0.55);
    }
    .btn-danger:hover:not(:disabled){ border-color: rgba(168,50,50,0.85); background: rgba(168,50,50,0.14); }

    .btn-ghost{ background: rgba(0,0,0,0.18); color: var(--text-secondary); }
    .btn-ghost:hover:not(:disabled){ border-color: rgba(148,163,184,0.55); background: rgba(255,255,255,0.03); }

    .help{
      margin-top: 10px;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
      color: var(--text-secondary);
      font-size: 0.86em;
      line-height: 1.35;
      align-items:center;
    }

    /* Modal */
    .modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 22px;
      z-index: 50;
      backdrop-filter: blur(3px);
    }
    .modal{
      width: min(560px, 100%);
      border-radius: 16px;
      border: 1px solid var(--panel-border-strong);
      background: linear-gradient(180deg, rgba(20,24,32,0.96), rgba(15,15,15,0.96));
      box-shadow: 0 0 60px rgba(0,0,0,0.60);
      overflow: hidden;
      position: relative;
    }
    .modal::before{
      content:"";
      position:absolute;
      left:0; top:0; right:0;
      height:3px;
      background: linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55));
    }
    .modalHead{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--panel-border);
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .modalHead h2{
      margin: 0;
      font-family: var(--font-display);
      color: var(--accent-gold);
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 1.25em;
    }
    .modalBody{ padding: 12px 14px 14px; }

    table{
      width: 100%;
      border-collapse: collapse;
      font-family: var(--font-mono);
      font-size: 0.86em;
      color: var(--text-secondary);
    }
    th, td{ border-bottom: 1px solid rgba(148,163,184,0.18); padding: 8px 8px; text-align: left; }
    th{ color: var(--text-muted); text-transform: uppercase; letter-spacing: 2px; font-size: 0.78em; }
    .right{ text-align:right; }


  </style>
</head>
<body>

  <div class="shell">
    <div class="top">
      <div class="row">
        <div class="titleWrap">
          <h1>Poker Slot</h1>
          <p class="sub">Hold cards. Spin for free rerolls. Bank, or overclock once the freebies run out.</p>
        </div>
        <div class="tabs">
          <div class="tab active" id="tabPlay">Play</div>
          <button class="btn btn-ghost" id="btnRules" type="button">Rules</button>
        </div>
      </div>

      <!-- PLAYER HUD (only what player sees) -->
      <div class="hud" id="playHud">
        <div class="box">
          <div class="lbl">Chips</div>
          <div class="val"><span id="credits">100</span> <small>in machine</small></div>
        </div>
        <div class="box">
          <div class="lbl">Spins</div>
          <div class="val"><span id="spinsLeft">â€”</span> <small>free</small></div>
        </div>
        <div class="box">
          <div class="lbl">Heat</div>
          <div class="heatRow">
            <div class="val"><span id="heatPct">0</span><small>%</small></div>
            <div class="meter" title="Burn chance increases with heat. Burnout resets heat to 0.">
              <div class="fill" id="heatFill"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- PLAY TAB -->
    <div id="playTab">
      <div class="mid">
        <div class="status">
          <div class="state" id="stateText">Ready.</div>
          <div class="pills">
            <span class="pill" id="handPill">Hand: â€”</span>
            <span class="pill" id="payoutPill">Payout: â€”</span>
            <span class="pill" id="burnPill">Burn: â€”</span>
          </div>
        </div>

        <div class="reels" id="reels"></div>

        <!-- Exit action requested: button below cards -->
        <div class="endRow">
          <button class="btn btn-ghost" id="btnEndGame">END GAME</button>
        </div>
      </div>

      <div class="bottom">
        <div class="btnRow">
          <div class="btnGroup" id="leftButtons"></div>
          <div class="btnGroup" id="rightButtons">
            <button class="btn btn-ghost" id="btnPaytable">Paytable</button>
          </div>
        </div>

        <div class="help">
          <div>
            <span class="pill" id="pillAnte">Next hand: âˆ’25</span>
            <span class="pill" id="pillHeatRule">Heat +10% on safe overclock</span>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Paytable modal -->
  <div class="modalBack" id="modalBack">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Paytable">
      <div class="modalHead">
        <h2>Paytable</h2>
        <button class="btn btn-ghost" id="btnCloseModal">Close</button>
      </div>
      <div class="modalBody">
        <table>
          <thead>
            <tr><th>Hand</th><th class="right">Mult</th><th class="right">Pays</th></tr>
          </thead>
          <tbody id="paytableBody"></tbody>
        </table>
      </div>
    </div>
  </div>


  <!-- Rules modal -->
  <div class="modalBack" id="rulesBack">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Rules">
      <div class="modalHead">
        <h2>Rules</h2>
        <button class="btn btn-ghost" id="btnCloseRules">Close</button>
      </div>
      <div class="modalBody">
        <ul style="margin:0; padding-left:18px; line-height:1.5; color:var(--text-secondary)">
          <li>Start a hand by paying the ante.</li>
          <li>Hold cards and use free spins to reroll unheld cards.</li>
          <li>Bank at any time to collect the current payout.</li>
          <li>When free spins are gone, you may overclock for one risky final reroll.</li>
          <li>Burnout resets heat; if embedded, your run ends when chips hit 0.</li>
        </ul>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------------- P63 Embed Bridge ----------------
  const P63_EMBED = (window.parent && window.parent !== window);
  const P63 = {
    send(type, payload={}) {
      if (!P63_EMBED) return;
      window.parent.postMessage({ __p63: 1, type, ...payload }, "*");
    }
  };
  // Tell parent weâ€™re alive (optional but helpful)
  P63.send("P63_MINIGAME_READY", { kind: "POKER_SLOTS" });

  let P63_ENDED = false;


  window.addEventListener("message", (e) => {
    const d = e.data;
    if (!d || d.__p63 !== 1 || d.type !== "P63_INIT" || d.kind !== "POKER_SLOTS") return;
    if (typeof d.startChips === "number") CFG.startChips = d.startChips;
    if (typeof d.ante === "number") CFG.ante = d.ante;
    if (typeof d.freeSpins === "number") CFG.freeSpins = d.freeSpins;
    if (typeof d.baseBurn === "number") CFG.baseBurn = d.baseBurn;
    if (typeof d.heatStep === "number") CFG.heatStep = d.heatStep;

    // reset session with new CFG
    SESSION.chips = CFG.startChips;
    SESSION.heat = 0;
    resetToReady("Ready.");
    updateHUD();
  });

  // ---------------- Runtime settings ----------------
  let CFG = {
    startChips: 100,
    ante: 25,
    freeSpins: 2,
    baseBurn: 15,   // %
    heatStep: 10,   // %
  };

  // Updated payout table (as provided)
  const PAYTABLE = [
    {key:"Royal Flush", mult:20},
    {key:"Straight Flush", mult:10},
    {key:"Four of a Kind", mult:8},
    {key:"Full House", mult:6},
    {key:"Flush", mult:5},
    {key:"Straight", mult:4},
    {key:"Three of a Kind", mult:3},
    {key:"Two Pair", mult:2},
    {key:"One Pair", mult:1},
    {key:"No Win", mult:0},
  ];

  // ---------------- RNG ----------------
  const rng = () => Math.random();
  const rint = (n) => Math.floor(rng() * n);
  const clamp = (n,a,b)=>Math.max(a, Math.min(b,n));

  // ---------------- Cards / Deck ----------------
  const SUITS = [
    {k:'S', sym:'\u2660', color:'blk'},
    {k:'H', sym:'\u2665', color:'red'},
    {k:'D', sym:'\u2666', color:'red'},
    {k:'C', sym:'\u2663', color:'blk'},
  ];
  const RANKS = [
    {k:'2', v:2},{k:'3', v:3},{k:'4', v:4},{k:'5', v:5},{k:'6', v:6},{k:'7', v:7},
    {k:'8', v:8},{k:'9', v:9},{k:'10', v:10},{k:'J', v:11},{k:'Q', v:12},{k:'K', v:13},{k:'A', v:14}
  ];

  function buildDeck(){
    const deck = [];
    for (const s of SUITS){
      for (const r of RANKS){
        deck.push({ id: r.k + s.k, rank:r.k, rv:r.v, suit:s.k, sym:s.sym, color:s.color });
      }
    }
    return deck;
  }
  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = rint(i+1);
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  // ---------------- Hand evaluation (all standard hands) ----------------
  function isStraight(uniq){
    if (uniq.length !== 5) return {ok:false, high:0};
    // wheel A-2-3-4-5
    const wheel = [2,3,4,5,14];
    const isWheel = wheel.every(v=>uniq.includes(v));
    if (isWheel) return {ok:true, high:5};
    const min = uniq[0], max = uniq[4];
    if (max - min === 4) return {ok:true, high:max};
    return {ok:false, high:0};
  }
  function rankToLabel(rv){
    const map = {14:'A',13:'K',12:'Q',11:'J',10:'10',9:'9',8:'8',7:'7',6:'6',5:'5',4:'4',3:'3',2:'2'};
    return map[String(rv)] || String(rv);
  }

  function evaluate(cards){
    const ranks = cards.map(c=>c.rv).sort((a,b)=>a-b);
    const suits = cards.map(c=>c.suit);
    const flush = suits.every(s=>s===suits[0]);

    const uniq = Array.from(new Set(ranks)).sort((a,b)=>a-b);
    const straight = isStraight(uniq);

    const countMap = new Map();
    for (const rv of ranks) countMap.set(rv, (countMap.get(rv)||0)+1);
    const counts = Array.from(countMap.entries())
      .map(([rv,ct])=>({rv,ct}))
      .sort((a,b)=> b.ct - a.ct || b.rv - a.rv);

    const highStraight = straight.high;
    const isRoyal = flush && straight.ok && highStraight===14 && ranks.includes(10);

    let category = "High Card";
    let detail = `High ${rankToLabel(ranks[4])}`;

    if (isRoyal){
      category = "Royal Flush"; detail = "A high";
    } else if (flush && straight.ok){
      category = "Straight Flush"; detail = `${rankToLabel(highStraight)} high`;
    } else if (counts[0].ct === 4){
      category = "Four of a Kind"; detail = `${rankToLabel(counts[0].rv)}s`;
    } else if (counts[0].ct === 3 && counts[1].ct === 2){
      category = "Full House"; detail = `${rankToLabel(counts[0].rv)}s full of ${rankToLabel(counts[1].rv)}s`;
    } else if (flush){
      category = "Flush"; detail = `${rankToLabel(ranks[4])} high`;
    } else if (straight.ok){
      category = "Straight"; detail = `${rankToLabel(highStraight)} high`;
    } else if (counts[0].ct === 3){
      category = "Three of a Kind"; detail = `${rankToLabel(counts[0].rv)}s`;
    } else if (counts[0].ct === 2 && counts[1].ct === 2){
      category = "Two Pair";
      const hi = Math.max(counts[0].rv, counts[1].rv);
      const lo = Math.min(counts[0].rv, counts[1].rv);
      detail = `${rankToLabel(hi)}s and ${rankToLabel(lo)}s`;
    } else if (counts[0].ct === 2){
      category = "One Pair"; detail = `${rankToLabel(counts[0].rv)}s`;
    }

    // Map to payout row
    let payoutKey = "No Win";
    if (category === "Royal Flush") payoutKey = "Royal Flush";
    else if (category === "Straight Flush") payoutKey = "Straight Flush";
    else if (category === "Four of a Kind") payoutKey = "Four of a Kind";
    else if (category === "Full House") payoutKey = "Full House";
    else if (category === "Flush") payoutKey = "Flush";
    else if (category === "Straight") payoutKey = "Straight";
    else if (category === "Three of a Kind") payoutKey = "Three of a Kind";
    else if (category === "Two Pair") payoutKey = "Two Pair";
    else if (category === "One Pair") payoutKey = "One Pair";

    const row = PAYTABLE.find(x=>x.key===payoutKey) || {mult:0};
    const mult = row.mult || 0;
    const payout = Math.round(mult * CFG.ante);

    return {category, detail, payoutKey, mult, payout};
  }

  // ---------------- UI refs ----------------
  const $ = (id)=>document.getElementById(id);
  const els = {
    tabPlay: $("tabPlay"),
    btnRules: $("btnRules"),
    playTab: $("playTab"),

    credits: $("credits"),
    spinsLeft: $("spinsLeft"),
    heatPct: $("heatPct"),
    heatFill: $("heatFill"),

    stateText: $("stateText"),
    handPill: $("handPill"),
    payoutPill: $("payoutPill"),
    burnPill: $("burnPill"),

    reels: $("reels"),

    leftButtons: $("leftButtons"),
    rightButtons: $("rightButtons"),

    pillAnte: $("pillAnte"),
    pillHeatRule: $("pillHeatRule"),

    btnEndGame: $("btnEndGame"),

    btnPaytable: $("btnPaytable"),
    modalBack: $("modalBack"),
    btnCloseModal: $("btnCloseModal"),
    paytableBody: $("paytableBody"),

    rulesBack: $("rulesBack"),
    btnCloseRules: $("btnCloseRules"),

  };

  // ---------------- State ----------------
  const SESSION = { chips: CFG.startChips, heat: 0 };

  const HAND = {
    phase: "READY",   // READY | HOLDING | RESOLVED | BURNED | SPINNING
    cards: [null,null,null,null,null],
    held: [false,false,false,false,false],
    spinsLeft: 0,
    deck: [],
    eval: null,
    lastWinnings: 0,   // winnings from THIS hand only
  };

  function burnChance(){
    return clamp(CFG.baseBurn + SESSION.heat, 0, 95);
  }

  // ---------------- Rendering ----------------
  function cardHTML(card, spinning){
    const rank = card ? card.rank : "\u2014";
    const sym = card ? card.sym : "\u2022";
    const color = card ? card.color : "blk";
    return `
      <div class="card ${spinning ? 'spin':''}">
        <div class="shine"></div>
        <div class="corner ${color}">
          <div>${rank}</div>
          <div style="font-size:1.05em">${sym}</div>
        </div>
        <div class="corner br ${color}">
          <div>${rank}</div>
          <div style="font-size:1.05em">${sym}</div>
        </div>
        <div class="pip ${color}">${sym}</div>
      </div>
    `;
  }

  function canToggleHold(){ return HAND.phase === "HOLDING"; }

  function renderReels(spinningMask){
    els.reels.innerHTML = "";
    for (let i=0;i<5;i++){
      const reel = document.createElement("div");
      const held = HAND.held[i];
      const locked = !canToggleHold();
      reel.className = "reel" + (held ? " held":"") + (locked ? " locked":"");
      reel.setAttribute("role","button");
      reel.setAttribute("tabindex","0");

      const tag = held ? "HOLD" : (locked ? "\u2014" : "TAP TO HOLD");
      reel.innerHTML = `
        <div class="holdTag"><span class="dot"></span><span>${tag}</span></div>
        <div class="cardFace">${cardHTML(HAND.cards[i], !!(spinningMask && spinningMask[i]))}</div>
      `;

      reel.addEventListener("click", ()=>toggleHold(i));
      reel.addEventListener("keydown", (e)=>{
        if (e.key==="Enter" || e.key===" "){ e.preventDefault(); toggleHold(i); }
      });

      els.reels.appendChild(reel);
    }
  }

  function setStateText(t){ els.stateText.textContent = t; }

  function updateHUD(){
    els.credits.textContent = String(SESSION.chips);
    els.spinsLeft.textContent = (HAND.phase==="HOLDING") ? String(HAND.spinsLeft) : "\u2014";

    els.heatPct.textContent = String(Math.round(SESSION.heat));
    els.heatFill.style.width = `${clamp(SESSION.heat,0,95)}%`;

    els.pillAnte.textContent = `Next hand: \u2212${CFG.ante}`;
    els.pillHeatRule.textContent = `Heat +${CFG.heatStep}% on safe overclock`;
    els.burnPill.textContent = `Burn: ${burnChance()}%`;

    // Disable global buttons during spin
    const disabledGlobal = (HAND.phase === "SPINNING");
    els.btnPaytable.disabled = disabledGlobal;
    els.btnRules.disabled = disabledGlobal;
    els.btnEndGame.disabled = disabledGlobal;

    if (HAND.eval){
      els.handPill.textContent = `Hand: ${HAND.eval.category} (${HAND.eval.detail})`;
      const p = HAND.eval.payout;
      if (HAND.phase==="HOLDING"){
        els.payoutPill.textContent = `Payout: ${p>0 ? "+"+p : "0"}`;
      } else if (HAND.phase==="RESOLVED"){
        els.payoutPill.textContent = `Won: ${HAND.lastWinnings>0 ? "+"+HAND.lastWinnings : "0"}`;
      } else if (HAND.phase==="BURNED"){
        els.payoutPill.textContent = "Won: 0";
      } else {
        els.payoutPill.textContent = `Payout: ${p>0 ? "+"+p : "0"}`;
      }
    } else {
      els.handPill.textContent = "Hand: \u2014";
      els.payoutPill.textContent = "Payout: \u2014";
    }

    rebuildButtons();

    // Embedded rule: if you hit 0 chips, the machine run ends.
    // (Donâ€™t end mid-hand; allow a hand already in play to resolve.)
    if (P63_EMBED && SESSION.chips <= 0 && HAND.phase !== "HOLDING" && HAND.phase !== "SPINNING"){
      // Avoid double-fire if updateHUD runs again during close
      els.btnEndGame.disabled = true;
      endGame("broke");
      return;
    }
  }

  function rebuildButtons(){
    els.leftButtons.innerHTML = "";

    const mk = (label, kind, onClick, disabled=false) => {
      const b = document.createElement("button");
      b.textContent = label;
      b.className = `btn ${kind}`;
      b.disabled = disabled;
      b.addEventListener("click", onClick);
      return b;
    };

    if (HAND.phase === "READY"){
      const disabled = SESSION.chips < CFG.ante;
      els.leftButtons.appendChild(mk(`Next Hand (\u2212${CFG.ante})`, "btn-primary", startHand, disabled));
      return;
    }

    if (HAND.phase === "HOLDING"){
      // Only show what is necessary:
      // - if spins left: SPIN + BANK
      // - if no spins left: BANK + OVERCLOCK
      if (HAND.spinsLeft > 0){
        els.leftButtons.appendChild(mk("Spin", "btn-primary", spinFree));
        els.leftButtons.appendChild(mk("Bank", "btn-warn", bank));
      } else {
        els.leftButtons.appendChild(mk("Bank", "btn-warn", bank));
        els.leftButtons.appendChild(mk("Overclock", "btn-danger", overclock));
      }
      return;
    }

    if (HAND.phase === "RESOLVED"){
      els.leftButtons.appendChild(mk(`Next Hand (\u2212${CFG.ante})`, "btn-primary", startHand, SESSION.chips < CFG.ante));
      return;
    }

    if (HAND.phase === "BURNED"){
      els.leftButtons.appendChild(mk(`Next Hand (\u2212${CFG.ante})`, "btn-primary", startHand, SESSION.chips < CFG.ante));
      return;
    }
    // SPINNING: no buttons
  }

  function renderPaytable(){
    els.paytableBody.innerHTML = "";
    for (const row of PAYTABLE){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${row.key}</td><td class="right">${row.mult}\u00d7</td><td class="right">${Math.round(row.mult*CFG.ante)}</td>`;
      els.paytableBody.appendChild(tr);
    }
  }

  // ---------------- Logic ----------------
  function resetToReady(msg="Ready."){
    HAND.phase = "READY";
    HAND.cards = [null,null,null,null,null];
    HAND.held = [false,false,false,false,false];
    HAND.spinsLeft = 0;
    HAND.deck = [];
    HAND.eval = null;
    HAND.lastWinnings = 0;

    renderReels([false,false,false,false,false]);
    setStateText(msg);
    updateHUD();
  }

  function toggleHold(i){
    if (!canToggleHold()) return;
    HAND.held[i] = !HAND.held[i];
    renderReels([false,false,false,false,false]);
    updateHUD();
  }

  function dealFromDeck(){ return HAND.deck.pop(); }

  function setEvaluation(){
    if (HAND.cards.some(c=>!c)){ HAND.eval = null; return; }
    HAND.eval = evaluate(HAND.cards);
  }

  function randomCardFace(){
    const s = SUITS[rint(SUITS.length)];
    const r = RANKS[rint(RANKS.length)];
    return { id: r.k + s.k, rank:r.k, rv:r.v, suit:s.k, sym:s.sym, color:s.color };
  }

  function animateSpin(spinningMask, onDone){
    HAND.phase = "SPINNING";
    setStateText("Spinning\u2026");
    renderReels(spinningMask);
    updateHUD();

    const base = 520, stagger = 110;
    let finished = 0;

    for (let i=0;i<5;i++){
      if (!spinningMask[i]){ finished++; continue; }
      const stopAt = base + i*stagger + rint(140);
      const start = performance.now();

      const t = setInterval(()=>{
        const elapsed = performance.now() - start;
        const fake = randomCardFace();
        const reels = els.reels.children;
        if (reels[i]){
          const face = reels[i].querySelector(".cardFace");
          if (face) face.innerHTML = cardHTML(fake, true);
        }
        if (elapsed >= stopAt){
          clearInterval(t);
          const reels2 = els.reels.children;
          if (reels2[i]){
            const face = reels2[i].querySelector(".cardFace");
            if (face) face.innerHTML = cardHTML(HAND.cards[i], false);
          }
          finished++;
          if (finished >= 5) setTimeout(onDone, 120);
        }
      }, 55);
    }
    if (finished >= 5) setTimeout(onDone, 80);
  }

  function startHand(){
    if (HAND.phase !== "READY" && HAND.phase !== "RESOLVED" && HAND.phase !== "BURNED") return;
    if (SESSION.chips < CFG.ante) return;

    SESSION.chips -= CFG.ante;

    HAND.deck = shuffle(buildDeck());
    HAND.held = [false,false,false,false,false];
    HAND.spinsLeft = CFG.freeSpins;
    HAND.lastWinnings = 0;

    for (let i=0;i<5;i++) HAND.cards[i] = dealFromDeck();

    animateSpin([true,true,true,true,true], ()=>{
      setEvaluation();
      HAND.phase = "HOLDING";
      setStateText("Tap to hold. Spin for free rerolls, or bank your payout.");
      updateHUD();
    });
  }

  function spinFree(){
    if (HAND.phase !== "HOLDING") return;
    if (HAND.spinsLeft <= 0) return;

    const mask = [false,false,false,false,false];
    for (let i=0;i<5;i++){
      if (!HAND.held[i]){
        HAND.cards[i] = dealFromDeck();
        mask[i] = true;
      }
    }
    HAND.spinsLeft -= 1;

    animateSpin(mask, ()=>{
      setEvaluation();
      HAND.phase = "HOLDING";
      setStateText(HAND.spinsLeft > 0
        ? "Adjust holds. Spin again, or bank."
        : "No spins left. Bank now\u2026 or overclock."
      );
      updateHUD();
    });
  }

  function bank(){
    if (HAND.phase !== "HOLDING") return;
    const pay = HAND.eval ? HAND.eval.payout : 0;

    SESSION.chips += pay;
    HAND.lastWinnings = pay;

    HAND.phase = "RESOLVED";
    HAND.held = [false,false,false,false,false];

    setStateText(pay > 0 ? `Banked +${pay}.` : "No win.");
    updateHUD();
  }

  function overclock(){
    if (HAND.phase !== "HOLDING") return;
    if (HAND.spinsLeft !== 0) return;

    const p = burnChance() / 100;
    const roll = rng();

    if (roll < p){
      // Burnout: Overclock must always sting.
      // If you currently have a payout showing, wipe it. Otherwise, charge a flat penalty (defaults to 25 via ante).
      const shownPay = (HAND.eval ? HAND.eval.payout : 0);
      const penalty = CFG.ante;

      SESSION.heat = 0;

      if (shownPay > 0){
        HAND.lastWinnings = 0;
        HAND.phase = "BURNED";
        HAND.held = [false,false,false,false,false];
        setStateText("Burnout. Payout wiped. Heat reset.");
      } else {
        SESSION.chips = Math.max(0, SESSION.chips - penalty);
        HAND.lastWinnings = 0;
        HAND.phase = "BURNED";
        HAND.held = [false,false,false,false,false];
        setStateText(`Burnout. Lost ${penalty} chips. Heat reset.`);
      }

      updateHUD();
      return;
    }

    // Safe: heat increases; one final reroll of unheld; auto-bank.
    SESSION.heat = clamp(SESSION.heat + CFG.heatStep, 0, 95);

    const mask = [false,false,false,false,false];
    for (let i=0;i<5;i++){
      if (!HAND.held[i]){
        HAND.cards[i] = dealFromDeck();
        mask[i] = true;
      }
    }

    animateSpin(mask, ()=>{
      setEvaluation();
      const pay = HAND.eval ? HAND.eval.payout : 0;
      SESSION.chips += pay;

      HAND.lastWinnings = pay;

      HAND.phase = "RESOLVED";
      HAND.held = [false,false,false,false,false];

      setStateText(pay > 0 ? `Overclock banked +${pay}. Heat rose.` : "Overclock banked 0. Heat rose.");
      updateHUD();
    });
  }

  // ---------------- Tabs ----------------
  function showPlay(){
    els.tabPlay.classList.add("active");
    els.playTab.style.display = "";
  }

  els.tabPlay.addEventListener("click", showPlay);

  // ---------------- Modal ----------------
  function openPaytable(){ els.modalBack.style.display = "flex"; renderPaytable(); }
  function closePaytable(){ els.modalBack.style.display = "none"; }
  function openRules(){ els.rulesBack.style.display = "flex"; }
  function closeRules(){ els.rulesBack.style.display = "none"; }

  els.btnPaytable.addEventListener("click", openPaytable);
  els.btnCloseModal.addEventListener("click", closePaytable);
  els.modalBack.addEventListener("click", (e)=>{ if (e.target === els.modalBack) closePaytable(); });

  els.btnRules.addEventListener("click", openRules);
  els.btnCloseRules.addEventListener("click", closeRules);
  els.rulesBack.addEventListener("click", (e)=>{ if (e.target === els.rulesBack) closeRules(); });

  document.addEventListener("keydown", (e)=>{
    if (e.key!=="Escape") return;
    closePaytable();
    closeRules();
  });

  // ---------------- End Game ----------------
  function endGame(reason){
    if (P63_ENDED) return;
    P63_ENDED = true;

    const cashOut = SESSION.chips;

    if (P63_EMBED){
      // Parent owns what happens next (chips credit + close overlay)
      P63.send("P63_MINIGAME_END", { kind:"POKER_SLOTS", reason, cashOut });
      return;
    }

    // Standalone fallback behavior:
    SESSION.chips = CFG.startChips;
    SESSION.heat = 0;
    resetToReady(`Ended game. Cashed out ${cashOut}.`);
    P63_ENDED = false;
  }

  els.btnEndGame.addEventListener("click", ()=> endGame("cashout"));

  // ---------------- Boot ----------------
  renderReels([false,false,false,false,false]);
  setStateText("Ready.");
  updateHUD();
  showPlay();
})();
</script>
</body>
</html>

  </template>

  <template id="tplMinigameInfiltration">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project 63 â€” Infiltration Run (Scoundrel Variant)</title>

  <!-- Match MVP typography -->
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ------------------------------------------------------------
      P63 MVP THEME (kept compatible with p63_0.47.html)
      ------------------------------------------------------------ */
    :root {
      /* Film Noir â€” Default Theme */
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-card: #262626;
      --bg-hover: #2c2c2c;

      --text-primary: #f5f5f5;
      --text-secondary: #b8b8b8;
      --text-muted: #737373;

      --accent-gold: #d4af37;
      --gold-rgb: 212,175,55;
      --accent-gold-dim: #8a6f1f;
      --accent-red: #a83232;
      --accent-green: #5e8c61;
      --accent-blue: #5f7d95;
      --accent-purple: #7d6a82;

      --border-color: #404040;

      /* Playing card ink (used on white cards) */
      --card-red: #b13b3b;
      --card-black: #111111;

      /* Typography */
      --font-display: 'Bebas Neue', sans-serif;
      --font-mono: 'Space Mono', monospace;
      --font-body: 'Inter', sans-serif;

      /* Derived wash colors */
      --wash-gold: rgba(212, 175, 55, 0.14);
      --wash-red: rgba(168, 50, 50, 0.18);
      --wash-green: rgba(94, 140, 97, 0.18);
      --wash-blue: rgba(95, 125, 149, 0.16);
      --wash-purple: rgba(125, 106, 130, 0.16);

      /* Noir polish */
      --noir-bg-primary: #0f1119;
      --noir-bg-secondary: #141820;
      --noir-shadow-gold: #261d0d;
      --noir-muted-gold: #6c5b21;
      --noir-soft-gold: #d4af37;
      --noir-text-primary: #e4e4e7;
      --noir-text-secondary: #a1a1aa;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-body);
      background:
        radial-gradient(ellipse at 50% -10%, rgba(212,175,55,0.18), rgba(15,17,25,0.0) 55%),
        radial-gradient(ellipse at 40% 115%, rgba(95,125,149,0.18), rgba(15,17,25,0.0) 55%),
        linear-gradient(180deg, var(--noir-bg-primary), var(--bg-primary));
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 16px 40px;
      -webkit-tap-highlight-color: transparent;
    }

    h1 {
      font-family: var(--font-display);
      font-size: 2.6em;
      letter-spacing: 6px;
      color: var(--accent-gold);
      text-shadow: 0 0 18px rgba(212,175,55,0.22);
      margin: 10px 0 4px;
      text-transform: uppercase;
    }
    .subtitle {
      color: var(--text-muted);
      font-size: 0.82em;
      letter-spacing: 2px;
      margin-bottom: 16px;
      text-transform: uppercase;
    }

    #game-container { width: 100%; max-width: 760px; }


    /* â”€â”€ STATS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .stats {
      display: flex;
      gap: 14px;
      align-items: stretch;
      margin-bottom: 14px;
      padding: 12px 14px;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.65), rgba(95,125,149,0.45)) top/100% 3px no-repeat,
        rgba(255,255,255,0.03);
      border: 1px solid rgba(148, 163, 184, 0.20);
      border-radius: 14px;
    }
    .meter-section { flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .stat-label { font-size: 0.68em; color: var(--text-muted); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; }
    .meter-bg  { height: 13px; background: rgba(0,0,0,0.35); border-radius: 10px; border: 1px solid rgba(148,163,184,0.25); overflow: hidden; }
    .meter-bar { height: 100%; border-radius: 10px; transition: width 0.35s ease, background 0.35s; }
    .meter-text { font-family: var(--font-mono); font-size: 0.78em; margin-top: 5px; text-align: right; color: var(--text-secondary); }

    .stat-box {
      text-align: center;
      display: flex; flex-direction: column; justify-content: center;
      padding: 0 12px;
      border-left: 1px solid rgba(148,163,184,0.18);
      min-width: 120px;
    }
    .tool-val { font-family: var(--font-mono); font-size: 1.02em; color: var(--text-primary); white-space: nowrap; }
    .tool-val.none { color: rgba(255,255,255,0.25); font-style: italic; }
    .tool-cap { font-family: var(--font-body); font-size: 0.70em; color: var(--text-muted); margin-top: 3px; white-space: nowrap; }
    .deck-num { font-family: var(--font-display); font-size: 1.9em; color: var(--accent-gold); line-height: 1; letter-spacing: 2px; }

    /* â”€â”€ COVER USED BANNER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .cover-banner {
      text-align: center;
      font-size: 0.76em;
      color: rgba(212,175,55,0.85);
      letter-spacing: 1px;
      margin: 0 0 10px;
      padding: 6px 10px;
      background: rgba(212,175,55,0.08);
      border: 1px solid rgba(212,175,55,0.18);
      border-radius: 10px;
      display: none;
    }
    .cover-banner.visible { display: block; }

    /* â”€â”€ NODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .node-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 10px;
    }
    .node-label {
      font-size: 0.72em;
      color: var(--text-muted);
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .progress-label {
      font-family: var(--font-mono);
      font-size: 0.78em;
      color: var(--text-secondary);
    }

    .node {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 12px;
      min-height: 184px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* â”€â”€ CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .card {
      width: 118px;
      height: 178px;
      background: white;
      border-radius: 12px;
      border: 2px solid rgba(221,221,221,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: transform 0.16s, box-shadow 0.16s, opacity 0.25s;
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
      user-select: none;
      isolation: isolate;
    }

    .card::before{
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 12px;
      opacity: 0.0;
      pointer-events: none;
      transition: opacity 0.16s;
      background: radial-gradient(ellipse at 50% 20%, rgba(212,175,55,0.25), rgba(212,175,55,0.0) 55%);
    }

    .card:hover:not(.played):not(.no-interact) {
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 18px 36px rgba(0,0,0,0.75);
      z-index: 5;
    }
    .card:hover:not(.played):not(.no-interact)::before{ opacity: 1; }

    .card.played {
      opacity: 0.16;
      cursor: default;
      pointer-events: none;
      transform: scale(0.96);
    }
    .card.no-interact { cursor: not-allowed; }

    /* Type borders (use MVP accents) */
    .card.detection { border-color: rgba(168, 50, 50, 0.85); }
    .card.cover     { border-color: rgba(94, 140, 97, 0.85); }
    .card.tool      { border-color: rgba(95, 125, 149, 0.85); }
    .card.tool-locked { border-color: rgba(212,175,55,0.75); }
    .card.cover-spent { opacity: 0.80; border-color: rgba(94, 140, 97, 0.45); }

    .card.red-suit   .cv, .card.red-suit   .cs,
    .card.red-suit   .big-suit, .card.red-suit .big-val { color: var(--card-red); }
    .card.black-suit .cv, .card.black-suit .cs,
    .card.black-suit .big-suit, .card.black-suit .big-val { color: var(--card-black); }

    .corner { position: absolute; display: flex; flex-direction: column; align-items: center; line-height: 1; font-family: var(--font-mono); }
    .corner.tl { top: 8px; left: 10px; }
    .corner.br { bottom: 8px; right: 10px; transform: rotate(180deg); }
    .cv { font-size: 1.02em; font-weight: 800; }
    .cs { font-size: 0.86em; }

    .card-center { display: flex; flex-direction: column; align-items: center; gap: 1px; }
    .big-suit { font-size: 2.6em; line-height: 1; }
    .big-val  { font-family: var(--font-mono); font-size: 1.28em; font-weight: 800; line-height: 1; }
    .card-type-tag {
      font-family: var(--font-body);
      font-size: 0.60em;
      letter-spacing: 1.3px;
      text-transform: uppercase;
      color: rgba(0,0,0,0.55);
      margin-top: 4px;
      font-weight: 700;
      text-align: center;
    }
    .card-sub {
      font-family: var(--font-mono);
      font-size: 0.62em;
      font-weight: 700;
      margin-top: 4px;
      text-align: center;
    }
    .card-sub.exposure-reduced { color: #2f6b3a; }
    .card-sub.exposure-locked  { color: #8a6f1f; }
    .card-sub.exposure-full    { color: #8a2010; }
    .card-sub.no-cover         { color: #6b5b20; font-style: italic; }

    .card.detection.danger { border-width: 3px; border-color: rgba(168, 50, 50, 1.0); }
    .card.detection.danger::after{
      content: "!";
      position: absolute; top: -10px; right: -10px;
      font-family: var(--font-display);
      font-size: 0.95em;
      color: rgba(168, 50, 50, 1.0);
      width: 22px; height: 22px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 999px;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(168, 50, 50, 0.7);
      box-shadow: 0 0 14px rgba(168, 50, 50, 0.25);
    }

    /* â”€â”€ ACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .actions {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .btn {
      font-family: var(--font-display);
      font-size: 0.90em;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.18s;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
    }
    .btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .btn:disabled { opacity: 0.40; cursor: not-allowed; }

    .btn-secondary { background: rgba(255,255,255,0.03); color: var(--text-secondary); }
    .btn-secondary:hover:not(:disabled) { border-color: rgba(148,163,184,0.6); }
    .btn-primary {
      background: rgba(95,125,149,0.22);
      border-color: rgba(95,125,149,0.70);
      color: var(--text-primary);
    }
    .btn-primary:hover:not(:disabled) { border-color: var(--accent-gold); background: rgba(95,125,149,0.30); }

    .btn-branch {
      background: rgba(212,175,55,0.12);
      border-color: rgba(212,175,55,0.55);
    }
    .btn-branch:hover:not(:disabled) { background: rgba(212,175,55,0.18); }

    /* â”€â”€ LOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .log {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 14px;
      padding: 10px 14px;
      max-height: 120px;
      overflow-y: auto;
      font-size: 0.86em;
      line-height: 1.55;
      color: var(--text-secondary);
    }
    .log::-webkit-scrollbar { width: 4px; }
    .log::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.35); border-radius: 2px; }

    .log-entry { color: var(--text-secondary); }
    .log-entry.info   { color: rgba(245,245,245,0.75); }
    .log-entry.system { color: var(--accent-gold); font-style: italic; }
    .log-entry.exposure { color: rgba(168, 50, 50, 0.95); }
    .log-entry.cover  { color: rgba(94, 140, 97, 0.95); }
    .log-entry.tool   { color: rgba(95, 125, 149, 1.0); }
    .log-entry.branch { color: rgba(212,175,55,0.95); }

    /* â”€â”€ RULES PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .rules-panel {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 14px;
      padding: 14px 16px;
      margin-bottom: 14px;
      font-size: 0.86em;
      line-height: 1.55;
      color: var(--text-secondary);
      display: none;
    }
    .rules-panel.open { display: block; }
    .rules-panel h3 {
      font-family: var(--font-display);
      color: var(--accent-gold);
      margin-bottom: 10px;
      font-size: 1.2em;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .rules-panel b { color: rgba(245,245,245,0.82); }
    .rr { margin-bottom: 8px; }

    /* â”€â”€ CHALLENGE MODAL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .modal-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      z-index: 100;
      backdrop-filter: blur(3px);
    }
    .modal {
      background: linear-gradient(180deg, rgba(20,24,32,0.95), rgba(15,15,15,0.95));
      border: 1px solid rgba(148,163,184,0.26);
      border-radius: 16px;
      padding: 22px 20px;
      text-align: center;
      max-width: 380px;
      width: 92%;
      box-shadow: 0 0 60px rgba(0,0,0,0.55);
      position: relative;
      overflow: hidden;
    }
    .modal::before{
      content:"";
      position:absolute;
      left:0; top:0; right:0;
      height:3px;
      background: linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55));
    }
    .modal h3 {
      font-family: var(--font-display);
      color: var(--accent-gold);
      margin-bottom: 10px;
      font-size: 1.25em;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .modal .modal-body {
      color: var(--text-secondary);
      margin-bottom: 16px;
      font-size: 0.92em;
      line-height: 1.6;
    }
    .modal .modal-body strong { color: rgba(245,245,245,0.9); }
    .modal .degrade-note {
      display: block;
      margin-top: 10px;
      padding: 8px 10px;
      background: rgba(212,175,55,0.10);
      border: 1px solid rgba(212,175,55,0.18);
      border-radius: 10px;
      color: rgba(212,175,55,0.95);
      font-size: 0.92em;
    }
    .modal-btns { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .btn-use-tool {
      background: rgba(95,125,149,0.26);
      border-color: rgba(95,125,149,0.70);
    }
    .btn-use-tool:hover:not(:disabled){ border-color: var(--accent-gold); }
    .btn-manual {
      background: rgba(168,50,50,0.10);
      border-color: rgba(168,50,50,0.55);
    }
    .btn-manual:hover:not(:disabled){ border-color: rgba(168,50,50,0.85); }

    /* â”€â”€ ENDGAME â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .endgame {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.92);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 200;
      text-align: center;
      padding: 20px;
    }
    .endgame h2 {
      font-family: var(--font-display);
      font-size: 3em;
      letter-spacing: 6px;
      margin-bottom: 14px;
      text-transform: uppercase;
      animation: pulse 2s ease-in-out infinite;
    }
    .endgame.dead h2 { color: rgba(168,50,50,1.0); text-shadow: 0 0 34px rgba(168,50,50,0.55); }
    .endgame.win  h2 { color: var(--accent-gold); text-shadow: 0 0 34px rgba(212,175,55,0.35); }

    .endgame p {
      color: var(--text-secondary);
      margin-bottom: 18px;
      font-size: 1.02em;
      line-height: 1.55;
      max-width: 420px;
    }
    .endgame p strong { color: rgba(245,245,245,0.9); }

    .loot {
      width: 100%;
      max-width: 420px;
      margin: 0 auto 18px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 14px;
      padding: 12px 14px;
      text-align: left;
    }
    .loot-title{
      font-family: var(--font-display);
      font-size: 1.05em;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--accent-gold);
      margin-bottom: 8px;
    }
    .loot-item{
      font-family: var(--font-mono);
      font-size: 0.90em;
      color: var(--text-primary);
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.18);
      background: rgba(0,0,0,0.22);
      margin-bottom: 6px;
    }
    .loot-item:last-child{ margin-bottom: 0; }

    /* Reward cards (winner screen) */
    .loot-sub{
      margin-top: 6px;
      font-size: 13px;
      color: rgba(255,255,255,0.55);
    }
    .loot-items{
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-top: 14px;
      flex-wrap: wrap;
    }
    .reward-card{
      width: 112px;
      height: 172px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,0.20);
      background: #f7f7f7;
      box-shadow: 0 10px 26px rgba(0,0,0,0.42);
      cursor: pointer;
      position: relative;
      transition: transform 0.18s, box-shadow 0.18s, border-color 0.18s;
      user-select: none;
      color: #111;
      overflow: hidden;
      display: block;
    }
    .reward-card::after{
      content: '';
      position: absolute;
      inset: 8px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.12);
      pointer-events: none;
    }
    .reward-card:hover{
      transform: translateY(-8px) scale(1.02);
      border-color: rgba(var(--gold-rgb),0.60);
      box-shadow: 0 16px 34px rgba(0,0,0,0.52), 0 0 24px rgba(var(--gold-rgb),0.18);
    }
    .reward-card.selected,
    .reward-card.is-selected{
      border-color: rgba(var(--gold-rgb),0.95);
      box-shadow: 0 18px 40px rgba(0,0,0,0.60), 0 0 34px rgba(var(--gold-rgb),0.24);
    }
    .reward-card .reward-corner{
      position:absolute;
      top:8px;
      left:8px;
      display:flex;
      flex-direction:column;
      gap:2px;
      line-height:1;
      font-weight:800;
      font-family:var(--font-mono);
      color:#111;
      z-index:2;
    }
    .reward-card .reward-corner.red{ color:#b13b3b; }
    .reward-card .reward-corner .rank,
    .reward-card .reward-corner .suit{ font-size:14px; }
    .reward-card .reward-icon-badge{
      position:absolute;
      width:22px;
      height:22px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.14);
      background:rgba(255,255,255,0.88);
      display:grid;
      place-items:center;
      font-size:12px;
      z-index:2;
      line-height:1;
    }
    .reward-card .reward-stamp{ right:8px; top:8px; }
    .reward-card .reward-sleeve{ left:8px; bottom:8px; }
    .reward-card .reward-center{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      font-family:var(--font-display);
      letter-spacing:1px;
      text-transform:uppercase;
      color:rgba(17,17,17,0.85);
    }
    .reward-card .reward-pill{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.16);
      background:rgba(255,255,255,0.72);
      font-size:13px;
    }

    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.72; } }
    .hidden { display: none !important; }
  </style>
</head>

<body>
  <h1>Infiltration Run</h1>
  <p class="subtitle">Project 63 â€” Solo Node Crawler</p>

  <div id="game-container">

    <!-- Stats -->
    <div class="stats">
      <div class="meter-section">
        <div class="stat-label">Exposure</div>
        <div class="meter-bg"><div class="meter-bar" id="exp-bar"></div></div>
        <div class="meter-text" id="exp-text">0 / 20</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Tool</div>
        <div class="tool-val none" id="tool-val">None</div>
        <div class="tool-cap" id="tool-cap"></div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Deck</div>
        <div class="deck-num" id="deck-count">--</div>
      </div>
    </div>

    <!-- Buttons -->
    <div class="actions" style="margin-bottom:10px">
      <button class="btn btn-secondary" onclick="toggleRules()">Rules</button>
          </div>

    <!-- Rules Panel -->
    <div class="rules-panel" id="rules-panel">
      <h3>How to Play</h3>
      <div class="rr">
        <b>Card types â€”</b>
        <b>â™  â™£ (black) 2â€“A</b> = <b>Detection</b> (rank = exposure gained; A=14, K=13, Q=12, J=11).
        <b>â™¥ 2â€“10</b> = <b>Cover</b> (reduces exposure by that amount, min 0).
        <b>â™¦ 2â€“10</b> = <b>Tool</b> (equips mitigation vs detection).
        Red J, Q, K, A are not in the deck.
      </div>
      <div class="rr">
        <b>Each node â€”</b> 4 cards dealt face-up. Play exactly 3; the 4th is <b>carried forward</b>.
        When the deck is empty after dealing, it is the <b>final node</b>: play all cards, none carried.
      </div>
      <div class="rr">
        <b>Cover â€”</b> only the <i>first</i> cover card played in a node applies. Extra cover is discarded with no effect.
        Dimmed cover cards (with â€œno effectâ€) wonâ€™t reduce exposure.
      </div>
      <div class="rr">
        <b>Mitigation with a tool â€”</b> exposure gained = max(0, detection rank âˆ’ tool rank).
        <i>Tool signature:</i> after mitigating a detection of rank N, the tool can only mitigate future detections ranked strictly less than N.
        Manual bypass never increases the tool signature.
        Locked detections cannot be targeted by your current tool.
      </div>
      <div class="rr">
        <b>Change Branch â€”</b> all node cards go to the <i>bottom</i> of the deck in current order (no shuffle).
        Cannot change branch two nodes in a row.
      </div>
      <div class="rr">
        <b>Shorter decks</b> use balanced subsets: equal proportions of detection, cover, and tools with ranks spread across the full range.
      </div>
    </div>

    <!-- Cover banner -->
    <div class="cover-banner" id="cover-banner">
      Cover already applied this node â€” additional cover will be discarded
    </div>

    <!-- Node -->
    <div class="node-header">
      <div class="node-label">Current Node</div>
      <div class="progress-label" id="progress-label"></div>
    </div>
    <div class="node" id="node"></div>

    <!-- Change Branch -->
    <div class="actions">
      <button class="btn btn-branch" id="branch-btn" onclick="changeBranch()">âš¡ Change Branch</button>
    </div>

    <!-- Log -->
    <div class="log" id="log"></div>
  </div>

  <!-- Challenge Modal -->
  <div class="modal-overlay hidden" id="challenge-modal">
    <div class="modal">
      <h3 id="modal-title"></h3>
      <div class="modal-body" id="modal-desc"></div>
      <div class="modal-btns">
        <button class="btn btn-use-tool" id="modal-tool-btn" onclick="resolveWithTool()">Use Tool</button>
        <button class="btn btn-manual" onclick="resolveManual()">Manual Bypass</button>
      </div>
    </div>
  </div>

  <!-- Endgame -->
  <div class="endgame hidden" id="endgame">
    <h2 id="eg-title"></h2>
    <p id="eg-msg"></p>

    <div class="loot hidden" id="loot-box">
      <div class="loot-title" id="loot-title">Choose 1 Reward</div>
      <div class="loot-sub" id="loot-sub">Select a modified card to carry forward.</div>
      <div class="loot-items" id="loot-items"></div>
    </div>

    <button class="btn btn-primary" id="eg-action-btn" onclick="endgameAction()">New Run</button>
  </div>

<script>

  // ================================================================
  //  HELPERS
  // ================================================================
  function valStr(v) {
    return ({11:'J', 12:'Q', 13:'K', 14:'A'})[v] || String(v);
  }

  function cardType(suit, val) {
    if (suit === '\u2660' || suit === '\u2663') return 'detection'; // spade, club
    if (suit === '\u2665') return 'cover'; // heart
    return 'tool'; // diamond
  }

  function cardDesc(c) { return valStr(c.value) + c.suit; }

  function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // ---------------- P63 Embed Bridge ----------------
  const P63_EMBED = (window.parent && window.parent !== window);
  const P63 = {
    send(type, payload = {}) {
      if (!P63_EMBED) return;
      window.parent.postMessage({ __p63: 1, type, ...payload }, "*");
    }
  };

  let rewardSetId = null;
  let P63_ENDED = false;

  function isRedSuit(sym){ return sym === 'â™¥' || sym === 'â™¦'; }

  function toSuitSymbol(sym) {
    const raw = (sym == null) ? '' : String(sym).trim();
    if (!raw) return 'â™ ';

    const upper = raw.toUpperCase();
    if (upper === 'S' || upper === 'SPADE' || upper === 'SPADES') return 'â™ ';
    if (upper === 'C' || upper === 'CLUB' || upper === 'CLUBS') return 'â™£';
    if (upper === 'H' || upper === 'HEART' || upper === 'HEARTS') return 'â™¥';
    if (upper === 'D' || upper === 'DIAMOND' || upper === 'DIAMONDS') return 'â™¦';

    if (raw === 'â™ ' || raw === 'â™£' || raw === 'â™¥' || raw === 'â™¦') return raw;
    return 'â™ ';
  }

  // Receive reward set from parent
  window.addEventListener("message", (e) => {
    const d = e.data;
    if (!d || d.__p63 !== 1) return;

    if (d.type === "P63_REWARD_SET" && d.kind === "INFILTRATION") {
      rewardSetId = d.rewardSetId || null;
      rewardChoices = Array.isArray(d.rewards) ? d.rewards : [];
      renderRewardChoices(); // will render actual cards now
    }
  });

  // Tell parent we're alive (optional but helpful)
  P63.send("P63_MINIGAME_READY", { kind: "INFILTRATION" });

  // ================================================================
  //  DECK CONFIGS (mechanics unchanged; just reskinned terminology)
  // ================================================================
  const DECK_CONFIGS = {
    short:  { lowRanks: [2, 5, 8, 10],          highRanks: [12, 13] },
    medium: { lowRanks: [2, 3, 5, 6, 8, 9, 10], highRanks: [11, 13] },
    full:   null
  };

  function buildDeck(lengthKey) {
    const deck = [];
    const SUITS = ['\u2660', '\u2663', '\u2665', '\u2666']; // spade club heart diamond

    if (lengthKey === 'full') {
      // 44-card standard deck
      for (const suit of ['\u2660', '\u2663'])
        for (let v = 2; v <= 14; v++)
          deck.push({ suit, value: v, type: 'detection' });
      for (let v = 2; v <= 10; v++)
        deck.push({ suit: '\u2665', value: v, type: 'cover' });
      for (let v = 2; v <= 10; v++)
        deck.push({ suit: '\u2666', value: v, type: 'tool' });
    } else {
      const cfg = DECK_CONFIGS[lengthKey];
      // Low ranks across all 4 suits
      for (const suit of SUITS)
        for (const v of cfg.lowRanks)
          deck.push({ suit, value: v, type: cardType(suit, v) });
      // High ranks (detection only) -- spade and club
      for (const suit of ['\u2660', '\u2663'])
        for (const v of cfg.highRanks)
          deck.push({ suit, value: v, type: 'detection' });
    }
    return deck;
  }

  // ================================================================
  //  GAME STATE
  // ================================================================
  let deck = [];
  let node = [];
  let carryCard = null;

  let runner = { exposure: 0, maxExposure: 20 };
  let tool = null; // {suit, value, maxDetectionValue}
  let canBranch = true;
  let coverUsedThisNode = false;
  let finalNode = false;

  let pendingDetection = null;
  let pendingDetectionIdx = null;

  let selectedLength = 'medium';

    // Reward placeholders (victory screen)
  let endgameMode = null;          // 'win' | 'dead'
  let rewardChoices = [];
  let selectedRewardIdx = null;

  function buildPlaceholderRewards() {
    // Standalone fallback only: empty placeholders
    return [{}, {}, {}];
  }

  function rewardChoiceMarkup(r, loading = false) {
    const suitSym = toSuitSymbol(r.suitSym || r.suit || 'â™ ');
    const rank = r.rank || r.value || 'â€”';
    const red = isRedSuit(suitSym);
    const stamp = r.stampShort || r.stampLabel || r.stampId || 'â€¦';
    const sleeve = r.sleeveShort || r.sleeveLabel || r.sleeveId || 'â€¦';

    return `
      <div class="reward-corner ${red ? 'red' : ''}">
        <div class="rank">${rank}</div>
        <div class="suit">${suitSym}</div>
      </div>
      <div class="reward-icon-badge reward-stamp" title="Stamp">${stamp}</div>
      <div class="reward-icon-badge reward-sleeve" title="Sleeve">${sleeve}</div>
      <div class="reward-center">
        <div class="reward-pill">${loading ? 'Loading' : 'Reward'}</div>
      </div>
    `;
  }

  function renderRewardChoices() {
    const lootBox   = document.getElementById('loot-box');
    const items     = document.getElementById('loot-items');
    const actionBtn = document.getElementById('eg-action-btn');

    items.innerHTML = '';
    selectedRewardIdx = null;
    actionBtn.disabled = true;

    const list = (rewardChoices && rewardChoices.length) ? rewardChoices : buildPlaceholderRewards();

    list.forEach((r, idx) => {
      const d = document.createElement('div');
      d.className = 'reward-card';
      d.title = rewardChoices.length ? 'Select reward' : 'Loading rewardâ€¦';
      d.setAttribute('role', 'button');
      d.setAttribute('tabindex', rewardChoices.length ? '0' : '-1');
      d.setAttribute('aria-label', rewardChoices.length ? `Select reward ${idx + 1}` : 'Loading reward');
      d.innerHTML = rewardChoiceMarkup(r, !rewardChoices.length);

      if (rewardChoices.length){
        d.onclick = () => selectReward(idx);
        d.onkeydown = (ev) => {
          if (ev.key === 'Enter' || ev.key === ' ') {
            ev.preventDefault();
            selectReward(idx);
          }
        };
      } else {
        d.style.cursor = "default";
      }

      items.appendChild(d);
    });

    lootBox.classList.remove('hidden');
  }

  function selectReward(idx) {
    selectedRewardIdx = idx;
    const nodes = Array.from(document.querySelectorAll('#loot-items .reward-card'));
    nodes.forEach((n, i) => {
      const on = i === idx;
      n.classList.toggle('selected', on);
      n.classList.toggle('is-selected', on);
      n.setAttribute('aria-pressed', on ? 'true' : 'false');
    });
    document.getElementById('eg-action-btn').disabled = false;
  }

  function endgameAction() {
    if (P63_ENDED) return;

    if (P63_EMBED){
      if (endgameMode === 'win'){
        if (selectedRewardIdx === null) return;
        P63_ENDED = true;
        P63.send("P63_MINIGAME_END", {
          kind: "INFILTRATION",
          outcome: "win",
          rewardSetId,
          chosenIdx: selectedRewardIdx
        });
        return;
      }

      // dead
      P63_ENDED = true;
      P63.send("P63_MINIGAME_END", {
        kind: "INFILTRATION",
        outcome: "dead"
      });
      return;
    }

    // Standalone fallback
    initGame();
  }


  // ================================================================
  //  SETUP
  // ================================================================
  function initGame() {
    P63_ENDED = false;

    if (P63_EMBED){
      selectedLength = "medium"; // Standard only
    }

    deck = shuffle(buildDeck(selectedLength));
    runner = { exposure: 0, maxExposure: 20 };
    tool = null;
    canBranch = true;
    carryCard = null;
    coverUsedThisNode = false;
    finalNode = false;
    pendingDetection = pendingDetectionIdx = null;
    node = [];

    document.getElementById('endgame').classList.add('hidden');
    document.getElementById('challenge-modal').classList.add('hidden');
    document.getElementById('loot-box').classList.add('hidden');
    document.getElementById('loot-items').innerHTML = '';
    document.getElementById('log').innerHTML = '';

    const labels = { short: 'Quick (20 cards)', medium: 'Standard (32 cards)', full: 'Full (44 cards)' };
    addLog('New infiltration run â€” ' + labels[selectedLength] + '.', 'system');
    dealNode(false);
  }

  // ================================================================
  //  NODE LOGIC
  // ================================================================
  function dealNode(afterBranch) {
    coverUsedThisNode = false;
    node = [];
    let toDraw = 4;

    if (carryCard) {
      node.push({ ...carryCard, played: false });
      carryCard = null;
      toDraw = 3;
    }

    for (let i = 0; i < Math.min(toDraw, deck.length); i++)
      node.push({ ...deck.pop(), played: false });

    finalNode = (deck.length === 0);

    if (!afterBranch) canBranch = true;
    updateUI();
  }

  // Final node: play everything. Normal: play all but 1 (carry the last).
  function neededCount() {
    if (finalNode || node.length <= 1) return node.length;
    return node.length - 1;
  }
  function playedCount() { return node.filter(c => c.played).length; }

  function afterCardPlayed() {
    const played = playedCount();
    const needed = neededCount();
    const remaining = node.filter(c => !c.played);

    if (played < needed) { updateUI(); return; }

    // Node complete
    if (!finalNode && remaining.length === 1) {
      carryCard = { ...remaining[0] };
      addLog('Carry forward: ' + cardDesc(carryCard) + '.', 'info');
    }

    updateUI();

    if (finalNode) {
      setTimeout(() => showEndgame(true), 650);
    } else {
      setTimeout(() => dealNode(false), 420);
    }
  }

  // ================================================================
  //  CARD INTERACTIONS
  // ================================================================
  function clickCard(idx) {
    const c = node[idx];
    if (!c || c.played) return;

    if (c.type === 'cover') applyCover(idx);
    else if (c.type === 'tool') equipTool(idx);
    else engageDetection(idx);
  }

  function applyCover(idx) {
    const c = node[idx];
    c.played = true;

    if (coverUsedThisNode) {
      addLog('Cover ignored: ' + cardDesc(c) + ' (already applied cover this node).', 'info');
    } else {
      coverUsedThisNode = true;
      const before = runner.exposure;
      runner.exposure = Math.max(0, runner.exposure - c.value);
      const reduced = before - runner.exposure;
      addLog('Applied cover ' + cardDesc(c) + ': -' + reduced + ' exposure. (' + runner.exposure + '/' + runner.maxExposure + ')', 'cover');
    }

    afterCardPlayed();
  }

  function equipTool(idx) {
    const c = node[idx];
    if (tool) {
      addLog('Swapped tool ' + valStr(tool.value) + tool.suit + ' â†’ ' + cardDesc(c) + '.', 'tool');
    } else {
      addLog('Equipped tool ' + cardDesc(c) + '.', 'tool');
    }
    tool = { suit: c.suit, value: c.value, maxDetectionValue: Infinity };
    c.played = true;
    afterCardPlayed();
  }

  function toolCanMitigate(detectionVal) {
    return tool !== null && detectionVal < tool.maxDetectionValue;
  }

  function engageDetection(idx) {
    const c = node[idx];
    pendingDetection = c;
    pendingDetectionIdx = idx;

    addLog('Engaged ' + cardDesc(c) + ' detection.', 'info');

    const canUse = toolCanMitigate(c.value);
    const toolExp = canUse ? Math.max(0, c.value - tool.value) : null;

    if (canUse) {
      const afterCap = c.value;
      const expStr = toolExp === 0
        ? '<strong>+0 exposure</strong> (fully mitigated)'
        : '<strong>+' + toolExp + ' exposure</strong>';

      const signatureStr = afterCap <= 2
        ? 'After this, the tool is effectively burned (no detections ranked &lt; ' + afterCap + ').'
        : 'After use: tool signature rises â€” mitigates rank &lt; ' + afterCap + ' only.';

      document.getElementById('modal-title').textContent =
        'Detection â€” ' + cardDesc(c) + ' (rank ' + c.value + ')';

      document.getElementById('modal-desc').innerHTML =
        'Manual bypass: <strong>+' + c.value + ' exposure</strong> <em style="font-size:0.9em;color:rgba(184,184,184,0.8)">(tool preserved)</em><br>' +
        valStr(tool.value) + tool.suit + ': ' + expStr +
        '<span class="degrade-note">' + signatureStr + '</span>';

      document.getElementById('challenge-modal').classList.remove('hidden');
    } else {
      if (tool) {
        const cap = tool.maxDetectionValue === Infinity ? 'any rank' : 'rank < ' + tool.maxDetectionValue;
        addLog('Tool ' + valStr(tool.value) + tool.suit + ' cannot mitigate rank ' + c.value + ' (' + cap + '). Manual bypass.', 'info');
      }
      resolveEngagement(false);
    }
  }

  function resolveWithTool() {
    document.getElementById('challenge-modal').classList.add('hidden');
    resolveEngagement(true);
  }
  function resolveManual() {
    document.getElementById('challenge-modal').classList.add('hidden');
    resolveEngagement(false);
  }

  function resolveEngagement(useTool) {
    const c = pendingDetection;
    const idx = pendingDetectionIdx;

    let inc = c.value; // manual bypass = full exposure

    if (useTool && tool) {
      inc = Math.max(0, c.value - tool.value);
      const oldCap = tool.maxDetectionValue === Infinity ? 'any' : '< ' + tool.maxDetectionValue;
      tool.maxDetectionValue = c.value;

      runner.exposure += inc;

      addLog(
        'Mitigated ' + cardDesc(c) + ' with ' + valStr(tool.value) + tool.suit + ': +' + inc + ' exposure. ' +
        '(tool was ' + oldCap + ', now < ' + c.value + ') ' +
        '(' + runner.exposure + '/' + runner.maxExposure + ')',
        'exposure'
      );
    } else {
      runner.exposure += inc;
      addLog(
        'Bypassed ' + cardDesc(c) + ' manually: +' + inc + ' exposure. (' + runner.exposure + '/' + runner.maxExposure + ')',
        'exposure'
      );
    }

    node[idx].played = true;

    if (runner.exposure >= runner.maxExposure) {
      runner.exposure = runner.maxExposure;
      updateUI();
      setTimeout(() => showEndgame(false), 650);
      return;
    }

    afterCardPlayed();
  }

  // ================================================================
  //  CHANGE BRANCH (FLEE)
  // ================================================================
  function changeBranch() {
    if (!canBranch) { addLog('Cannot change branch two nodes in a row.', 'info'); return; }

    const allCards = node.map(c => { const { played, ...bare } = c; return bare; });
    deck.unshift(...allCards);

    addLog('Changed branch â€” ' + allCards.length + ' card(s) moved to bottom of deck. (' + deck.length + ' remain)', 'branch');

    canBranch = false;
    carryCard = null;
    node = [];
    dealNode(true);
  }

  // ================================================================
  //  UI
  // ================================================================
  function updateUI() {
    // Exposure bar (fills up as exposure rises)
    const pct = Math.max(0, Math.min(1, runner.exposure / runner.maxExposure)) * 100;
    const bar = document.getElementById('exp-bar');
    bar.style.width = pct + '%';
    bar.style.background = pct < 35
      ? 'linear-gradient(90deg, rgba(94,140,97,0.95), rgba(94,140,97,0.65))'
      : pct < 70
      ? 'linear-gradient(90deg, rgba(212,175,55,0.95), rgba(212,175,55,0.65))'
      : 'linear-gradient(90deg, rgba(168,50,50,0.95), rgba(168,50,50,0.65))';

    document.getElementById('exp-text').textContent = runner.exposure + ' / ' + runner.maxExposure;

    // Tool
    const tv = document.getElementById('tool-val');
    const tc = document.getElementById('tool-cap');

    if (tool) {
      tv.className = 'tool-val';
      tv.textContent = valStr(tool.value) + tool.suit;

      if (tool.maxDetectionValue === Infinity) {
        tc.textContent = 'mitigates any rank';
        tc.style.color = '';
      } else if (tool.maxDetectionValue <= 2) {
        tc.textContent = 'burned (fully flagged)';
        tc.style.color = 'rgba(168,50,50,0.95)';
      } else {
        tc.textContent = 'mitigates rank < ' + tool.maxDetectionValue;
        tc.style.color = '';
      }
    } else {
      tv.className = 'tool-val none';
      tv.textContent = 'None';
      tc.textContent = '';
      tc.style.color = '';
    }

    // Deck count
    document.getElementById('deck-count').textContent = deck.length;

    // Change branch button
    document.getElementById('branch-btn').disabled = !canBranch;

    // Cover banner: show if cover used AND unused cover remains
    const unusedCover = node.filter(c => !c.played && c.type === 'cover').length;
    document.getElementById('cover-banner')
      .classList.toggle('visible', coverUsedThisNode && unusedCover > 0);

    // Progress label
    const played = playedCount();
    const needed = neededCount();
    document.getElementById('progress-label').textContent =
      played + ' / ' + needed + ' played' + (finalNode ? ' (final node)' : '');

    renderNode();
  }

  function renderNode() {
    const el = document.getElementById('node');
    el.innerHTML = '';

    const played = playedCount();
    const needed = neededCount();

    node.forEach((c, idx) => {
      const isRed = (c.suit === '\u2665' || c.suit === '\u2666');
      const v = valStr(c.value);
      const isDanger = !c.played && c.type === 'detection' && c.value >= 10;
      const isLocked = !c.played && c.type === 'detection' && tool && !toolCanMitigate(c.value);
      const isSpent = !c.played && c.type === 'cover' && coverUsedThisNode;

      let subText = '', subClass = '';

      if (!c.played) {
        if (c.type === 'detection') {
          if (tool && toolCanMitigate(c.value)) {
            const inc = Math.max(0, c.value - tool.value);
            if (inc === 0) { subText = '+0 EXP'; subClass = 'exposure-reduced'; }
            else { subText = '+' + inc + ' EXP'; subClass = 'exposure-reduced'; }
          } else if (isLocked) {
            subText = '+' + c.value + ' EXP'; subClass = 'exposure-locked';
          } else {
            subText = '+' + c.value + ' EXP'; subClass = 'exposure-full';
          }
        } else if (isSpent) {
          subText = 'no effect'; subClass = 'no-cover';
        }
      }

      if (isLocked && subText) subText = 'ðŸ”’ ' + subText;

      const typeLabel = { detection: 'Detection', cover: 'Cover', tool: 'Tool' }[c.type];

      const cls = [
        'card',
        c.type,
        isLocked ? 'tool-locked' : '',
        isSpent ? 'cover-spent' : '',
        isRed ? 'red-suit' : 'black-suit',
        (isDanger && !c.played) ? 'danger' : '',
        c.played ? 'played' : '',
        (!c.played && played >= needed) ? 'no-interact' : ''
      ].filter(Boolean).join(' ');

      const div = document.createElement('div');
      div.className = cls;

      div.innerHTML =
        '<div class="corner tl"><span class="cv">' + v + '</span><span class="cs">' + c.suit + '</span></div>' +
        '<div class="card-center">' +
          '<div class="big-suit">' + c.suit + '</div>' +
          '<div class="big-val">' + v + '</div>' +
          '<div class="card-type-tag">' + typeLabel + '</div>' +
          (subText ? '<div class="card-sub ' + subClass + '">' + subText + '</div>' : '') +
        '</div>' +
        '<div class="corner br"><span class="cv">' + v + '</span><span class="cs">' + c.suit + '</span></div>';

      if (!c.played && played < needed) {
        div.onclick = () => clickCard(idx);
        div.title =
          c.type === 'detection' ? 'Engage detection'
          : c.type === 'cover' ? (isSpent ? 'Discard cover (no effect)' : 'Apply cover')
          : 'Equip tool';
      }

      el.appendChild(div);
    });
  }

  function addLog(msg, cls) {
    const log = document.getElementById('log');
    const d = document.createElement('div');
    d.className = 'log-entry' + (cls ? ' ' + cls : '');
    d.textContent = msg;
    log.appendChild(d);
    log.scrollTop = log.scrollHeight;
  }

  function showEndgame(win) {
    endgameMode = win ? 'win' : 'dead';

    const el        = document.getElementById('endgame');
    const titleEl   = document.getElementById('eg-title');
    const msgEl     = document.getElementById('eg-msg');
    const actionBtn = document.getElementById('eg-action-btn');
    const lootBox   = document.getElementById('loot-box');
    const lootItems = document.getElementById('loot-items');

    el.className = 'endgame ' + (win ? 'win' : 'dead');

    if (win) {
      titleEl.textContent = 'SUCCESS';
      msgEl.innerHTML = 'Trace cleared.<br><strong>The Pit holds no record.</strong>';

      lootItems.innerHTML = '';
      lootBox.classList.remove('hidden');

      actionBtn.textContent = 'CLAIM REWARD';
      actionBtn.disabled = true;

      if (P63_EMBED){
        // Show loading placeholders, then request real rewards from parent
        rewardChoices = [];
        rewardSetId = null;
        renderRewardChoices();
        P63.send("P63_REQUEST_REWARD_SET", { kind:"INFILTRATION" });
      } else {
        rewardChoices = buildPlaceholderRewards();
        renderRewardChoices();
      }
    } else {
      titleEl.textContent = 'TRACE BREACHED';
      msgEl.innerHTML =
        'Exposure hit <strong>' + runner.maxExposure + '</strong>.<br>' +
        'The node chain is sealed â€” start a new run.';

      lootBox.classList.add('hidden');
      lootItems.innerHTML = '';

      actionBtn.textContent = P63_EMBED ? 'END GAME' : 'New Run';
      actionBtn.disabled = false;
    }

    el.classList.remove('hidden');
  }

  function toggleRules() {
    document.getElementById('rules-panel').classList.toggle('open');
  }

  // ================================================================
  //  START
  // ================================================================
  initGame();
</script>
</body>
</html>

  </template>

  <script>
    // =============================================
    // CONSTANTS
    // =============================================
    const STARTING_CHIPS = 500;
    const REST_REWARD = 50;
    const BARTENDER_REWARD = 50;
    const MINIGAME_POKER_ENTRY_COST = 100;

    // rarity roll used for BOTH stamps and sleeves for infiltration rewards
    const MINIGAME_RARITY_ROLL = [
      { r: 'common',   p: 0.55 },
      { r: 'uncommon', p: 0.35 },
      { r: 'rare',     p: 0.10 }
    ];

    const MERCHANT_BUY_BASE_STANDARD = 50;
    const MERCHANT_BUY_BASE_MOD = 100;
    const MERCHANT_BUY_INCREMENT = 25;
    const MERCHANT_REMOVE_COST = 50;
    const REMOVAL_REROLL_COST = 25;      // also used as inventory reroll cost
    const MERCHANT_INVENTORY_REROLL_COST = 25;
    const COLLECTOR_COST_BY_RARITY = { common: 20, uncommon: 35, rare: 60 };
    const SHOP_PURCHASE_CAP = 10;

// Economy tuning
const MERCHANT_REMOVE_INCREMENT = 25; // removal cost increases by this amount each time you start a paid removal
const MOD_PURCHASE_LIMIT_PER_DELTA = 2; // only this many of each modifier (-4..+4) can be purchased per run
const BENCH_BASE_CAPACITY = 2; // bench slots at start of run
const BENCH_CAPACITY_BONUS_PER_BOSS_WIN = 1; // +1 bench slot after each boss victory
const LANE_COUNT = 5;  // intentional fixed lane count (used for lane initialization / fixed arrays)
const CALLING_PROC_CHANCE = 0.50;
const DIAMOND_BONUS_CHIPS = 10;
const CALLING_RANK_THRESHOLDS = [
  { rank: '2', karma: 0 },
  { rank: '3', karma: 200 },
  { rank: '4', karma: 500 },
  { rank: '5', karma: 900 },
  { rank: '6', karma: 1400 },
  { rank: '7', karma: 2000 },
  { rank: '8', karma: 2700 },
  { rank: '9', karma: 3500 },
  { rank: '10', karma: 4400 },
  { rank: 'J', karma: 5400 },
  { rank: 'Q', karma: 6500 },
  { rank: 'K', karma: 7700 },
  { rank: 'A', karma: 9000 }
];


    const LOAN_AMOUNT = 500;
    const LOAN_REPAY = 750;

    const BUYIN_STANDARD = 100;
    const BUYIN_HIGH = 200;
    const BUYIN_BOSS = 300;
    const HIGH_STAKES_KARMA_MULT = 1.2;

    // Action tokens + cocktails
    const COCKTAIL_COST = 150;
    const ACTION_TOKEN_MAX_BANKED = 3;
    const KEY_SUIT = 'â˜…';
    const KEY_MERCHANT_COST = 150;

    // Rewards / mechanics
    const BLACKJACK_21_REWARD = 21;
    const ALL_FIVE_21_BONUS = 210;

    // Modifiers (merchant + deck)
    const MODIFIER_DELTAS = [-4,-3,-2,-1, +1,+2,+3,+4];
    const MOD_OFFER_CHANCE = 0.22;

    const FLOOR_COUNTS = {
      1: { standard: 11, high: 2 },
      2: { standard: 7, high: 6 },
      3: { standard: 3, high: 10 }
    };

    const NODES = [
      [0, 200, 50, []],
      [1, 140, 95, [0]], [2, 260, 95, [0]],
      [3, 80, 140, [1]], [4, 200, 140, [0, 1, 2]], [5, 320, 140, [2]],
      [6, 140, 185, [1, 3, 4]], [7, 260, 185, [2, 4, 5]],
      [8, 80, 230, [3, 6]], [9, 200, 230, [4, 6, 7]], [10, 320, 230, [5, 7]],
      [11, 140, 275, [6, 8, 9]], [12, 260, 275, [7, 9, 10]],
      [13, 80, 320, [8, 11]], [14, 200, 320, [9, 11, 12]], [15, 320, 320, [10, 12]],
      [16, 140, 365, [11, 13, 14]], [17, 260, 365, [12, 14, 15]],
      [18, 80, 410, [13, 16]], [19, 200, 410, [14, 16, 17]], [20, 320, 410, [15, 17]]
    ];

    const HEX_SIZE = 30;
    const SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
    const RANKS = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];

    const TILE_COLORS = {
      'BOSS': '#FFD700',
      'STANDARD': '#4a6fa5',
      'HIGH_STAKES': '#9b59b6',
      'MERCHANT': '#27ae60',
      'MODIFY': '#16a085',
      'COLLECTOR': '#f39c12',
      'LOAN_SHARK': '#e67e22',
      'REST_STOP': '#3498db',
      'BARTENDER': '#e74c3c',
      'MINIGAME': '#1abc9c'
    };

    const TILE_LABELS = {
      'BOSS': 'BOSS',
      'STANDARD': 'STD',
      'HIGH_STAKES': 'HIGH',
      'MERCHANT': 'MER',
      'MODIFY': 'MOD',
      'COLLECTOR': 'COL',
      'LOAN_SHARK': 'LOAN',
      'REST_STOP': 'REST',
      'BARTENDER': 'BAR',
      'MINIGAME': 'MINI'
    };

    const TILE_META = {
      BOSS: { name: 'Boss', desc: 'Three-round boss fight. Win to clear the floor.' },
      STANDARD: { name: 'Standard Table', desc: `Blackjack match. Buy-in ${BUYIN_STANDARD}.` },
      HIGH_STAKES: { name: 'High Stakes', desc: `Harder blackjack match. Buy-in ${BUYIN_HIGH}.` },
      REST_STOP: { name: 'Rest Stop', desc: `Choose: free removal or +${REST_REWARD} chips. Always: +1 banked token.` },
      BARTENDER: { name: 'Bartender', desc: `Take +${BARTENDER_REWARD} chips, or buy a cocktail action (${COCKTAIL_COST}).` },
      LOAN_SHARK: { name: 'Loan Shark', desc: `Borrow +${LOAN_AMOUNT} now. Repay ${LOAN_REPAY} before the final boss.` },
      MERCHANT: { name: 'Shop Keeper', desc: 'Buy cards & modifiers. Optional paid removals and rerolls.' },
      MODIFY: { name: 'Modify', desc: 'Pay chips to re-suit / re-rank and other presses.' },
      COLLECTOR: { name: 'Collector', desc: 'Buy stamps & sleeves; auction the leftovers.' },
      MINIGAME: { name: 'Mini Game', desc: 'Choose Poker Slots for chips or Infiltration Run for cards.' }
    };


    const HELP_TILES = {
      STANDARD: { title: 'Standard Table', lines: [`Buy-in: ${BUYIN_STANDARD} chips`, 'Play a normal 5-lane match.', 'Win the match for a deck reward.'] },
      HIGH_STAKES: { title: 'High Stakes Table', lines: [`Buy-in: ${BUYIN_HIGH} chips`, 'Harder tables, bigger swings.', 'Win the match for a deck reward.'] },
      BOSS: { title: 'Boss Table', lines: [`Buy-in: ${BUYIN_BOSS} chips`, 'Multi-round boss match.', 'Clear it to advance floors.'] },
      MERCHANT: { title: 'Merchant', lines: ['Buy cards and modifiers.', 'Reroll inventory for a fee.', 'Optional paid card removal.'] },
      MODIFY: { title: 'Modify', lines: ['Pay to re-suit / re-rank cards.', 'Premium presses can affect sets.', 'Rerolls cost chips.'] },
      COLLECTOR: { title: 'Collector', lines: ['Buy stamps & sleeves.', 'Apply to eligible base cards.', 'Slots refresh after purchase.'] },
      LOAN_SHARK: { title: 'Loan Shark', lines: [`Borrow ${LOAN_AMOUNT} chips now`, `Repay ${LOAN_REPAY} before Floor 3 boss`, 'Can block boss entry if unpaid.'] },
      REST_STOP: { title: 'Rest Stop', lines: ['Choose 1 benefit (free).', 'Also gain +1 banked Action Token.', 'Good for stabilizing runs.'] },
      BARTENDER: { title: 'Bartender', lines: [`Take +${BARTENDER_REWARD} chips`, `Or buy a Cocktail for ${COCKTAIL_COST}`, 'Cocktails unlock Actions.'] },
      MINIGAME: { title: 'Minigame', lines: [`Poker Slots: entry ${MINIGAME_POKER_ENTRY_COST}`, 'Infiltration Run: play for cards.', 'Does not advance the floor.'] }
    };

    const HELP_MODALS = {
      'Settings': { lines: ['These settings persist on this device/browser.', 'Help toggles control tips + tooltips.', 'Advanced/Testing is optional and usually unnecessary for normal play.'] },
      'Rules': { lines: ['Goal: beat the Dealer by winning lanes with totals â‰¤ 21.', 'Close a lane to lock it (you canâ€™t add more cards).', 'On touch devices: long-press cards/tiles to see tooltips.'] },
      'Deck Viewer': { lines: ['Shows your current deck contents (including badges).', 'Use this to understand how stamps/sleeves are shaping your run.', 'Deck changes happen through rewards + shops.'] },
      'Feedback': { lines: ['Notes saved here attach to the current run.', 'Use â€œBugsâ€ for reproducible issues; â€œCommentsâ€ for balance/UX notes.', 'This is designed to export cleanly in the analyzer.'] },
      'Rest Stop': { lines: ['Choose ONE: Free Removal or Chips.', 'You ALSO gain +1 banked Action Token no matter what you choose.', 'Free Removal will offer a small set of cards to delete.'] },
      'Bartender': { lines: ['You can always take the free chips.', 'Cocktail unlocks 1 random Action (until you own them all).', 'Actions are spent during matches using Action Tokens.'] },
      'Minigame': { lines: [`Poker Slots costs ${MINIGAME_POKER_ENTRY_COST} to enter.`, 'Poker Slots: you can cash out anytime; the run ends if you hit 0.', 'Infiltration Run: win to choose a card reward.'] },
      'Loan Shark': { lines: [`Take ${LOAN_AMOUNT} now, but you must repay ${LOAN_REPAY}.`, 'If unpaid at the Floor 3 boss gate, you may be blocked from entering.', 'Repaying clears the loan immediately.'] },
      'Merchant': { lines: ['Buy cards/modifiers to strengthen your deck.', 'Removal mode lets you pay to delete a card (when offered).', 'Rerolls refresh inventory at a cost.'] },
      'Modify': { lines: ['Each purchase consumes chips immediately and counts toward the shop cap.', 'Core services affect single cards (re-suit / rank shift).', 'Premium services can affect sets (shown in the UI).'] },
      'Collector': { lines: ['Buy a Stamp or Sleeve, then apply it to an eligible base card.', 'Cards that already have a stamp/sleeve may be ineligible.', 'After applying, the purchased slot refreshes.'] },
      'Debt Due': { lines: ['You must repay your loan to proceed into the final boss.', 'If you canâ€™t repay, youâ€™ll be turned away.', 'Borrowing is powerful but can become a hard gate.'] },
      'Boss Cleared': { lines: ['Clearing a boss advances the run to the next floor.', 'You gain tokens (floor base) and your bench capacity may change.', 'Continue to generate the next board.'] },
      'A New Opponent': { lines: ['This is a special encounter with unique behavior.', 'Your current Calling Card influences some interactions.', 'Prepare for higher pressure and different timing.'] },
      'Winner Reward': { lines: ['You won the match â€” choose a deck reward.', 'Remove: delete a card from offered options.', 'Duplicate: add a copy of a chosen offered card.'] },
      'Fuse Cards': { lines: ['Select exactly 2 eligible cards to fuse into 1.', 'A fused card counts as a single card for effect scanning.', 'Fusion is permanent for the run.'] },
      'Actions': { lines: ['Choose an action to perform during the match.', 'Opening this list consumes the token even if you cancel (per current rules).', 'Some actions prompt follow-up choices (lane/card).'] },
      'Split Decision': { lines: ['Choose 1 card to play now.', 'The other card will be played by the Dealer immediately after.', 'Use this to force timing and lane pressure.'] },
      'Second Opinion': { lines: ['Choose 1 card to play now.', 'The other card is discarded.', 'Use this to filter bad draws into acceptable plays.'] },
      'Power Proc': { lines: ['A triggered power is asking for your choice.', 'Your selection applies immediately to the specified lane.', 'Use this to push totals across/away from 21 thresholds.'] },
      'Test Games': { lines: ['Sandbox mode: runs minigames in a loop.', 'No progression or rewards carry into normal runs.', 'Use â€œEND TESTâ€ to return.'] },
      'Collector - Apply': { lines: ['Pick a card from the offered sample.', 'Only eligible cards are shown.', 'After selecting, you return to the Collector main view.'] },
      'Modify - Service': { lines: ['Pick a target card from the shown candidates.', 'Reroll refreshes candidates at a cost.', 'Confirming applies immediately and updates your deck.'] },
      'Quick Start': { lines: ['You win lanes by beating the Dealer total without busting.', 'Close lanes to lock totals; you canâ€™t add more cards.', 'Use Action Tokens to access powerful tactical plays.'] }
    };


    // =============================================
    // COCKTAIL ACTION REGISTRY
    // =============================================
    const ACTIONS = {
      splitDecision: {
        name: "Split Decision",
        desc: "Draw 2 playable cards. Choose 1 to play; the other is immediately played by the Dealer.",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard && countOpenPositions(m.playerPositions) > 0,
        activate: () => activateSplitDecision()
      },
      secondOpinion: {
        name: "Second Opinion",
        desc: "Draw 2 playable cards. Choose 1 to play; discard the other.",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard && countOpenPositions(m.playerPositions) > 0,
        activate: () => activateSecondOpinion()
      },
      benched: {
        name: "Benched",
        desc: "Draw a playable card and send it to your Bench (ends your turn).",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard,
        activate: () => activateBenched()
      },
      spyGlass: {
        name: "Spy Network",
        desc: "Reveal the current totals of all Dealer lanes for the rest of the match.",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateSpyGlass()
      },
      forcedPlay: {
        name: "Forced Play",
        desc: "Choose a Dealer open lane. The Dealer's next placed card must go there (if still valid).",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateForcedPlay()
      },
      revival: {
        name: "Revival",
        desc: "Reopen any of your closed lanes (stood or busted).",
        isUsable: (m) => isPlayerActionContextOK(m) && getEligibleRevivalLanes(m).length > 0,
        activate: () => activateRevival()
      },
      findMyCard: {
        name: "Find My Card",
        desc: "Search the top 10 of your draw pile for a modifier; move the first found to your Bench (ends your turn).",
        isUsable: (m) => isPlayerActionContextOK(m) && !m.drawnCard,
        activate: () => activateFindMyCard()
      },
      closer: {
        name: "Closer",
        desc: "Choose a Dealer open lane and close it immediately.",
        isUsable: (m) => isPlayerActionContextOK(m) && anyOpenIncomplete(m.dealerPositions),
        activate: () => activateCloser()
      }
    };

    // =============================================
    // STARTER SCREEN
    // =============================================
    const START_PLASMA_CONFIG = {
      speed: 1.00, intensity: 1.25, scale: 1.6,
      colors: [
        [0.0588, 0.0667, 0.0980],
        [0.1490, 0.1137, 0.0510],
        [0.4235, 0.3569, 0.1294]
      ]
    };

    class StartPlasma2D {
      constructor(canvas, cfg){
        this.canvas = canvas;
        this.ctx = canvas ? canvas.getContext('2d', { alpha: false }) : null;
        this.cfg = cfg; this.t = 0; this.running = false;
        this.off = document.createElement('canvas');
        this.offCtx = this.off.getContext('2d');
        this.onResize = this.onResize.bind(this);
        window.addEventListener('resize', this.onResize);
        this.onResize();
      }
      onResize(){
        if (!this.canvas || !this.ctx) return;
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const w = Math.floor(window.innerWidth * dpr);
        const h = Math.floor(window.innerHeight * dpr);
        this.canvas.width = w; this.canvas.height = h;
        const scale = 0.33;
        this.off.width = Math.max(240, Math.floor(w * scale));
        this.off.height = Math.max(180, Math.floor(h * scale));
      }
      start(){ if (this.running) return; if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) return; this.running = true; requestAnimationFrame(()=>this.frame()); }
      stop(){ this.running = false; }
      field(x,y,t){ const s=this.cfg.scale,nx=x/this.off.width,ny=y/this.off.height; return (Math.sin((nx*3.2*s)+t)+Math.sin((ny*3.0*s)+t*0.9)+Math.sin(((nx+ny)*2.2*s)+t*0.7)+Math.sin((Math.hypot(nx-0.5, ny-0.5)*7.0*s)-t*1.1))*0.25+0.5; }
      lerp(a,b,t){ return a+(b-a)*t; }
      sampleGradient(v){ const [c0,c1,c2]=this.cfg.colors; if(v<0.5){ const t=v/0.5; return [this.lerp(c0[0],c1[0],t),this.lerp(c0[1],c1[1],t),this.lerp(c0[2],c1[2],t)]; } const t=(v-0.5)/0.5; return [this.lerp(c1[0],c2[0],t),this.lerp(c1[1],c2[1],t),this.lerp(c1[2],c2[2],t)]; }
      frame(){ if (!this.running || !this.ctx) return; const w=this.off.width,h=this.off.height,img=this.offCtx.createImageData(w,h),d=img.data; this.t += 0.016*this.cfg.speed; const inten=this.cfg.intensity; for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ let v=this.field(x,y,this.t); v=Math.min(1,Math.max(0,0.5+(v-0.5)*inten)); const [r,g,b]=this.sampleGradient(v); const i=(y*w+x)*4; d[i]=(r*255)|0; d[i+1]=(g*255)|0; d[i+2]=(b*255)|0; d[i+3]=255; } } this.offCtx.putImageData(img,0,0); this.ctx.imageSmoothingEnabled=true; this.ctx.drawImage(this.off,0,0,this.canvas.width,this.canvas.height); requestAnimationFrame(()=>this.frame()); }
    }

    let startPlasma = null;
    let introPlasma = null;
    let introPlasmaFading = false;
    let uiView = 'start';
    function initStartPlasma(){ const c=document.getElementById('startPlasma'); if (!c) return; startPlasma = new StartPlasma2D(c, START_PLASMA_CONFIG); }
    function initIntroPlasma(){ const c=document.getElementById('introPlasma'); if (!c) return; introPlasma = new StartPlasma2D(c, START_PLASMA_CONFIG); }
    function showIntroPlasma(){
      const layer = document.getElementById('introPlasmaLayer');
      if (!layer) return;
      introPlasmaFading = false;
      layer.classList.remove('fade-out');
      layer.classList.add('show');
      if (introPlasma) introPlasma.start();
    }
    function hideIntroPlasmaImmediate(){
      const layer = document.getElementById('introPlasmaLayer');
      if (layer) {
        layer.classList.remove('show');
        layer.classList.remove('fade-out');
      }
      introPlasmaFading = false;
      if (introPlasma) introPlasma.stop();
    }
    function fadeOutIntroPlasmaAndStop(){
      const layer = document.getElementById('introPlasmaLayer');
      if (!layer) return;
      introPlasmaFading = true;
      layer.classList.add('fade-out');
      layer.classList.remove('show');
      setTimeout(() => {
        if (introPlasma) introPlasma.stop();
        if (layer) layer.classList.remove('fade-out');
        introPlasmaFading = false;
      }, 460);
    }
    function showStartScreen(){ uiView = 'start'; const el=document.getElementById('startScreen'); if (el) el.style.display='flex'; hideIntroPlasmaImmediate(); if (startPlasma) startPlasma.start(); setTimeout(updateStartRunCard, 0); }
    function hideStartScreen(){ uiView = 'game'; const el=document.getElementById('startScreen'); if (el) el.style.display='none'; if (startPlasma) startPlasma.stop(); }
    function updateStartRunCard(){
      const sum = document.getElementById('startRunSummary');
      const btnContinue = document.getElementById('btnContinue');
      if (!sum || !btnContinue) return;
      const hasRun = !!run;
      if (hasRun) {
        sum.textContent = `Floor ${run.floor} Â· Chips ${safeNumber(run.chips)} Â· Debt ${run.loan && run.loan.active && !run.loan.repaid ? "Owed" : "None"}`;
        btnContinue.disabled = false;
      } else {
        sum.textContent = 'No saved run yet';
        btnContinue.disabled = true;
      }
    }

    // =============================================
    // GAME STATE
    // =============================================
    let run = null;
    let blackjackMatch = null;

    // Merchant state
    let merchantOffers = [];
    let removalMode = false;
    let removalCandidates = [];
    let selectedRemovalIdx = null;
    let removalPaidCost = 0;

    // Dealer timers (bug-proof reset)
    let dealerTimerA = null;
    let dealerTimerB = null;
    function clearDealerTimers() {
      if (dealerTimerA) clearTimeout(dealerTimerA);
      if (dealerTimerB) clearTimeout(dealerTimerB);
      dealerTimerA = null;
      dealerTimerB = null;
    }

    // =============================================
    // UI SETTINGS + LOGGING (Option B)
    // =============================================
    // --- Story/Record context (used by run logs + story generator)
    const APP_BUILD = '0.52';
    const APP_VARIANT = 'p63_0.52.html';
    const CASINO_ID = 'grand_casino';
    const CASINO_NAME = 'Grand Casino';
    const DEFAULT_NARRATOR = 'The Archivist';
    const MARGINALIA_RATE_PER_FLOOR = 0.25;

    const LOG_STORAGE_KEY = 'p63_runlog_latest';
    const PLAYER_NAME_KEY = 'p63_player_name';
    const SFX_ENABLED_KEY = 'p63_sfx_enabled';
    const SFX_VOLUME_KEY = 'p63_sfx_volume';
    const HELP_ENABLED_KEY = 'p63_help_enabled';
    const HELP_DEFAULT_OPEN_KEY = 'p63_help_default_open';
    const TOOLTIPS_ENABLED_KEY = 'p63_tooltips_enabled';
    const TUTORIALS_ENABLED_KEY = 'p63_tutorials_enabled';
    const REDUCE_MOTION_KEY = 'p63_reduce_motion';
    const TUTORIAL_SEEN_KEY = 'p63_tutorial_seen_table';
    let uiSettings = {
      autoOpenLogOnEnd: true,

      // if false, dealer totals + hole cards reveal only at match resolution (unless Spy Network)
      revealTotalsOnClose: false,

      // NEW: opponent AI difficulty
      opponentDifficulty: 'hard', // 'easy' | 'medium' | 'hard'

      // (kept) house rake mode (this used to be uiSettings.difficulty)
      rakeMode: 'hard', // 'easy' (none) | 'medium' (10% flat) | 'hard' (10/20/30)

      // hard cap for bench capacity (0 = no cap)
      benchHardCap: 3, // 2 or 3 (or 0 for â€œno capâ€)

      // SFX (NEW)
      sfxEnabled: true,
      sfxVolume: 0.70,

      // NEW â€” player help
      helpEnabled: true,
      helpDefaultOpen: true,
      tooltipsEnabled: true,
      tutorialsEnabled: true,
      reduceMotion: false
    };

    // Back-compat: if you had older saves/edits that set uiSettings.difficulty
    if (uiSettings.difficulty && !uiSettings.opponentDifficulty) uiSettings.opponentDifficulty = uiSettings.difficulty;
    if (uiSettings.difficulty && !uiSettings.rakeMode) uiSettings.rakeMode = uiSettings.difficulty;

    function loadPlayerName() {
      try { return localStorage.getItem(PLAYER_NAME_KEY) || ''; } catch (e) { return ''; }
    }

    function savePlayerName(name) {
      try { localStorage.setItem(PLAYER_NAME_KEY, name || ''); } catch (e) {}
    }

    function clearPlayerName() {
      try { localStorage.removeItem(PLAYER_NAME_KEY); } catch (e) {}
    }

    function loadSfxPrefs() {
      try {
        const e = localStorage.getItem(SFX_ENABLED_KEY);
        const v = localStorage.getItem(SFX_VOLUME_KEY);
        if (e !== null) uiSettings.sfxEnabled = (e === '1');
        if (v !== null) uiSettings.sfxVolume = Math.max(0, Math.min(1, parseFloat(v)));
      } catch (err) {}

      try {
        if (window.SFX) {
          SFX.setEnabled(uiSettings.sfxEnabled !== false);
          SFX.setVolume(uiSettings.sfxVolume);
        }
      } catch (err) {}
    }

    function saveSfxPrefs() {
      try {
        localStorage.setItem(SFX_ENABLED_KEY, (uiSettings.sfxEnabled !== false) ? '1' : '0');
        localStorage.setItem(SFX_VOLUME_KEY, String(Math.max(0, Math.min(1, parseFloat(uiSettings.sfxVolume)))));
      } catch (err) {}
    }

    function loadHelpPrefs() {
      try {
        const vHelp = localStorage.getItem(HELP_ENABLED_KEY);
        if (vHelp !== null) uiSettings.helpEnabled = (vHelp === '1');

        const vOpen = localStorage.getItem(HELP_DEFAULT_OPEN_KEY);
        if (vOpen !== null) uiSettings.helpDefaultOpen = (vOpen === '1');

        const vTips = localStorage.getItem(TOOLTIPS_ENABLED_KEY);
        if (vTips !== null) uiSettings.tooltipsEnabled = (vTips === '1');

        const vTut = localStorage.getItem(TUTORIALS_ENABLED_KEY);
        if (vTut !== null) uiSettings.tutorialsEnabled = (vTut === '1');

        const vRM = localStorage.getItem(REDUCE_MOTION_KEY);
        if (vRM !== null) uiSettings.reduceMotion = (vRM === '1');
      } catch (e) {}
    }

    function saveHelpPrefs() {
      try {
        localStorage.setItem(HELP_ENABLED_KEY, uiSettings.helpEnabled ? '1' : '0');
        localStorage.setItem(HELP_DEFAULT_OPEN_KEY, uiSettings.helpDefaultOpen ? '1' : '0');
        localStorage.setItem(TOOLTIPS_ENABLED_KEY, uiSettings.tooltipsEnabled ? '1' : '0');
        localStorage.setItem(TUTORIALS_ENABLED_KEY, uiSettings.tutorialsEnabled ? '1' : '0');
        localStorage.setItem(REDUCE_MOTION_KEY, uiSettings.reduceMotion ? '1' : '0');
      } catch (e) {}
    }

    function applyReduceMotion() {
      document.body.classList.toggle('reduce-motion', !!uiSettings.reduceMotion);
    }

    function hasSeenTableTutorial() {
      try { return localStorage.getItem(TUTORIAL_SEEN_KEY) === '1'; } catch (e) { return false; }
    }

    function markSeenTableTutorial() {
      try { localStorage.setItem(TUTORIAL_SEEN_KEY, '1'); } catch (e) {}
    }


    let gameLog = null;
    let logPanelOpen = false;
    let logPanelTab = 'stats'; // 'events' | 'stats'

    let persistTimer = null;
    function persistLogSoon() {
      if (!gameLog) return;
      if (persistTimer) return;
      persistTimer = setTimeout(() => {
        persistTimer = null;
        try { localStorage.setItem(LOG_STORAGE_KEY, JSON.stringify(gameLog)); } catch (e) {}
      }, 120);
    }

    function generateSessionId() {
      return 'S' + Math.random().toString(16).slice(2, 8).toUpperCase() + '-' + Date.now().toString(16).toUpperCase().slice(-6);
    }

    function getSettingsSnapshot() {
      return {
        revealTotalsOnClose: (uiSettings && uiSettings.revealTotalsOnClose) !== false,
        opponentDifficulty: (uiSettings && (uiSettings.opponentDifficulty || uiSettings.difficulty)) || 'hard',
        rakeMode: (uiSettings && uiSettings.rakeMode) || 'hard',
        benchHardCap: safeNumber(uiSettings && uiSettings.benchHardCap, 3),
        autoOpenLogOnEnd: !!(uiSettings && uiSettings.autoOpenLogOnEnd),
        rulesContext: {
          benchBaseCapacity: BENCH_BASE_CAPACITY,
          benchBonusPerBossWin: BENCH_CAPACITY_BONUS_PER_BOSS_WIN,
          modifierPurchaseLimitPerDelta: MOD_PURCHASE_LIMIT_PER_DELTA,
          startingChips: STARTING_CHIPS,
          buyins: {
            standard: BUYIN_STANDARD,
            highStakes: BUYIN_HIGH,
            boss: BUYIN_BOSS
          },
          blackjack21Reward: BLACKJACK_21_REWARD,
          allFive21Bonus: ALL_FIVE_21_BONUS
        }
      };
    }

    function buildDeckSummary() {
      const deck = run ? (run.playerDeck || []) : [];
      const bySuit = { 'â™ ': 0, 'â™¥': 0, 'â™¦': 0, 'â™£': 0, [KEY_SUIT]: 0 };
      const byRank = Object.fromEntries(RANKS.map(r => [r, 0]));
      let modCount = 0;
      let fusedCount = 0;
      let sleevedCount = 0;
      let stampedCount = 0;

      for (const c of deck) {
        if (isModifier(c)) {
          modCount += 1;
          continue;
        }
        if (isFused(c)) {
          fusedCount += 1;
          continue;
        }
        if (isKeyCard(c)) {
          if (bySuit[c.suit] !== undefined) bySuit[c.suit] += 1;
          if (byRank[c.rank] !== undefined) byRank[c.rank] += 1;
          continue;
        }
        if (isStandardCard(c)) {
          if (bySuit[c.suit] !== undefined) bySuit[c.suit] += 1;
          if (byRank[c.rank] !== undefined) byRank[c.rank] += 1;
          if (c.sleeveId) sleevedCount += 1;
          if (c.stampId) stampedCount += 1;
        }
      }

      return {
        deckSize: deck.length,
        modCount,
        fusedCount,
        sleevedCount,
        stampedCount,
        bySuit,
        byRank
      };
    }

    function serializeCard(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: card.uid || null, kind: 'MOD', delta: card.delta };
      if (isKeyCard(card)) return { uid: card.uid || null, kind: 'KEY', rank: card.rank, suit: card.suit, keySource: card.keySource || null };
      if (isFused(card)) {
        return {
          uid: card.uid || null,
          kind: 'FUSE',
          a: serializeCard(card.a),
          b: serializeCard(card.b)
        };
      }
      return {
        uid: card.uid || null,
        kind: 'STD',
        rank: card.rank,
        suit: card.suit,
        stampId: card.stampId || null,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function serializeDeck() {
      const deck = run ? (run.playerDeck || []) : [];
      return {
        cards: deck.map(serializeCard)
      };
    }

    function deckSnapshot() {
      const summary = buildDeckSummary();
      return {
        deckId: gameLog ? gameLog.currentDeckId : null,
        deckSize: summary.deckSize,
        modCount: summary.modCount,
        fusedCount: summary.fusedCount,
        sleevedCount: summary.sleevedCount,
        stampedCount: summary.stampedCount,
        bySuit: summary.bySuit,
        byRank: summary.byRank
      };
    }

    function recordDeckSnapshot(reason, extraData = {}) {
      if (!gameLog || !run) return null;
      const nextId = safeNumber(gameLog.currentDeckId, 0) + 1;
      gameLog.currentDeckId = nextId;
      const entry = {
        deckId: nextId,
        ts: new Date().toISOString(),
        reason,
        ctx: getEventCtx(),
        deck: serializeDeck(),
        summary: buildDeckSummary(),
        ...extraData
      };
      gameLog.deckHistory.push(entry);
      if (gameLog.stats) gameLog.stats.deckSnapshots = safeNumber(gameLog.stats.deckSnapshots, 0) + 1;
      persistLogSoon();
      return nextId;
    }

    function resetLog() {
      const snap = deckSnapshot();
      const chipsNow = run ? safeNumber(run.chips, 0) : 0;
      const sessionId = generateSessionId();
      const rulesContext = {
        collector: {
          costByRarity: { ...COLLECTOR_COST_BY_RARITY },
          rarityRates: { common: 0.55, uncommon: 0.35, rare: 0.10 }
        },
        modify: {
          services: Object.values(MODIFY_SERVICES).map(s => ({ id: s.id, tier: s.tier, kind: s.kind })),
          pricing: { coreBase: 100, coreInc: 25, premiumBase: 200, premiumInc: 50 }
        },
        stamps: Object.values(STAMP_DEFS).map(s => ({ id: s.id, rarity: s.rarity })),
        sleeves: Object.values(SLEEVE_DEFS).map(s => ({ id: s.id, rarity: s.rarity }))
      };

      gameLog = {
        logVersion: 'D',
        sessionId,
        runId: sessionId,
        startedAt: new Date().toISOString(),
        endedAt: null,
        exportedAt: null,
        app: {
          name: 'Project 63',
          build: APP_BUILD,
          variant: APP_VARIANT,
          casinoId: CASINO_ID,
          casinoName: CASINO_NAME,
          narrator: DEFAULT_NARRATOR,
          marginaliaRatePerFloor: MARGINALIA_RATE_PER_FLOOR,
          userAgent: navigator.userAgent
        },
        player: {
          name: run && run.playerName ? run.playerName : '',
          archetype: null,
          resonancePct: null
        },
        settingsAtStart: getSettingsSnapshot(),
        settingsLatest: getSettingsSnapshot(),
        rulesContext,
        initialState: null,
        finalState: null,
        runOutcome: null,
        feedback: { comments: '', bugs: '', updatedAt: null },
        deckHistory: [],
        currentDeckId: null,
        events: [],
        floorTracker: null,
        stats: {
          floorsReached: 1,
          tilesEntered: 0,
          tilesByType: {},
          matches: 0,
          wins: 0,
          losses: 0,
          ties: 0,
          buyinSpent: 0,
          payoutReceived: 0,
          transferNet: 0,
          bonusChips: 0,
          merchantBuys: 0,
          merchantBuyChips: 0,
          merchantRemoves: 0,
          merchantRemoveChips: 0,
          merchantRerolls: 0,
          merchantRerollChips: 0,
          cocktailsBought: 0,
          cocktailSpendChips: 0,
          collectorOffersShown: 0,
          collectorPurchases: 0,
          collectorBuyChips: 0,
          modifyCandidateSetsShown: 0,
          modifyApplies: 0,
          modifySpendChips: 0,
          loansTaken: 0,
          loansRepaid: 0,
          tokensGained: 0,
          tokensSpent: 0,
          actionsUsed: 0,
          deckSnapshots: 0,
          feedbackUpdates: 0,
          chipsPeak: chipsNow,
          chipsLow: chipsNow,
          deckSizeMin: snap.deckSize,
          deckSizeMax: snap.deckSize,
          modCountMin: snap.modCount,
          modCountMax: snap.modCount,
          matchDurationMsTotal: 0,
          rakePaidTotal: 0,
          bossClears: 0
        }
      };
      persistLogSoon();
    }

    function updateLogStats(evt) {
      if (!gameLog || !gameLog.stats) return;
      const st = gameLog.stats;

      if (evt && typeof evt.chips === 'number') {
        st.chipsPeak = Math.max(st.chipsPeak, evt.chips);
        st.chipsLow = Math.min(st.chipsLow, evt.chips);
      }
      if (evt && evt.data && evt.data.deckSnapshot) {
        const ds = evt.data.deckSnapshot;
        if (typeof ds.deckSize === 'number') {
          st.deckSizeMin = Math.min(st.deckSizeMin, ds.deckSize);
          st.deckSizeMax = Math.max(st.deckSizeMax, ds.deckSize);
        }
        if (typeof ds.modCount === 'number') {
          st.modCountMin = Math.min(st.modCountMin, ds.modCount);
          st.modCountMax = Math.max(st.modCountMax, ds.modCount);
        }
      }

      switch (evt.type) {
        case 'FLOOR_START': st.floorsReached = Math.max(st.floorsReached, evt.floor || 1); break;
        case 'TILE_ENTER': st.tilesEntered += 1; st.tilesByType[evt.data.tileType] = (st.tilesByType[evt.data.tileType] || 0) + 1; break;
        case 'MATCH_START': st.matches += 1; st.buyinSpent += safeNumber(evt.data.buyIn, 0); break;
        case 'MATCH_END':
          if (evt.data.outcome === 'WIN') st.wins += 1; else if (evt.data.outcome === 'LOSS') st.losses += 1; else st.ties += 1;
          st.payoutReceived += safeNumber(evt.data.payout, 0);
          st.transferNet += safeNumber(evt.data.transferNet, 0);
          st.bonusChips += safeNumber(evt.data.bonusChips, 0);
          st.rakePaidTotal += safeNumber(evt.data.rake, 0);
          st.matchDurationMsTotal += safeNumber(evt.data.durationMs, 0);
          break;
        case 'BOSS_CLEARED': st.bossClears += 1; break;
        case 'TOKEN_GAIN': st.tokensGained += safeNumber(evt.data.amount, 0); break;
        case 'TOKEN_SPENT': st.tokensSpent += safeNumber(evt.data.amount, 0); break;
        case 'ACTION_USED': st.actionsUsed += 1; break;
        case 'MERCHANT_BUY': st.merchantBuys += 1; st.merchantBuyChips += safeNumber(evt.data.cost, 0); break;
        case 'MERCHANT_REMOVE_START': st.merchantRemoveChips += safeNumber(evt.data.cost, 0); break;
        case 'MERCHANT_REMOVE_CONFIRM': st.merchantRemoves += 1; break;
        case 'MERCHANT_REROLL': st.merchantRerolls += 1; st.merchantRerollChips += safeNumber(evt.data.cost, 0); break;
        case 'COCKTAIL_BOUGHT': st.cocktailsBought += 1; st.cocktailSpendChips += safeNumber(evt.data.cost, 0); break;
        case 'LOAN_TAKEN': st.loansTaken += 1; break;
        case 'LOAN_REPAID': st.loansRepaid += 1; break;
        case 'COLLECTOR_SHOP_GENERATED': st.collectorOffersShown += 1; break;
        case 'COLLECTOR_BUY': st.collectorPurchases += 1; st.collectorBuyChips += safeNumber(evt.data.cost, 0); break;
        case 'MODIFY_CANDIDATES_SHOWN': st.modifyCandidateSetsShown += 1; break;
        case 'MODIFY_APPLY': st.modifyApplies += 1; break;
        case 'MODIFY_SERVICE_SELECT': st.modifySpendChips += safeNumber(evt.data.cost, 0); break;
        case 'FEEDBACK_UPDATED': st.feedbackUpdates += 1; break;
        case 'DECK_SNAPSHOT': st.deckSnapshots += 1; break;
      }
    }

    function beginFloorTracking(floorNum) {
      if (!gameLog || !run) return;
      gameLog.floorTracker = {
        floor: floorNum,
        startedAt: new Date().toISOString(),
        chipsStart: safeNumber(run.chips, 0),
        karmaStart: safeNumber(run.karma, 0),
        chipsLow: safeNumber(run.chips, 0),
        chipsHigh: safeNumber(run.chips, 0),
        matches: 0,
        wins: 0,
        losses: 0,
        ties: 0
      };
    }

    function endCurrentFloorIfOpen({ endReason = 'FLOOR_EXIT' } = {}) {
      if (!gameLog || !gameLog.floorTracker || !run) return;
      const ft = gameLog.floorTracker;
      const summary = {
        floor: ft.floor,
        startedAt: ft.startedAt,
        endedAt: new Date().toISOString(),
        chipsStart: ft.chipsStart,
        chipsEnd: safeNumber(run.chips, 0),
        chipsLow: ft.chipsLow,
        chipsHigh: ft.chipsHigh,
        karmaStart: ft.karmaStart,
        karmaEnd: safeNumber(run.karma, 0),
        karmaGain: safeNumber(run.karma, 0) - ft.karmaStart,
        matches: ft.matches,
        wins: ft.wins,
        losses: ft.losses,
        ties: ft.ties,
        endReason
      };
      logEvent('FLOOR_END', summary);
      gameLog.floorTracker = null;
    }

    function getEventMeta(type, data = {}) {
      const base = { scope: 'both', importance: 40, category: 'system' };
      const map = {
        FLOOR_START: { scope: 'story', importance: 85, category: 'run' },
        FLOOR_END: { scope: 'story', importance: 88, category: 'run' },
        RUN_SUMMARY: { scope: 'story', importance: 95, category: 'run' },
        TILE_ENTER: { scope: 'story', importance: 55, category: 'movement' },
        MATCH_START: { scope: 'story', importance: 70, category: 'match' },
        MATCH_END: { scope: 'story', importance: 82, category: 'match' },
        MATCH_START_FAILED: { scope: 'story', importance: 90, category: 'terminal' },
        GAME_END: { scope: 'story', importance: 100, category: 'terminal' },
        LOAN_DEFAULTED: { scope: 'story', importance: 92, category: 'terminal' },
        BOSS_FIGHT_FAILED: { scope: 'story', importance: 90, category: 'boss' },
        BOSS_CLEARED: { scope: 'story', importance: 88, category: 'boss' },
        KEYCARD_OBTAINED: { scope: 'story', importance: 84, category: 'progression' },
        NPC_ASSIGNED: { scope: 'debug', importance: 20, category: 'debug' }
      };
      return { ...base, ...(map[type] || {}) };
    }

    function getEventCtx() {
      const currentTile = run && run.board && run.board.tiles && run.board.currentTileId !== null
        ? run.board.tiles[run.board.currentTileId]
        : null;
      return {
        floor: run ? run.floor : null,
        chips: run ? safeNumber(run.chips, null) : null,
        karma: run ? safeNumber(run.karma, null) : null,
        callingCard: run && run.callingCard ? { ...run.callingCard } : null,
        tileId: run && run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        mode: run && run.ui ? run.ui.mode : null
      };
    }

    function logEvent(type, data = {}) {
      if (!gameLog) return;
      const prev = gameLog.events.length ? gameLog.events[gameLog.events.length - 1] : null;
      const chips = run ? safeNumber(run.chips, null) : null;
      const karma = run ? safeNumber(run.karma, null) : null;
      const prevChips = prev ? safeNumber(prev.chips, chips) : chips;
      const prevKarma = prev ? safeNumber(prev.karma, karma) : karma;
      const evt = {
        id: gameLog.events.length + 1,
        ts: new Date().toISOString(),
        type,
        floor: run ? run.floor : null,
        chips,
        karma,
        meta: getEventMeta(type, data),
        ctx: getEventCtx(),
        delta: {
          chips: (typeof chips === 'number' && typeof prevChips === 'number') ? (chips - prevChips) : null,
          karma: (typeof karma === 'number' && typeof prevKarma === 'number') ? (karma - prevKarma) : null
        },
        data
      };
      gameLog.events.push(evt);
      if (gameLog.floorTracker && typeof chips === 'number') {
        gameLog.floorTracker.chipsLow = Math.min(gameLog.floorTracker.chipsLow, chips);
        gameLog.floorTracker.chipsHigh = Math.max(gameLog.floorTracker.chipsHigh, chips);
      }
      if (gameLog.floorTracker && type === 'MATCH_START') gameLog.floorTracker.matches += 1;
      if (gameLog.floorTracker && type === 'MATCH_END') {
        if (data.outcome === 'WIN') gameLog.floorTracker.wins += 1;
        else if (data.outcome === 'LOSS') gameLog.floorTracker.losses += 1;
        else gameLog.floorTracker.ties += 1;
      }
      updateLogStats(evt);
      persistLogSoon();
      if (logPanelOpen) renderLogPanel();
    }

    function finalizeRunLog(outcomeObj = {}) {
      if (!gameLog || !run) return;
      if (!gameLog.endedAt) gameLog.endedAt = new Date().toISOString();

      const currentTile = run.board && run.board.tiles && run.board.currentTileId !== null
        ? run.board.tiles[run.board.currentTileId]
        : null;
      const baseOutcome = {
        outcome: outcomeObj.outcome || null,
        floor: run.floor,
        tileId: run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        matchSeq: blackjackMatch ? blackjackMatch.matchSeq : null,
        chips: safeNumber(run.chips, 0),
        message: outcomeObj.message || null,
        reasonCode: outcomeObj.reasonCode || 'UNKNOWN'
      };

      const analysis = getRunEndAnalysis();
      const playstyle = analysis && analysis.summary ? analysis.summary.playstyle : null;
      const resonancePct = playstyle ? Math.round(safeNumber(playstyle.confidence, 0) * 100) : null;

      gameLog.player.archetype = playstyle && playstyle.primary ? playstyle.primary.name : null;
      gameLog.player.resonancePct = resonancePct;
      gameLog.runOutcome = { ...baseOutcome };
      gameLog.finalState = {
        chips: safeNumber(run.chips, 0),
        karma: safeNumber(run.karma, 0),
        floor: run.floor,
        tileId: run.board ? run.board.currentTileId : null,
        tileType: currentTile ? currentTile.type : null,
        callingCard: run.callingCard ? { ...run.callingCard } : null,
        deckSnapshot: deckSnapshot(),
        deckSummary: buildDeckSummary(),
        playstyle: playstyle ? { ...playstyle, resonancePct } : null
      };
      if (run.feedback) gameLog.feedback = { ...run.feedback };

      logEvent('RUN_SUMMARY', {
        outcome: baseOutcome.outcome,
        reasonCode: baseOutcome.reasonCode,
        floorsReached: gameLog.stats ? gameLog.stats.floorsReached : null,
        matches: gameLog.stats ? gameLog.stats.matches : null,
        wins: gameLog.stats ? gameLog.stats.wins : null,
        losses: gameLog.stats ? gameLog.stats.losses : null,
        ties: gameLog.stats ? gameLog.stats.ties : null,
        chipsStart: gameLog.initialState ? gameLog.initialState.chips : null,
        chipsEnd: safeNumber(run.chips, 0),
        karmaStart: gameLog.initialState ? gameLog.initialState.karma : null,
        karmaEnd: safeNumber(run.karma, 0),
        archetype: gameLog.player.archetype,
        resonancePct
      });
      persistLogSoon();
    }

    function formatTime(tsIso) {
      const d = new Date(tsIso);
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      const ss = String(d.getSeconds()).padStart(2, '0');
      return `${hh}:${mm}:${ss}`;
    }

    function eventSummary(evt) {
      const t = evt.type;
      const d = evt.data || {};
      if (t === 'GAME_START') return `Run started. Chips=${d.startingChips}, Deck=${d.deckSize}`;
      if (t === 'FLOOR_START') return `Entered Floor ${d.floor}`;
      if (t === 'TILE_ENTER') return `Entered tile #${d.tileId} (${d.tileType})`;
      if (t === 'REST_CHOICE') return `Lounge: ${d.choice}${d.freeRemoval ? ' (free removal)' : ''}`;
      if (t === 'MINIGAME_START') return `Minigame start: ${d.kind}${d.entryCost ? ` (entry ${d.entryCost})` : ''}`;
      if (t === 'MINIGAME_REWARD_OFFER') return `Infiltration rewards offered (set ${d.rewardSetId || 'n/a'})`;
      if (t === 'MINIGAME_END') return `Minigame end: ${d.kind} ${d.outcome || d.reason || ''}`.trim();
      if (t === 'BARTENDER_TAKE') return `Bartender: took +${d.chips} chips`;
      if (t === 'COCKTAIL_BOUGHT') return `Bought cocktail: ${d.actionName} (-${d.cost})`;
      if (t === 'LOAN_TAKEN') return `Loan taken +${d.amount}, owe ${d.repay}`;
      if (t === 'LOAN_REPAID') return `Loan repaid -${d.amount}`;
      if (t === 'MERCHANT_ENTER') return `Shop Keeper opened`;
      if (t === 'MODIFY_ENTER') return `Card Press opened`;
      if (t === 'MODIFY_SERVICE_SELECT') return `Card Press service: ${d.serviceId} (-${d.cost})`;
      if (t === 'MODIFY_CANDIDATES_SHOWN') return `Card Press candidates shown (${d.countShown || 0})`;
      if (t === 'MODIFY_SELECTION') return `Card Press selection: ${d.serviceId}`;
      if (t === 'MODIFY_APPLY') return `Card Press applied: ${d.serviceId} (${d.count || 0} cards)`;
      if (t === 'MODIFY_LEAVE') return `Card Press closed`;
      if (t === 'COLLECTOR_SHOP_GENERATED') return `Collector shop generated`;
      if (t === 'COLLECTOR_ENTER') return `Collector opened`;
      if (t === 'COLLECTOR_BUY') return `Collector buy: ${d.name} (-${d.cost})`;
      if (t === 'STAMP_OPTIONS_SHOWN') return `Stamp options shown (${d.options ? d.options.join(',') : ''})`;
      if (t === 'SLEEVE_CANDIDATES_SHOWN') return `Sleeve candidates shown`;
      if (t === 'STAMP_APPLY') return `Stamp applied: ${d.stampId} on ${d.rank}`;
      if (t === 'SLEEVE_APPLY') return `Sleeve applied: ${d.sleeveId} on ${d.card}`;
      if (t === 'COLLECTOR_LEAVE') return `Collector closed`;
      if (t === 'MERCHANT_BUY') return `Bought ${d.card} (-${d.cost})`;
      if (t === 'MERCHANT_REMOVE_START') return `Removal started (-${d.cost})`;
      if (t === 'MERCHANT_REMOVE_CONFIRM') return `Removed ${d.card}`;
      if (t === 'MERCHANT_REROLL') return `Merchant reroll (${d.which}) (-${d.cost})`;
      if (t === 'MODIFIER_SOLD_OUT') return `Modifier sold out: ${d.card} (limit ${d.limit})`;
      if (t === 'MATCH_START') return `Match start: ${d.type}, buy-in ${d.buyIn}, tokens ${d.tokensTotal}`;
      if (t === 'PLAYER_DRAW') return `Player drew ${d.card}`;
      if (t === 'PLAYER_DRAW_BENCH') return `Player drew modifier ${d.card} (benched)`;
      if (t === 'PLAYER_PLACE') return `Player placed ${d.card} to lane #${d.lane}`;
      if (t === 'PLAYER_STAND') return `Player stood lane #${d.lane} (total ${d.total})`;
      if (t === 'BENCH_APPLY') return `Bench applied ${d.card} to ${d.side} lane #${d.lane}`;
      if (t === 'BENCH_PLACE') return `Bench placed ${d.card} to player lane #${d.lane}`;
      if (t === 'BENCH_OVERFLOW') return `Bench overflow: discarded ${d.removed}`;
      if (t === 'TRANSFER_BET') return `Side Bet: player x${d.playerMultiplier} (${d.dealerAction}${d.offer ? ` to x${d.offer}` : ''})`;
      if (t === 'TRANSFER_BET_RESPONSE') return `Side Bet response: ${d.response} (x${d.finalMultiplier})`;
      if (t === 'ACTION_USED') return `Action used: ${d.actionName}`;
      if (t === 'BONUS_21') return `Bonus: lane #${d.lane} hit 21 (+${d.amount})`;
      if (t === 'BONUS_ALL_FIVE') return `Bonus: all five hit 21 (+${d.amount})`;
      if (t === 'SETTINGS_CHANGED') return `Settings updated`;
      if (t === 'CALLING_CARD_SET') return `Calling card set: ${d.callingCard ? cardToString(d.callingCard) : 'â€”'}`;
      if (t === 'CALLING_PROC_DIAMOND') return `Calling (â™¦): +${d.amount} chips`;
      if (t === 'CALLING_PROC_CLUBS') return `Calling (â™£): dealer lane #${d.laneIdx} ${d.delta}`;
      if (t === 'CALLING_PROC_SPADES') return `Calling (â™ ): revealed dealer lane #${d.laneIdx}`;
      if (t === 'CALLING_PROC_HEARTS_TRIAGE') return `Calling (â™¥): triage lane #${d.laneIdx}`;
      if (t === 'CALLING_CARD_LEVEL_UP') return `Calling card leveled: ${d.fromRank} â†’ ${d.toRank}`;
      if (t === 'NPC_ASSIGNED') return `NPC: ${d.npcName} (${d.tileType})`;
      if (t === 'GOLD_SLEEVE_BONUS') return `Gold sleeve bonus +${d.amount} (lane #${d.laneIdx})`;
      if (t === 'BURN_AFTER_READING') return `Burned ${d.count} stamped card(s)`;
      if (t === 'MERCHANT_ENTER') return `Merchant: ${d.npcName} (prices x${d.priceMult})`;
      if (t === 'WINNER_REWARD_FUSE') return `Fused ${d.cards ? d.cards.join(' + ') : 'cards'}`;
      if (t === 'DECK_EXHAUSTION') return `Deck exhaustion: ${d.side} (${d.reason})`;
      if (t === 'MATCH_END') return `Match end: ${d.outcome} (payout ${d.payout}, transfer ${d.transferNet >= 0 ? '+' : ''}${d.transferNet})`;
      if (t === 'BOSS_CLEARED') return `Boss cleared on floor ${d.floor}`;
      if (t === 'KARMA_GAIN') return `Karma +${d.amount} (total ${d.total})`;
      if (t === 'FEEDBACK_UPDATED') return `Feedback updated`;
      if (t === 'DECK_SNAPSHOT') return `Deck snapshot saved`;
      if (t === 'GAME_END') return `Run ended: ${d.result} (${d.reasonCode || 'UNKNOWN'})`;
      if (t === 'FLOOR_END') return `Floor ${d.floor} ended (${d.endReason})`;
      if (t === 'RUN_SUMMARY') return `Run summary: ${d.outcome || 'UNKNOWN'} Â· ${d.reasonCode || 'UNKNOWN'}`;
      return t;
    }

    function openLogPanel(tab = 'stats') {
      logPanelTab = tab;
      logPanelOpen = true;
      const el = document.getElementById('logPanel');
      el.classList.add('open');
      renderLogPanel();
    }

    function closeLogPanel() {
      logPanelOpen = false;
      const el = document.getElementById('logPanel');
      el.classList.remove('open');
    }

    function switchLogTab(tab) {
      logPanelTab = tab;
      renderLogPanel();
    }

    function exportLog() {
      if (!gameLog) return;
      if (!gameLog.exportedAt) gameLog.exportedAt = new Date().toISOString();
      if (!gameLog.endedAt && run && (run.ui.mode === 'GAMEOVER' || run.ui.mode === 'VICTORY')) {
        const outcome = run.ui.mode === 'VICTORY' ? 'win' : 'loss';
        finalizeRunLog({ outcome, message: run.ui.message || null });
      }
      const payload = JSON.stringify(gameLog, null, 2);
      const blob = new Blob([payload], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `project63_runlog_${gameLog.sessionId}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      showToast('Log exported');
    }

    function clearSavedLog() {
      try { localStorage.removeItem(LOG_STORAGE_KEY); } catch (e) {}
      showToast('Saved log cleared');
    }

    function renderLogEvents() {
      const events = (gameLog && gameLog.events) ? gameLog.events.slice().reverse() : [];
      if (!events.length) return `<div class="log-card"><div class="log-card-body">No events yet.</div></div>`;

      return events.map(evt => {
        const time = formatTime(evt.ts);
        const summary = eventSummary(evt);
        const details = JSON.stringify(evt.data || {}, null, 2);
        return `
          <div class="log-card">
            <div class="log-card-head">
              <div><span class="log-type">${evt.type}</span> <span style="opacity:.85;">Â· F${evt.floor ?? '-'}</span></div>
              <div>${time}</div>
            </div>
            <div class="log-card-body">${summary}</div>
            ${details && details !== "{}" ? `<div class="log-kv">${details}</div>` : ``}
          </div>
        `;
      }).join('');
    }

    function formatRate(numerator, denominator) {
      if (!denominator) return 'â€”';
      return `${Math.round((numerator / denominator) * 100)}%`;
    }

    function initPerfBucket() {
      return {
        matches: 0,
        lanesPlayed: 0,
        playerTotalSum: 0,
        playerNonBustSum: 0,
        playerNonBustCount: 0,
        playerBustLanes: 0,
        dealerBustLanes: 0,
        player21Lanes: 0,
        dealer21Lanes: 0,
        laneW: 0,
        laneL: 0,
        laneT: 0,
        matchW: 0,
        matchL: 0,
        matchT: 0
      };
    }

    function computeDerivedPerf(events) {
      const perf = {
        overall: initPerfBucket(),
        byFloor: {},
        byType: {},
        recentMatches: []
      };

      (events || []).forEach(evt => {
        if (!evt || evt.type !== 'MATCH_END') return;
        const lanes = evt.data && evt.data.lanes;
        if (!lanes) return;

        const playerTotals = lanes.playerTotals || [];
        const dealerTotals = lanes.dealerTotals || [];
        const playerBusts = lanes.playerBusts || [];
        const dealerBusts = lanes.dealerBusts || [];
        const laneWinners = lanes.laneWinners || [];

        const bucket = perf.overall;
        const floorKey = String(evt.floor || 'â€”');
        const typeKey = evt.data.type || 'UNKNOWN';

        if (!perf.byFloor[floorKey]) perf.byFloor[floorKey] = initPerfBucket();
        if (!perf.byType[typeKey]) perf.byType[typeKey] = initPerfBucket();

        const floorBucket = perf.byFloor[floorKey];
        const typeBucket = perf.byType[typeKey];
        const buckets = [bucket, floorBucket, typeBucket];

        buckets.forEach(b => { b.matches += 1; });
        if (evt.data.outcome === 'WIN') buckets.forEach(b => { b.matchW += 1; });
        else if (evt.data.outcome === 'LOSS') buckets.forEach(b => { b.matchL += 1; });
        else buckets.forEach(b => { b.matchT += 1; });

        let matchPlayerTotalSum = 0;
        let matchPlayerNonBustSum = 0;
        let matchPlayerNonBustCount = 0;
        let matchPlayerBusts = 0;
        let matchPlayer21s = 0;
        let matchLaneW = 0;
        let matchLaneL = 0;
        let matchLaneT = 0;

        for (let i = 0; i < laneWinners.length; i++) {
          const pTotal = safeNumber(playerTotals[i], 0);
          const dTotal = safeNumber(dealerTotals[i], 0);
          const pBust = !!playerBusts[i];
          const dBust = !!dealerBusts[i];
          const winner = laneWinners[i];

          matchPlayerTotalSum += pTotal;
          if (!pBust) {
            matchPlayerNonBustSum += pTotal;
            matchPlayerNonBustCount += 1;
          } else {
            matchPlayerBusts += 1;
          }
          if (pTotal === 21 && !pBust) matchPlayer21s += 1;

          buckets.forEach(b => {
            b.lanesPlayed += 1;
            b.playerTotalSum += pTotal;
            if (!pBust) {
              b.playerNonBustSum += pTotal;
              b.playerNonBustCount += 1;
            }
            if (pBust) b.playerBustLanes += 1;
            if (dBust) b.dealerBustLanes += 1;
            if (pTotal === 21 && !pBust) b.player21Lanes += 1;
            if (dTotal === 21 && !dBust) b.dealer21Lanes += 1;
          });

          if (winner === 'player') {
            buckets.forEach(b => { b.laneW += 1; });
            matchLaneW += 1;
          } else if (winner === 'dealer') {
            buckets.forEach(b => { b.laneL += 1; });
            matchLaneL += 1;
          } else {
            buckets.forEach(b => { b.laneT += 1; });
            matchLaneT += 1;
          }
        }

        const matchAvgIncl = matchPlayerTotalSum / 5;
        const matchAvgExcl = matchPlayerNonBustCount ? (matchPlayerNonBustSum / matchPlayerNonBustCount) : null;
        perf.recentMatches.push({
          floor: evt.floor,
          type: evt.data.type,
          outcome: evt.data.outcome,
          avgIncl: matchAvgIncl,
          avgExcl: matchAvgExcl,
          playerBusts: matchPlayerBusts,
          player21s: matchPlayer21s,
          laneW: matchLaneW,
          laneL: matchLaneL,
          laneT: matchLaneT
        });
      });

      return perf;
    }

    function renderLogStats() {
      const s = (gameLog && gameLog.stats) ? gameLog.stats : null;
      if (!s) return `<div class="log-card"><div class="log-card-body">No stats yet.</div></div>`;

      const derived = computeDerivedPerf(gameLog.events || []);
      const overall = derived.overall;
      const avgLaneIncl = overall.lanesPlayed ? (overall.playerTotalSum / overall.lanesPlayed) : 0;
      const avgLaneExcl = overall.playerNonBustCount ? (overall.playerNonBustSum / overall.playerNonBustCount) : null;

      const net = safeNumber(run ? run.chips : 0) - STARTING_CHIPS;

      const tileLines = Object.entries(s.tilesByType || {})
        .sort((a,b) => b[1]-a[1])
        .map(([k,v]) => `${k}: ${v}`)
        .join('\n');

      const avgMatchMs = s.matches ? Math.round(s.matchDurationMsTotal / s.matches) : 0;

      const recentMatches = derived.recentMatches.slice(-10).reverse();

      const floorRows = Object.entries(derived.byFloor).map(([floor, data]) => {
        const avgIncl = data.lanesPlayed ? (data.playerTotalSum / data.lanesPlayed) : 0;
        const avgExcl = data.playerNonBustCount ? (data.playerNonBustSum / data.playerNonBustCount) : null;
        return `
          <tr>
            <td>Floor ${floor}</td>
            <td>${data.matches}</td>
            <td>${data.matchW}/${data.matchL}/${data.matchT}</td>
            <td>${formatRate(data.matchW, data.matches)}</td>
            <td>${avgIncl.toFixed(1)}</td>
            <td>${avgExcl === null ? 'â€”' : avgExcl.toFixed(1)}</td>
            <td>${formatRate(data.playerBustLanes, data.lanesPlayed)}</td>
            <td>${formatRate(data.player21Lanes, data.lanesPlayed)}</td>
            <td>${data.laneW}/${data.laneL}/${data.laneT}</td>
          </tr>
        `;
      }).join('') || `<tr><td colspan="9">No matches yet.</td></tr>`;

      const typeRows = Object.entries(derived.byType).map(([type, data]) => {
        const avgIncl = data.lanesPlayed ? (data.playerTotalSum / data.lanesPlayed) : 0;
        const avgExcl = data.playerNonBustCount ? (data.playerNonBustSum / data.playerNonBustCount) : null;
        return `
          <tr>
            <td>${type}</td>
            <td>${data.matches}</td>
            <td>${data.matchW}/${data.matchL}/${data.matchT}</td>
            <td>${formatRate(data.matchW, data.matches)}</td>
            <td>${avgIncl.toFixed(1)}</td>
            <td>${avgExcl === null ? 'â€”' : avgExcl.toFixed(1)}</td>
            <td>${formatRate(data.playerBustLanes, data.lanesPlayed)}</td>
            <td>${formatRate(data.player21Lanes, data.lanesPlayed)}</td>
            <td>${data.laneW}/${data.laneL}/${data.laneT}</td>
          </tr>
        `;
      }).join('') || `<tr><td colspan="9">No matches yet.</td></tr>`;

      const recentRows = recentMatches.map(m => `
        <tr>
          <td>F${m.floor}</td>
          <td>${m.type}</td>
          <td>${m.outcome}</td>
          <td>${m.avgIncl.toFixed(1)}</td>
          <td>${m.avgExcl === null ? 'â€”' : m.avgExcl.toFixed(1)}</td>
          <td>${m.playerBusts}</td>
          <td>${m.player21s}</td>
          <td>${m.laneW}/${m.laneL}/${m.laneT}</td>
        </tr>
      `).join('') || `<tr><td colspan="8">No recent matches.</td></tr>`;

      return `
        <div class="log-section-title">Run Overview</div>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Session</div>
            <div class="stat-value gold" style="font-size:12px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${gameLog.sessionId}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Floors Reached</div>
            <div class="stat-value">${s.floorsReached}/3</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Chips Peak</div>
            <div class="stat-value good">${s.chipsPeak}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Chips Low</div>
            <div class="stat-value bad">${s.chipsLow}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Net vs Start</div>
            <div class="stat-value ${net >= 0 ? 'good' : 'bad'}">${net >= 0 ? '+' : ''}${net}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Matches</div>
            <div class="stat-value">${s.matches}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">W / L / T</div>
            <div class="stat-value">${s.wins} / ${s.losses} / ${s.ties}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Match Time</div>
            <div class="stat-value">${avgMatchMs}ms</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Buy-ins Spent</div>
            <div class="stat-value">${s.buyinSpent}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Payouts</div>
            <div class="stat-value">${s.payoutReceived}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Transfers Net</div>
            <div class="stat-value ${s.transferNet >= 0 ? 'good' : 'bad'}">${s.transferNet >= 0 ? '+' : ''}${s.transferNet}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Bonus Chips</div>
            <div class="stat-value gold">${s.bonusChips}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Rake Paid</div>
            <div class="stat-value bad">${s.rakePaidTotal}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Tokens Gained / Spent</div>
            <div class="stat-value">${s.tokensGained} / ${s.tokensSpent}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Actions Used</div>
            <div class="stat-value">${s.actionsUsed}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Deck Size Min / Max</div>
            <div class="stat-value">${s.deckSizeMin} / ${s.deckSizeMax}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Mods Min / Max</div>
            <div class="stat-value">${s.modCountMin} / ${s.modCountMax}</div>
          </div>

          <div class="stat-box">
            <div class="stat-label">Merchant Buys</div>
            <div class="stat-value">${s.merchantBuys}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Removals</div>
            <div class="stat-value">${s.merchantRemoves}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Boss Clears</div>
            <div class="stat-value">${s.bossClears}</div>
          </div>

          <div class="stat-box" style="grid-column: 1 / -1;">
            <div class="stat-label">Tiles Entered</div>
            <div class="stat-value">${s.tilesEntered}</div>
            <div class="log-kv" style="margin-top:10px;">${tileLines || '(none yet)'}</div>
          </div>
        </div>

        <div class="log-section-title">Performance</div>
        <div class="stats-grid">
          <div class="stat-box">
            <div class="stat-label">Match W/L/T</div>
            <div class="stat-value">${overall.matchW} / ${overall.matchL} / ${overall.matchT}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Match Win Rate</div>
            <div class="stat-value">${formatRate(overall.matchW, overall.matches)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Lane W/L/T</div>
            <div class="stat-value">${overall.laneW} / ${overall.laneL} / ${overall.laneT}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Lane Win Rate</div>
            <div class="stat-value">${formatRate(overall.laneW, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Player Bust Rate</div>
            <div class="stat-value">${formatRate(overall.playerBustLanes, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Player 21 Rate</div>
            <div class="stat-value">${formatRate(overall.player21Lanes, overall.lanesPlayed)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Lane (Incl Bust)</div>
            <div class="stat-value">${avgLaneIncl.toFixed(1)}</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">Avg Lane (Excl Bust)</div>
            <div class="stat-value">${avgLaneExcl === null ? 'â€”' : avgLaneExcl.toFixed(1)}</div>
          </div>
        </div>

        <div class="log-section-title">Breakdown by Floor</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Floor</th>
              <th>Matches</th>
              <th>W/L/T</th>
              <th>Win %</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust %</th>
              <th>21 %</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${floorRows}
          </tbody>
        </table>

        <div class="log-section-title">Breakdown by Match Type</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Type</th>
              <th>Matches</th>
              <th>W/L/T</th>
              <th>Win %</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust %</th>
              <th>21 %</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${typeRows}
          </tbody>
        </table>

        <div class="log-section-title">Recent Matches</div>
        <table class="log-table">
          <thead>
            <tr>
              <th>Floor</th>
              <th>Type</th>
              <th>Outcome</th>
              <th>Avg Incl</th>
              <th>Avg Excl</th>
              <th>Bust Lanes</th>
              <th>21 Lanes</th>
              <th>Lane W/L/T</th>
            </tr>
          </thead>
          <tbody>
            ${recentRows}
          </tbody>
        </table>
      `;
    }

    function renderLogPanel() {
      const el = document.getElementById('logPanel');
      if (!el) return;

      const sid = gameLog ? gameLog.sessionId : 'â€”';
      const started = gameLog ? gameLog.startedAt : '';
      const sub = started ? `Started ${started.slice(0,19).replace('T',' ')}` : '';

      el.innerHTML = `
        <div class="log-panel-header">
          <div>
            <div class="log-panel-title">Run Log</div>
            <div class="log-panel-sub">${sid} Â· ${sub}</div>
          </div>
          <div class="log-panel-actions">
            <button class="log-mini-btn" onclick="exportLog()">Export</button>
            <button class="log-mini-btn" onclick="clearSavedLog()">Clear</button>
            <button class="log-mini-btn danger" onclick="closeLogPanel()">Close</button>
          </div>
        </div>

        <div class="log-tabs">
          <button class="log-tab ${logPanelTab === 'events' ? 'active' : ''}" onclick="switchLogTab('events')">Events</button>
          <button class="log-tab ${logPanelTab === 'stats' ? 'active' : ''}" onclick="switchLogTab('stats')">Stats</button>
        </div>

        <div class="log-panel-body">
          ${logPanelTab === 'events' ? renderLogEvents() : renderLogStats()}
        </div>
      `;
    }

    function openTestGamesModal() {
      showModal('Test Games', `
        <p class="modal-text">Choose a minigame to run in an endless sandbox loop.</p>
      `, [
        {
          text: 'Poker Slots (Test)',
          primary: true,
          action: () => { closeModal(); Minigames.startTest('POKER_SLOTS'); }
        },
        {
          text: 'Infiltration Run (Test)',
          action: () => { closeModal(); Minigames.startTest('INFILTRATION'); }
        },
        { text: 'Close', action: () => closeModal() }
      ]);

    }

    function openSettingsPanel() {
      const checked = !!uiSettings.autoOpenLogOnEnd;
      const revealOnClose = (uiSettings.revealTotalsOnClose !== false);
      const oppDiff = getOpponentDifficulty();
      const rakeMode = (uiSettings.rakeMode || 'hard');
      const benchCap = String(safeNumber(uiSettings.benchHardCap, 3));
      const sfxEnabled = (uiSettings.sfxEnabled !== false);
      const sfxPct = Math.round(safeNumber(uiSettings.sfxVolume, 0.70) * 100);
      const helpEnabled = (uiSettings.helpEnabled !== false);
      const helpDefaultOpen = (uiSettings.helpDefaultOpen !== false);
      const tooltipsEnabled = (uiSettings.tooltipsEnabled !== false);
      const tutorialsEnabled = (uiSettings.tutorialsEnabled !== false);
      const reduceMotion = !!uiSettings.reduceMotion;

      const body = `
        <p class="modal-text">Player settings + optional testing tools.</p>

        <details open class="settings-section">
          <summary>Gameplay</summary>
          <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">Opponent Difficulty</div>
          <select id="setting_opponentDifficulty" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
            <option value="easy" ${oppDiff === 'easy' ? 'selected' : ''}>Easy â€” safer play, rarely uses bench mods</option>
            <option value="medium" ${oppDiff === 'medium' ? 'selected' : ''}>Medium â€” situational bench use, normal standing</option>
            <option value="hard" ${oppDiff === 'hard' ? 'selected' : ''}>Hard â€” counterplay-focused, proactive bench use</option>
          </select>
        </details>

        <details open class="settings-section">
          <summary>Help</summary>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:8px;">
            <input id="setting_helpEnabled" type="checkbox" ${helpEnabled ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Enable tips in modals</div></div>
          </label>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:8px;">
            <input id="setting_helpDefaultOpen" type="checkbox" ${helpDefaultOpen ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Tips expanded by default</div></div>
          </label>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:8px;">
            <input id="setting_tooltipsEnabled" type="checkbox" ${tooltipsEnabled ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Enable tooltips</div></div>
          </label>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:8px;">
            <input id="setting_tutorialsEnabled" type="checkbox" ${tutorialsEnabled ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Enable first-time tutorials</div></div>
          </label>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer;">
            <input id="setting_reduceMotion" type="checkbox" ${reduceMotion ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Reduce motion</div></div>
          </label>
        </details>

        <details open class="settings-section">
          <summary>Audio</summary>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:10px;">
            <input id="setting_sfxEnabled" type="checkbox" ${sfxEnabled ? 'checked' : ''} style="margin-top:3px;"/>
            <div>
              <div style="font-weight:800; color:var(--text-primary);">Enable SFX</div>
              <div style="color:var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">Warm UI + gameplay sounds (no music in MVP).</div>
            </div>
          </label>
          <div style="display:flex; align-items:center; gap:10px;">
            <input id="setting_sfxVolume" type="range" min="0" max="100" value="${sfxPct}" ${sfxEnabled ? '' : 'disabled'} style="width:100%;" />
            <div id="setting_sfxVolumeReadout" style="min-width:52px; text-align:right; font-weight:800; color:var(--text-primary);">${sfxPct}%</div>
          </div>
        </details>

        <details class="settings-section">
          <summary>Advanced / Testing</summary>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:10px;">
            <input id="setting_autoOpenLog" type="checkbox" ${checked ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Auto-open Run Log on Game Over / Victory</div></div>
          </label>
          <label style="display:flex; gap:10px; align-items:flex-start; cursor:pointer; margin-bottom:10px;">
            <input id="setting_revealTotalsOnClose" type="checkbox" ${revealOnClose ? 'checked' : ''} style="margin-top:3px;"/>
            <div><div style="font-weight:800; color:var(--text-primary);">Reveal Dealer totals + hole card when a lane closes</div></div>
          </label>
          <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">House Rake</div>
          <select id="setting_rakeMode" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary); margin-bottom:10px;">
            <option value="easy" ${rakeMode === 'easy' ? 'selected' : ''}>Off â€” 0%</option>
            <option value="medium" ${rakeMode === 'medium' ? 'selected' : ''}>Flat â€” 10% all floors</option>
            <option value="hard" ${rakeMode === 'hard' ? 'selected' : ''}>Scaled â€” 10% / 20% / 30%</option>
          </select>
          <div style="font-weight:800; color:var(--text-primary); margin-bottom:6px;">Bench hard cap</div>
          <select id="setting_benchHardCap" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">
            <option value="2" ${benchCap === '2' ? 'selected' : ''}>2 slots</option>
            <option value="3" ${benchCap === '3' ? 'selected' : ''}>3 slots</option>
            <option value="0" ${benchCap === '0' ? 'selected' : ''}>No cap (dev)</option>
          </select>
        </details>
      `;

      showModal('Settings', body, [
        {
          text: 'Save',
          primary: true,
          action: () => {
            const prevSettings = getSettingsSnapshot();
            const cbLog = document.getElementById('setting_autoOpenLog');
            const cbReveal = document.getElementById('setting_revealTotalsOnClose');
            const selOpp = document.getElementById('setting_opponentDifficulty');
            const selRake = document.getElementById('setting_rakeMode');
            const selCap = document.getElementById('setting_benchHardCap');
            const cbSfx = document.getElementById('setting_sfxEnabled');
            const volSfx = document.getElementById('setting_sfxVolume');
            const cbHelp = document.getElementById('setting_helpEnabled');
            const cbHelpOpen = document.getElementById('setting_helpDefaultOpen');
            const cbTips = document.getElementById('setting_tooltipsEnabled');
            const cbTut = document.getElementById('setting_tutorialsEnabled');
            const cbReduce = document.getElementById('setting_reduceMotion');

            uiSettings.autoOpenLogOnEnd = !!(cbLog && cbLog.checked);
            uiSettings.revealTotalsOnClose = !!(cbReveal && cbReveal.checked);
            uiSettings.opponentDifficulty = (selOpp && selOpp.value) ? selOpp.value : 'hard';
            uiSettings.rakeMode = (selRake && selRake.value) ? selRake.value : 'hard';
            uiSettings.benchHardCap = safeNumber(selCap && selCap.value, 3);

            uiSettings.sfxEnabled = !!(cbSfx && cbSfx.checked);
            uiSettings.sfxVolume = Math.max(0, Math.min(1, safeNumber(volSfx && volSfx.value, 70) / 100));
            saveSfxPrefs();
            if (window.SFX) {
              SFX.setEnabled(uiSettings.sfxEnabled !== false);
              SFX.setVolume(uiSettings.sfxVolume);
            }

            uiSettings.helpEnabled = !!(cbHelp && cbHelp.checked);
            uiSettings.helpDefaultOpen = !!(cbHelpOpen && cbHelpOpen.checked);
            uiSettings.tooltipsEnabled = !!(cbTips && cbTips.checked);
            uiSettings.tutorialsEnabled = !!(cbTut && cbTut.checked);
            uiSettings.reduceMotion = !!(cbReduce && cbReduce.checked);
            saveHelpPrefs();
            applyReduceMotion();

            const nextSettings = getSettingsSnapshot();
            logEvent('SETTINGS_CHANGED', { prev: prevSettings, next: nextSettings });
            if (gameLog) gameLog.settingsLatest = nextSettings;

            closeModal();
            renderAll();
            showToast('Settings saved');
          }
        },
        { text: 'Close', action: () => closeModal() }
      ]);

      setTimeout(() => {
        const cb = document.getElementById('setting_sfxEnabled');
        const vol = document.getElementById('setting_sfxVolume');
        const ro = document.getElementById('setting_sfxVolumeReadout');
        if (!cb || !vol) return;

        const applyEnabledUI = () => {
          vol.disabled = !cb.checked;
          if (window.SFX) SFX.setEnabled(cb.checked);
          uiSettings.sfxEnabled = cb.checked;
          saveSfxPrefs();
        };

        cb.addEventListener('change', () => {
          applyEnabledUI();
          if (cb.checked && window.SFX) SFX.play('toast');
        });

        vol.addEventListener('input', () => {
          const v = Math.max(0, Math.min(1, (parseInt(vol.value, 10) || 0) / 100));
          uiSettings.sfxVolume = v;
          if (ro) ro.textContent = `${Math.round(v * 100)}%`;
          saveSfxPrefs();
          if (window.SFX) SFX.setVolume(v);
        });

        applyEnabledUI();
      }, 0);
    }

    function openRulesPanel() {
      const html = `
      <div class="rules-wrap">
        <h3 class="rules-h">Goal of the Run</h3>
        <ul class="rules-ul">
          <li>Climb The Pit floor by floor.</li>
          <li>Win tables to earn chips, improve your deck, and advance.</li>
          <li>Clear the <b>Floor Boss</b> to move on.</li>
        </ul>

        <h3 class="rules-h">Board & Tiles</h3>
        <ul class="rules-ul">
          <li>Move tile-to-tile on each floor.</li>
          <li><b>Tables</b> start a match. <b>Services</b> improve your deck and economy.</li>
          <li>Routing is a risk choice: buy-ins vs upgrades vs recovery.</li>
        </ul>

        <h3 class="rules-h">Five-Hand Blackjack</h3>
        <ul class="rules-ul">
          <li>Each match plays across <b>five lanes</b>. Each lane is its own hand.</li>
          <li>On your turn: <b>Draw</b> â†’ <b>Place</b> into an open lane, or use an effect, then end turn.</li>
          <li><b>Stand</b> closes a lane so no more cards can be placed there.</li>
          <li>At resolution, each lane compares totals vs the dealerâ€™s matching lane.</li>
          <li><b>Attack rule:</b> The first player to close a lane deals an <b>Attack</b> to the opponent equal to the <b>last card played</b> to that lane before it closed.</li>
          <li><b>Tokens</b> are a consumable resource used to power certain plays and effects (including Bench plays).</li>
          <li><b>Bench</b> holds cards you set aside to play later. Bench capacity is limited.</li>
        </ul>

        <h3 class="rules-h">Side Bets</h3>
        <ul class="rules-ul">
          <li>Some matches offer a <b>Side Bet</b>.</li>
          <li>Accepting increases risk for higher payoff based on the odds shown.</li>
        </ul>

        <h3 class="rules-h">Calling Card, Karma, Rank Ups</h3>
        <ul class="rules-ul">
          <li>Choose a Calling Suit. Your Calling Card starts at <b>Rank 2</b>.</li>
          <li>Karma is earned from match performance and effects.</li>
          <li><b>Higher rank improves the rate at which your calling cardâ€™s unique suit trait triggers during gameplay.</b></li>
        </ul>

        <h3 class="rules-h">Services & Shops</h3>
        <ul class="rules-ul">
          <li><b>Shopkeeper</b>: buy cards and modifiers.</li>
          <li><b>Card Press</b>: re-suit / re-rank cards (premium services affect multiple cards).</li>
          <li><b>Collector</b>: stamps/sleeves and other upgrades.</li>
          <li><b>Loan Shark</b>: trade safety for immediate power (debt).</li>
          <li><b>Bartender</b>: purchase <b>cocktails</b>. Each cocktail can be used <b>once per match</b>.</li>
        </ul>

        <h3 class="rules-h">Floor Boss</h3>
        <ul class="rules-ul">
          <li>The Floor Boss has a <b>health pool</b> that must be depleted.</li>
          <li><b>Boss HP must be depleted before time runs out.</b></li>
          <li>Boss phases may add targeting and countermeasures.</li>
          <li>Bench persists across boss rounds.</li>
        </ul>
      </div>
      `;
      showModal("Rules", html, [{ text: 'Close', primary: true, action: () => closeModal() }]);
    }

    function openFeedbackModal() {
      const comments = run && run.feedback ? run.feedback.comments : '';
      const bugs = run && run.feedback ? run.feedback.bugs : '';
      const body = `
        <p class="modal-text">Share any feedback or bugs you noticed during the run.</p>
        <div style="display:flex; flex-direction:column; gap:12px;">
          <div>
            <div style="font-weight:800; margin-bottom:6px;">Comments</div>
            <textarea id="feedback_comments" rows="4" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">${comments}</textarea>
          </div>
          <div>
            <div style="font-weight:800; margin-bottom:6px;">Bugs</div>
            <textarea id="feedback_bugs" rows="4" style="width:100%; padding:10px; border-radius:10px; border:1px solid var(--border-color); background:var(--bg-secondary); color:var(--text-primary);">${bugs}</textarea>
          </div>
        </div>
      `;
      showModal('Feedback', body, [
        {
          text: 'Save',
          primary: true,
          action: () => {
            const commentsEl = document.getElementById('feedback_comments');
            const bugsEl = document.getElementById('feedback_bugs');
            const next = {
              comments: commentsEl ? commentsEl.value : '',
              bugs: bugsEl ? bugsEl.value : '',
              updatedAt: new Date().toISOString()
            };
            if (run) run.feedback = next;
            if (gameLog) gameLog.feedback = { ...next };
            logEvent('FEEDBACK_UPDATED', { commentsLen: next.comments.length, bugsLen: next.bugs.length });
            closeModal();
            showToast('Feedback saved');
          }
        },
        { text: 'Close', action: () => closeModal() }
      ]);

    }

    function openDeckViewer() {
      if (!run) return;
      const summary = buildDeckSummary();
      const stampLines = summary.stampedCount ? `${summary.stampedCount} stamped card(s)` : 'None';

      const bySuitLine = Object.entries(summary.bySuit)
        .map(([suit, count]) => `${suit} ${count}`)
        .join(' Â· ');

      const byRankLine = RANKS.map(rank => `${rank}:${summary.byRank[rank] || 0}`).join(' ');

      const standards = [];
      const modifiers = [];
      const fused = [];
      run.playerDeck.forEach(card => {
        if (isModifier(card)) modifiers.push(card);
        else if (isFused(card)) fused.push(card);
        else standards.push(card);
      });
      const rankIndex = Object.fromEntries(RANKS.map((r, i) => [r, i]));
      standards.sort((a, b) => {
        const suitIndexA = a.suit === KEY_SUIT ? 99 : SUITS.indexOf(a.suit);
        const suitIndexB = b.suit === KEY_SUIT ? 99 : SUITS.indexOf(b.suit);
        const suitDiff = suitIndexA - suitIndexB;
        if (suitDiff !== 0) return suitDiff;
        return (rankIndex[a.rank] || 0) - (rankIndex[b.rank] || 0);
      });

      const list = [...standards, ...fused, ...modifiers];
      const listHtml = list.map(card => renderCard(card, false)).join('');

      const body = `
        <div class="log-kv" style="margin-bottom:10px;">
          <div><strong>Deck size:</strong> ${summary.deckSize}</div>
          <div><strong>Standard:</strong> ${summary.deckSize - summary.modCount - summary.fusedCount} Â· <strong>Mods:</strong> ${summary.modCount} Â· <strong>Fused:</strong> ${summary.fusedCount}</div>
          <div><strong>Sleeved:</strong> ${summary.sleevedCount}</div>
          <div><strong>Stamps:</strong> ${stampLines}</div>
        </div>
        <div style="margin-bottom:10px;"><strong>By suit:</strong> ${bySuitLine}</div>
        <div style="margin-bottom:10px;"><strong>By rank:</strong> ${byRankLine}</div>
        <div class="merchant-cards">${listHtml}</div>
      `;

      showModal('Deck Viewer', body, [
        { text: 'Close', primary: true, action: () => closeModal() }
      ]);
    }

    // =============================================
    // UI: MODALS, TOAST, CONFIRM
    // =============================================
    let __modalButtons = [];
    let __modalTitle = '';
    let __modalOnClose = null;

    (function initModalDelegation(){
      const modal = document.getElementById('modal');
      if (!modal) return;

      modal.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-modal-idx]');
        if (!btn) return;

        const i = Number(btn.getAttribute('data-modal-idx'));
        const b = __modalButtons[i];
        if (!b || b.disabled) return;

        if (typeof b.action === 'function') b.action();
      });
    })();

    function renderHelpBlock(helpKey) {
      if (uiSettings.helpEnabled === false) return '';
      const h = HELP_MODALS[helpKey];
      if (!h || !h.lines || !h.lines.length) return '';

      const openAttr = (uiSettings.helpDefaultOpen !== false) ? 'open' : '';
      const items = h.lines.map(line => `<li>${line}</li>`).join('');

      return `
        <details class="help-block" ${openAttr}>
          <summary>How this works</summary>
          <ul>${items}</ul>
        </details>
      `;
    }

    function showModal(title, bodyHtml, buttons = [], opts = {}) {

      __modalButtons = buttons.map(b => ({ ...b }));
      __modalTitle = title || '';
      __modalOnClose = (opts && typeof opts.onClose === 'function') ? opts.onClose : null;

      const overlay = document.getElementById('modalOverlay');
      const modal = document.getElementById('modal');
      const helpKey = opts.helpKey || title;
      const helpHtml = renderHelpBlock(helpKey);

      const footer = buttons.length ? `
        <div class="modal-footer">
          ${buttons.map((b, i) => {
            const cls = [
              'modal-btn',
              b.primary ? 'primary' : '',
              b.danger ? 'danger' : ''
            ].filter(Boolean).join(' ');
            const dis = b.disabled ? 'disabled' : '';
            return `<button class="${cls}" ${dis} data-modal-idx="${i}">${b.text}</button>`;
          }).join('')}
        </div>
      ` : '';

      modal.innerHTML = `
        <div class="modal-header">${title}</div>
        <div class="modal-body">${helpHtml + bodyHtml}</div>
        ${footer}
      `;
      overlay.classList.remove('hidden');
      try { if (window.SFX) { SFX.unlock(); SFX.play('modal_open'); } } catch(e){}
    }

    function closeModal() {
      // Call modal-specific onClose hook (if any)
      if (typeof __modalOnClose === 'function') {
        try { __modalOnClose(); } catch (e) { console.warn('modal onClose error', e); }
      }

      __modalOnClose = null;
      __modalTitle = '';
      try { if (window.SFX) SFX.play('modal_close'); } catch(e){}
      document.getElementById('modalOverlay').classList.add('hidden');
      document.getElementById('modal').innerHTML = '';
      __modalButtons = [];
    }

    let toastTimer = null;
    let procBannerTimer = null;

    function showProcBanner(data = {}) {
      if (!blackjackMatch) return;

      blackjackMatch.procBanner = {
        suit: data.suit || '',
        title: data.title || 'Calling Proc',
        desc: data.desc || ''
      };
      try { if (window.SFX) SFX.play('proc'); } catch(e){}

      renderBlackjack();

      if (procBannerTimer) clearTimeout(procBannerTimer);
      procBannerTimer = setTimeout(() => {
        if (blackjackMatch) blackjackMatch.procBanner = null;
        renderBlackjack();
        procBannerTimer = null;
      }, 1500);
    }

    function showToast(text, ms = 1600) {
      try { if (window.SFX) SFX.play('toast'); } catch(e){}
      const el = document.getElementById('toast');
      el.textContent = text;
      el.classList.remove('hidden');
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => {
        el.classList.add('hidden');
      }, ms);
    }

    function showConfirmDialog(message, onConfirm) {
      const dialog = document.createElement('div');
      dialog.className = 'confirm-dialog';
      dialog.innerHTML = `
        <div class="confirm-content">
          <div class="confirm-message">${message}</div>
          <div class="confirm-btns">
            <button class="modal-btn danger" id="confirmYes">Yes</button>
            <button class="modal-btn" id="confirmNo">No</button>
          </div>
        </div>
      `;
      document.body.appendChild(dialog);

      dialog.querySelector('#confirmYes').onclick = () => {
        dialog.remove();
        if (onConfirm) onConfirm();
      };
      dialog.querySelector('#confirmNo').onclick = () => dialog.remove();
    }

    // ESC closes modal or log panel
    window.addEventListener('keydown', (e) => {
      if (e.key !== 'Escape') return;
      const overlay = document.getElementById('modalOverlay');
      if (overlay && !overlay.classList.contains('hidden')) closeModal();
      else if (logPanelOpen) closeLogPanel();
    });

    // =============================================
    // UTILITY FUNCTIONS
    // =============================================
    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function makeStandardDeck52() {
      const deck = [];
      for (const s of SUITS) {
        for (const r of RANKS) deck.push({ uid: null, rank: r, suit: s, stampId: null, sleeveId: null, laminationId: null });
      }
      return deck;
    }

    function isModifier(c) {
      return c && c.type === 'MOD';
    }

    function isFused(c) {
      return c && c.type === 'FUSE';
    }

    function isKeyCard(c) {
      return c && c.type === 'KEY';
    }

    function makeKeyCard(source) {
      const rank = randomChoice(RANKS);
      return { uid: null, type: 'KEY', suit: KEY_SUIT, rank, keySource: source, sleeveId: null, laminationId: null };
    }

    function isStandardCard(c) {
      return c && !c.type && c.rank && c.suit;
    }

    const STAMP_DEFS = {
      PLUS_FIVE: { id: 'PLUS_FIVE', name: '+5', rarity: 'common', desc: 'If this card is in a winning lane, gain +5 karma.', icon: '+5' },
      PLUS_TEN: { id: 'PLUS_TEN', name: '+10', rarity: 'common', desc: 'If this card is in a winning lane, gain +10 karma.', icon: '+10' },
      DOUBLE: { id: 'DOUBLE', name: 'Double', rarity: 'uncommon', desc: "If this card is in a winning lane, multiply that lane's karma by Ã—2.", icon: 'x2' },
      TRIPLE_PLAY: { id: 'TRIPLE_PLAY', name: 'Triple Play', rarity: 'uncommon', desc: "If this card is in a winning lane, multiply that lane's karma by Ã—3.", icon: 'x3' },
      CROWD_CONTROL: { id: 'CROWD_CONTROL', name: 'Crowd Control', rarity: 'rare', desc: 'If this card is in a winning lane, multiply lane karma by lane size.', icon: 'CC' },
      PROXY_SUIT: { id: 'PROXY_SUIT', name: 'Proxy Suit', rarity: 'common', desc: 'When played, counts as the Calling suit for proc checks.', icon: 'PS' },
      BURN_AFTER_READING: { id: 'BURN_AFTER_READING', name: 'Burn After Reading', rarity: 'uncommon', desc: "If this card was played this match, remove it from your deck.", icon: 'BR' },
      CHICKEN_DINNER: { id: 'CHICKEN_DINNER', name: 'Chicken Dinner', rarity: 'rare', desc: 'If this card is in a winning lane, gain +21 karma.', icon: '21' },
      HOUSE_EDGE: { id: 'HOUSE_EDGE', name: 'House Edge', rarity: 'rare', desc: 'If lane total is exactly 21 and wins, gain +10 karma per card in lane.', icon: 'HE' },
      VENTURE_FUND: { id: 'VENTURE_FUND', name: 'Venture Fund', rarity: 'rare', desc: 'If this card is in a winning lane, gain chips equal to lane karma.', icon: 'VF', cost: 75 }
    };

    const SLEEVE_DEFS = {
      BLUE: { id: 'BLUE', name: 'Blue', rarity: 'common', desc: 'If drawn, card goes to bench instead of forced draw-play.', icon: 'B' },
      GOLD: { id: 'GOLD', name: 'Gold', rarity: 'common', desc: 'If lane wins, gain chips equal to lane total per Gold card in lane.', icon: 'G' },
      STEEL: { id: 'STEEL', name: 'Steel', rarity: 'uncommon', desc: 'Lane cannot be targeted by opponent modifier effects while present.', icon: 'S' },
      FUSION: { id: 'FUSION', name: 'Fusion', rarity: 'rare', desc: 'When played, arms fusion. Next standard card atop it fuses.', icon: 'âœ¦' },
      ERASER: { id: 'ERASER', name: 'Eraser', rarity: 'uncommon', desc: 'Negate the first modifier applied to this lane after this card is present.', icon: 'E' },
      FOIL: { id: 'FOIL', name: 'Foil', rarity: 'rare', desc: 'Doubles the effect of the stamp on this same card.', icon: 'F' },
      NEGATIVE: { id: 'NEGATIVE', name: 'Negative', rarity: 'uncommon', desc: "This card's value is subtracted from lane total instead of added.", icon: 'N' }
    };

    function getStampDef(id) {
      return id ? STAMP_DEFS[id] : null;
    }

    function getSleeveDef(id) {
      return id ? SLEEVE_DEFS[id] : null;
    }

    function getCardStampId(card) {
      if (!card) return null;
      if (isFused(card) && card.a && card.a.sleeveId === 'FUSION') return card.a.stampId || null;
      if (!isStandardCard(card)) return null;
      return card.stampId || null;
    }

    function assignUid(card) {
      if (!card) return null;
      if (card.uid) return card.uid;
      if (!run) return null;
      run.nextCardUid = safeNumber(run.nextCardUid, 1);
      card.uid = run.nextCardUid;
      run.nextCardUid += 1;
      return card.uid;
    }

    function cloneCardWithNewUid(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: null, type: 'MOD', delta: card.delta };
      if (isKeyCard(card)) return { ...card, uid: null };
      if (isFused(card)) return { uid: null, type: 'FUSE', a: card.a, b: card.b, sleeveId: card.sleeveId || null };
      return {
        uid: null,
        rank: card.rank,
        suit: card.suit,
        stampId: card.stampId || null,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }

    function cardRef(card) {
      if (!card) return null;
      if (isModifier(card)) return { uid: card.uid || null, kind: 'MOD', delta: card.delta };
      if (isKeyCard(card)) return { uid: card.uid || null, kind: 'KEY', rank: card.rank, suit: card.suit, keySource: card.keySource || null };
      if (isFused(card)) return { uid: card.uid || null, kind: 'FUSE', aUid: card.a?.uid || null, bUid: card.b?.uid || null };
      return {
        uid: card.uid || null,
        kind: 'STD',
        rank: card.rank,
        suit: card.suit,
        stampId: card.stampId || null,
        sleeveId: card.sleeveId || null,
        laminationId: card.laminationId ?? null
      };
    }


    function collectLaneCardsForEffects(cards) {
      const out = [];
      for (const c of cards || []) {
        if (!c || isModifier(c) || isKeyCard(c)) continue;
        out.push(c); // fused counts as ONE card entity for effect scanning
      }
      return out;
    }

    function cardHasSleeve(card, sleeveId) {
      if (!card) return false;
      if (isFused(card)) {
        return card.sleeveId === sleeveId
          || card.a?.sleeveId === sleeveId
          || card.b?.sleeveId === sleeveId;
      }
      return card.sleeveId === sleeveId;
    }

    function laneHasSleeve(pos, sleeveId) {
      const cards = collectLaneCardsForEffects(pos?.cards || []);
      return cards.some(c => cardHasSleeve(c, sleeveId));
    }

    function getStampKarmaContribution(stampId, baseValue, laneSize) {
      switch (stampId) {
        case 'PLUS_FIVE':
          return 5;
        case 'PLUS_TEN':
          return 10;
        case 'DOUBLE':
          return baseValue;
        case 'TRIPLE_PLAY':
          return baseValue * 2;
        case 'CROWD_CONTROL':
          return Math.max(0, baseValue * (Math.max(1, laneSize) - 1));
        case 'CHICKEN_DINNER':
          return 21;
        case 'HOUSE_EDGE':
        case 'VENTURE_FUND':
          return 0;
        default:
          return 0;
      }
    }

    function cardToString(c) {
      if (!c) return '';
      if (isModifier(c)) return c.delta > 0 ? `+${c.delta}` : `${c.delta}`;
      if (isFused(c)) return `${cardToString(c.a)}/${cardToString(c.b)}`;
      return `${c.rank}${c.suit}`;
    }

    function isRedSuit(suit) {
      return suit === 'â™¥' || suit === 'â™¦';
    }

    function cardCssClass(card) {
      if (isModifier(card)) return 'mod';
      if (isFused(card)) return 'fused';
      if (isKeyCard(card)) return 'black';
      const classes = [isRedSuit(card.suit) ? 'red' : 'black'];
      return classes.join(' ');
    }

    function rankToValue(rank) {
      if (rank === 'A') return 14;
      if (rank === 'K') return 13;
      if (rank === 'Q') return 12;
      if (rank === 'J') return 11;
      const n = Number(rank);
      return Number.isFinite(n) ? n : 0;
    }

    function valueToRank(value) {
      if (value === 14) return 'A';
      if (value === 13) return 'K';
      if (value === 12) return 'Q';
      if (value === 11) return 'J';
      return String(value);
    }

    function suitColor(suit) {
      return (suit === 'â™¥' || suit === 'â™¦') ? 'red' : 'black';
    }

    function getAffinity(playerSuit, npcSuit) {
      if (!playerSuit || !npcSuit) return 'neutral';
      if (playerSuit === npcSuit) return 'resonant';
      if (suitColor(playerSuit) === suitColor(npcSuit)) return 'dissonant';
      return 'neutral';
    }

    function affinityIcon(affinity) {
      if (affinity === 'resonant') return '+';
      if (affinity === 'dissonant') return '-';
      return 'â€¢';
    }

    function getCallingRankInfo() {
      if (!run || !run.callingCard) return null;
      const rank = run.callingCard.rank || '2';
      const idx = CALLING_RANK_THRESHOLDS.findIndex(t => t.rank === rank);
      const safeIdx = idx >= 0 ? idx : 0;
      const current = CALLING_RANK_THRESHOLDS[safeIdx];
      const next = CALLING_RANK_THRESHOLDS[safeIdx + 1] || null;
      const karma = safeNumber(run.karma, 0);
      const prevKarma = current ? current.karma : 0;
      const nextKarma = next ? next.karma : prevKarma;
      const span = Math.max(1, nextKarma - prevKarma);
      const progress = next ? Math.max(0, Math.min(1, (karma - prevKarma) / span)) : 1;
      return {
        rank,
        current,
        next,
        isMax: !next,
        progress,
        toNext: next ? Math.max(0, next.karma - karma) : 0
      };
    }

    function maybeLevelUpCallingCardFromKarma() {
      if (!run || !run.callingCard) return null;
      const fromRank = run.callingCard.rank || '2';
      let idx = CALLING_RANK_THRESHOLDS.findIndex(t => t.rank === fromRank);
      if (idx < 0) idx = 0;
      let gained = 0;
      while (idx + 1 < CALLING_RANK_THRESHOLDS.length && safeNumber(run.karma, 0) >= CALLING_RANK_THRESHOLDS[idx + 1].karma) {
        idx += 1;
        gained += 1;
      }
      if (gained <= 0) return null;
      const toRank = CALLING_RANK_THRESHOLDS[idx].rank;
      run.callingCard.rank = toRank;
      run.ui.callingRankPulseUntil = Date.now() + 1500;
      logEvent('CALLING_CARD_LEVEL_UP', {
        fromRank,
        toRank,
        levelsGained: gained,
        karmaAtLevelUp: run.karma
      });
      showToast(`Calling Card leveled up: ${fromRank} â†’ ${toRank}`);
      renderHUD();
      return { fromRank, toRank, levelsGained: gained };
    }

    function getCardValueOptions(card) {
      if (!card || isModifier(card)) return [];

      if (isFused(card)) {
        const a = getCardValueOptions(card.a);
        const b = getCardValueOptions(card.b);
        return Array.from(new Set([...(a || []), ...(b || [])])).sort((x, y) => x - y);
      }

      if (card.__negValue !== undefined) return [safeNumber(card.__negValue, 0)];
      if (card.rank === 'A') return [1, 11];
      if (['J', 'Q', 'K'].includes(card.rank)) return [10];
      const n = Number(card.rank);
      return Number.isFinite(n) ? [n] : [];
    }

    // Harden total calc to never produce NaN (supports fused + aces)
    function calcBestTotal(cards, modSum = 0) {
      let totals = [0];
      for (const c of cards || []) {
        const options = getCardValueOptions(c);
        if (!options.length) continue;
        const nextTotals = [];
        for (const t of totals) {
          for (const v of options) nextTotals.push(t + v);
        }
        totals = nextTotals;
      }
      totals = totals.map(t => t + modSum);
      const under = totals.filter(t => t <= 21);
      if (under.length) return Math.max(...under);
      return totals.length ? Math.min(...totals) : 0;
    }

    function hexPath(x, y) {
      const pts = [];
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 180) * (60 * i);
        pts.push([x + HEX_SIZE * Math.cos(angle), y + HEX_SIZE * Math.sin(angle)]);
      }
      return `M ${pts.map(p => p.join(',')).join(' L ')} Z`;
    }

    function removeOne(arr, item) {
      const idx = arr.indexOf(item);
      if (idx !== -1) arr.splice(idx, 1);
    }

    function clampAddBankedToken(n = 1) {
      run.bankedTokens = Math.min(ACTION_TOKEN_MAX_BANKED, (run.bankedTokens || 0) + n);
    }

    function distinctRandomIndices(n, length) {
      const idxs = Array.from({ length }, (_, i) => i);
      const s = shuffle(idxs);
      return s.slice(0, Math.min(n, s.length));
    }

    // Merchant random offer: standard card OR modifier (intermixed)
    function cloneDeck(deck) {
      return (deck || []).map(card => {
        const c = cloneCardWithNewUid(card);
        assignUid(c);
        return c;
      });
    }


    function cloneCard(card) {
      if (!card) return card;
      if (isFused(card)) {
        return {
          ...card,
          a: cloneCard(card.a),
          b: cloneCard(card.b)
        };
      }
      return { ...card };
    }

    function randomCard() {
      if (Math.random() < MOD_OFFER_CHANCE) {
        const delta = MODIFIER_DELTAS[Math.floor(Math.random() * MODIFIER_DELTAS.length)];
        return { uid: null, type: 'MOD', delta };
      }
      return {
        uid: null,
        rank: RANKS[Math.floor(Math.random() * RANKS.length)],
        suit: SUITS[Math.floor(Math.random() * SUITS.length)],
        sleeveId: null,
        laminationId: null
      };
    }

    function safeNumber(x, fallback = 0) {
      const n = Number(x);
      return Number.isFinite(n) ? n : fallback;
    }

    function installGlobalClickSfx() {
      document.addEventListener('pointerdown', (e) => {
        try {
          if (!window.SFX) return;
          if ((uiSettings && uiSettings.sfxEnabled) === false) return;
          if (typeof e.button === 'number' && e.button !== 0) return;
          const t = e.target;
          if (!t || !t.closest) return;
          if (t.closest('input, textarea, select')) return;
          const clickable = t.closest('button, [role="button"], a[href], [onclick], .bj-btn, .modal-btn');
          if (!clickable || clickable.disabled) return;
          if (clickable.getAttribute('data-sfx-skip') === '1') return;
          const key = clickable.getAttribute('data-sfx');
          SFX.unlock();
          SFX.play(key || 'ui_click');
        } catch (err) {}
      }, true);
    }

    window.SFX = (function(){
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return { unlock(){}, play(){}, setEnabled(){}, setVolume(){}, isUnlocked(){ return false; } };
      let ctx = null;
      let master = null;
      let unlocked = false;
      const lastAt = new Map();
      const gate = (k, ms) => {
        const now = performance.now();
        const prev = lastAt.get(k) || 0;
        if (now - prev < ms) return false;
        lastAt.set(k, now);
        return true;
      };
      const rnd = (a,b)=>a+Math.random()*(b-a);
      const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
      function enabled(){ return (uiSettings && uiSettings.sfxEnabled) !== false; }
      function volume(){ const v=(uiSettings ? safeNumber(uiSettings.sfxVolume, 0.70) : 0.70); return clamp(v,0,1); }
      function ensure(){ if (ctx) return; ctx = new AC({ latencyHint:'interactive' }); master = ctx.createGain(); master.gain.value = volume() * 2.0; master.connect(ctx.destination); }
      async function unlock(){ if (unlocked) return; ensure(); try { await ctx.resume(); const o=ctx.createOscillator(); const g=ctx.createGain(); g.gain.value=0.00001; o.frequency.value=220; o.connect(g); g.connect(master); o.start(); o.stop(ctx.currentTime+0.01); unlocked=true; } catch(e){} }
      function setEnabled(v){ if (uiSettings) uiSettings.sfxEnabled = !!v; }
      function setVolume(v){ if (uiSettings) uiSettings.sfxVolume = clamp(parseFloat(v)||0, 0, 1); ensure(); master.gain.value = volume() * 2.0; }
      function envGain(t0, a, d, s, r){ const g=ctx.createGain(); g.gain.setValueAtTime(0.0001, t0); g.gain.exponentialRampToValueAtTime(a, t0 + 0.001); g.gain.exponentialRampToValueAtTime(Math.max(0.0001, s), t0 + d); g.gain.exponentialRampToValueAtTime(0.0001, t0 + d + r); return g; }
      function hp(node, f){ const bi=ctx.createBiquadFilter(); bi.type='highpass'; bi.frequency.value=f; node.connect(bi); return bi; }
      function lp(node, f){ const bi=ctx.createBiquadFilter(); bi.type='lowpass'; bi.frequency.value=f; node.connect(bi); return bi; }
      function noiseBuf(){ const len=Math.floor(ctx.sampleRate*0.25); const b=ctx.createBuffer(1,len,ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*(1-i/len); return b; }
      const _noise = { buf: null };
      function noise(){ if (!_noise.buf) _noise.buf = noiseBuf(); const s=ctx.createBufferSource(); s.buffer=_noise.buf; return s; }
      function s_click(vol=1){ if(!gate('ui_click',40)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nG=envGain(t,0.28*vol,0.018,0.0004,0.03); const nHP=hp(n,650); const nLP=lp(nHP,5200); nLP.connect(nG); nG.connect(master); const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(340,t); o.frequency.exponentialRampToValueAtTime(180,t+0.03); const oG=envGain(t,0.10*vol,0.015,0.0005,0.04); o.connect(oG); oG.connect(master); n.start(t); n.stop(t+0.08); o.start(t); o.stop(t+0.08); }
      function s_toast(vol=1){ if(!gate('toast',80)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(1040,t); o.frequency.exponentialRampToValueAtTime(1320,t+0.08); const g=envGain(t,0.10*vol,0.05,0.0005,0.07); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.14); }
      function s_modalOpen(vol=1){ if(!gate('modal_open',80)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,180); const nLP=lp(nHP,1800); const g=envGain(t,0.18*vol,0.05,0.0005,0.12); nLP.connect(g); g.connect(master); n.start(t); n.stop(t+0.18); }
      function s_modalClose(vol=1){ if(!gate('modal_close',80)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,420); const nLP=lp(nHP,2600); const g=envGain(t,0.16*vol,0.03,0.0005,0.10); nLP.connect(g); g.connect(master); n.start(t); n.stop(t+0.14); }
      function s_paper(vol=1){ if(!gate('paper',28)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,900); const nLP=lp(nHP,5400); const g=envGain(t,0.22*vol,0.02,0.0005,0.05); nLP.connect(g); g.connect(master); n.start(t); n.stop(t+0.10); }
      function s_paperHeavy(vol=1){ if(!gate('paperHeavy',32)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,700); const nLP=lp(nHP,4600); const g=envGain(t,0.26*vol,0.03,0.0005,0.07); nLP.connect(g); g.connect(master); n.start(t); n.stop(t+0.13); }
      function s_chipTap(vol=1){ if(!gate('chipTap',50)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(620,t); o.frequency.exponentialRampToValueAtTime(420,t+0.05); const g=envGain(t,0.12*vol,0.02,0.0005,0.06); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.10); }
      function s_bust(vol=1){ if(!gate('bust',120)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,120); const nLP=lp(nHP,700); const g=envGain(t,0.22*vol,0.05,0.0005,0.15); nLP.connect(g); g.connect(master); const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(170,t); o.frequency.exponentialRampToValueAtTime(90,t+0.18); const og=envGain(t,0.10*vol,0.04,0.0005,0.18); o.connect(og); og.connect(master); n.start(t); n.stop(t+0.24); o.start(t); o.stop(t+0.24); }
      function s_chipDrop(vol=1){ if(!gate('chipDrop',35)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o1=ctx.createOscillator(); o1.type='triangle'; o1.frequency.setValueAtTime(860,t); o1.frequency.exponentialRampToValueAtTime(520,t+0.06); const g1=envGain(t,0.14*vol,0.02,0.0005,0.07); o1.connect(g1); g1.connect(master); const o2=ctx.createOscillator(); o2.type='sine'; o2.frequency.setValueAtTime(1240,t+0.02); o2.frequency.exponentialRampToValueAtTime(760,t+0.08); const g2=envGain(t+0.02,0.10*vol,0.02,0.0005,0.08); o2.connect(g2); g2.connect(master); o1.start(t); o1.stop(t+0.11); o2.start(t+0.02); o2.stop(t+0.13); }
      function s_rakeClick(vol=1){ if(!gate('rake',45)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,900); const nLP=lp(nHP,2600); const g=envGain(t,0.16*vol,0.015,0.0005,0.05); nLP.connect(g); g.connect(master); n.start(t); n.stop(t+0.08); }
      function s_earnTick(vol=1){ if(!gate('earnTick',60)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(980,t); const g=envGain(t,0.06*vol,0.02,0.0005,0.05); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.08); }
      function s_chipClinks(vol=1){ if(!gate('chipDone',160)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; for(let i=0;i<3;i++){ const tt=t+i*0.06; const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(rnd(900,1400),tt); const g=envGain(tt,0.10*vol,0.02,0.0005,0.06); o.connect(g); g.connect(master); o.start(tt); o.stop(tt+0.08); } }
      function s_karmaTick(vol=1){ if(!gate('karmaTick',60)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(1180,t); o.frequency.exponentialRampToValueAtTime(1480,t+0.06); const g=envGain(t,0.06*vol,0.02,0.0005,0.06); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.10); }
      function s_rankUp(vol=1){ if(!gate('rankUp',200)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(520,t); o.frequency.exponentialRampToValueAtTime(1040,t+0.18); const g=envGain(t,0.14*vol,0.06,0.0005,0.20); o.connect(g); g.connect(master); const n=noise(); const nHP=hp(n,1400); const nLP=lp(nHP,6000); const ng=envGain(t,0.10*vol,0.05,0.0005,0.22); nLP.connect(ng); ng.connect(master); o.start(t); o.stop(t+0.28); n.start(t); n.stop(t+0.28); }
      function s_benchArm(vol=1){ if(!gate('benchArm',50)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(240,t); o.frequency.exponentialRampToValueAtTime(320,t+0.05); const g=envGain(t,0.08*vol,0.02,0.0005,0.08); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.12); }
      function s_modPlus(vol=1){ if(!gate('modPlus',60)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(820,t); o.frequency.exponentialRampToValueAtTime(1320,t+0.10); const g=envGain(t,0.10*vol,0.04,0.0005,0.12); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.18); }
      function s_modMinus(vol=1){ if(!gate('modMinus',60)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(520,t); o.frequency.exponentialRampToValueAtTime(260,t+0.12); const g=envGain(t,0.10*vol,0.04,0.0005,0.14); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.20); }
      function s_block(vol=1){ if(!gate('block',70)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const n=noise(); const nHP=hp(n,500); const nLP=lp(nHP,1300); const g=envGain(t,0.12*vol,0.02,0.0005,0.08); nLP.connect(g); g.connect(master); n.start(t); n.stop(t+0.12); }
      function s_proc(vol=1){ if(!gate('proc',150)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(660,t); o.frequency.exponentialRampToValueAtTime(990,t+0.10); const g=envGain(t,0.12*vol,0.04,0.0005,0.12); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.18); }
      function s_bossCleared(vol=1){ if(!gate('bossCleared',250)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(392,t); o.frequency.exponentialRampToValueAtTime(784,t+0.18); const g=envGain(t,0.18*vol,0.06,0.0005,0.22); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.30); }
      function s_watcherIntro(vol=1){ if(!gate('watcherIntro',250)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(110,t); o.frequency.exponentialRampToValueAtTime(220,t+0.25); const g=envGain(t,0.18*vol,0.10,0.0005,0.35); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.45); }
      function s_victory(vol=1){ if(!gate('victory',300)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(440,t); o.frequency.exponentialRampToValueAtTime(880,t+0.18); const g=envGain(t,0.18*vol,0.06,0.0005,0.24); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.32); }
      function s_gameover(vol=1){ if(!gate('gameover',300)) return; ensure(); if(!enabled()) return; const t=ctx.currentTime; const o=ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(220,t); o.frequency.exponentialRampToValueAtTime(110,t+0.22); const g=envGain(t,0.16*vol,0.06,0.0005,0.26); o.connect(g); g.connect(master); o.start(t); o.stop(t+0.34); }
      function play(name, opt={}){ if (!enabled()) return; ensure(); if (!unlocked) unlock(); const vol = clamp(safeNumber(opt.volMul,1)*volume(),0,1); switch(name){
        case 'ui_click': return s_click(vol); case 'toast': return s_toast(vol); case 'modal_open': return s_modalOpen(vol); case 'modal_close': return s_modalClose(vol);
        case 'card_draw': return s_paper(vol); case 'card_place': return s_paperHeavy(vol); case 'dealer_place': return s_paper(vol*0.6);
        case 'bench_add': return s_chipDrop(vol); case 'bench_overflow': return s_rakeClick(vol); case 'bench_arm': return s_benchArm(vol); case 'lane_close': return s_chipTap(vol); case 'bust': return s_bust(vol);
        case 'chip_tick': return s_earnTick(vol); case 'chip_done': return s_chipClinks(vol); case 'karma_tick': return s_karmaTick(vol); case 'karma_done': return s_rankUp(vol);
        case 'mod': return safeNumber(opt.delta,0) >= 0 ? s_modPlus(vol) : s_modMinus(vol); case 'mod_block': return s_block(vol);
        case 'boss_cleared': return s_bossCleared(vol); case 'watcher_intro': return s_watcherIntro(vol); case 'victory': return s_victory(vol); case 'gameover': return s_gameover(vol); case 'proc': return s_proc(vol);
        default: return;
      }}
      return { unlock, play, setEnabled, setVolume, isUnlocked: () => unlocked && ctx?.state === 'running' };
    })();

    function escapeHtml(value) {
      return String(value ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

function ensureShopPurchaseCounts() {
  if (!run) return;
  if (!run.shopPurchaseCounts || typeof run.shopPurchaseCounts !== 'object') {
    run.shopPurchaseCounts = {};
  }
}

function getShopPurchasesUsed(shopId) {
  if (!run || !shopId) return 0;
  ensureShopPurchaseCounts();
  return safeNumber(run.shopPurchaseCounts[shopId], 0);
}

function getShopPurchasesRemaining(shopId) {
  return Math.max(0, SHOP_PURCHASE_CAP - getShopPurchasesUsed(shopId));
}

function canShopPurchase(shopId) {
  return getShopPurchasesRemaining(shopId) > 0;
}

function recordShopPurchase(shopId, meta = {}) {
  ensureShopPurchaseCounts();
  const before = getShopPurchasesUsed(shopId);
  run.shopPurchaseCounts[shopId] = before + 1;

  logEvent('SHOP_PURCHASE', {
    shopId,
    cap: SHOP_PURCHASE_CAP,
    before,
    after: before + 1,
    ...meta
  });
}

function renderShopPurchaseCounter(shopId) {
  const remaining = getShopPurchasesRemaining(shopId);
  return `
    <div class="shop-purchase-counter">
      Purchases Left: <b>${remaining}</b> / ${SHOP_PURCHASE_CAP}
    </div>
  `;
}


// =============================================
// ECONOMY / LIMIT HELPERS
// =============================================
function getHouseRakeRate(floor) {
  const mode = (uiSettings && uiSettings.rakeMode) || 'hard';

  if (mode === 'easy') return 0;
  if (mode === 'medium') return 0.10;

  // hard = 10/20/30 by floor (default behavior)
  const hardRates = { 1: 0.10, 2: 0.20, 3: 0.30 };
  const r = hardRates[String(floor)] ?? hardRates[floor] ?? 0;
  return Math.max(0, Math.min(0.95, safeNumber(r, 0)));
}

function getOpponentDifficulty() {
  const d = (uiSettings && (uiSettings.opponentDifficulty || uiSettings.difficulty)) || 'hard';
  return (d === 'easy' || d === 'medium' || d === 'hard') ? d : 'hard';
}

function getMerchantPriceMult() {
  const ctx = run && run.ui && run.ui.merchantContext;
  const mult = ctx && typeof ctx.priceMult === 'number' ? ctx.priceMult : 1;
  return Math.max(0.75, Math.min(1.25, mult));
}

function getMerchantRemovalCost() {
  const n = safeNumber(run && run.paidRemovalCount, 0);
  const base = MERCHANT_REMOVE_COST + (n * MERCHANT_REMOVE_INCREMENT);
  return Math.ceil(base * getMerchantPriceMult());
}

function getMerchantCost(base) {
  return Math.ceil(base * getMerchantPriceMult());
}

function getMerchantBuyCost(card) {
  if (isKeyCard(card)) return KEY_MERCHANT_COST;
  const mult = getMerchantPriceMult();

  if (isModifier(card)) {
    const n = safeNumber(run.merchantModifierBuys, 0);
    return Math.round((MERCHANT_BUY_BASE_MOD + MERCHANT_BUY_INCREMENT * n) * mult);
  }

  // Standard cards: NO scaling
  return Math.round(MERCHANT_BUY_BASE_STANDARD * mult);
}

function getModifyServiceCost(serviceId, floor) {
  const baseFloor = Math.max(1, safeNumber(floor, 1));
  const isPremium = serviceId === 'CALLING_SUIT_SWEEP' || serviceId === 'UNIFORM_RANK_PRESS';
  const base = isPremium ? 200 : 100;
  const step = isPremium ? 50 : 25;
  const scaled = base + ((baseFloor - 1) * step);
  return Math.ceil(scaled * getModifyPriceMult());
}

function getModKey(delta) { return String(delta); }

function getModifierPurchased(delta) {
  const key = getModKey(delta);
  return safeNumber(run && run.modPurchaseCounts && run.modPurchaseCounts[key], 0);
}

function getModifierRemaining(delta) {
  return Math.max(0, MOD_PURCHASE_LIMIT_PER_DELTA - getModifierPurchased(delta));
}

function recordModifierPurchase(delta) {
  const key = getModKey(delta);
  if (!run.modPurchaseCounts) run.modPurchaseCounts = {};
  run.modPurchaseCounts[key] = getModifierPurchased(delta) + 1;
}

function getBenchCapacity() {
  const wins = safeNumber(run && run.bossWins, 0);
  const uncapped = BENCH_BASE_CAPACITY + (wins * BENCH_CAPACITY_BONUS_PER_BOSS_WIN);

  const cap = safeNumber(uiSettings && uiSettings.benchHardCap, 0);
  if (cap > 0) return Math.max(1, Math.min(cap, uncapped));
  return uncapped;
}


// Push to bench with FIFO overflow (oldest discarded if full)
function benchPush(card, source = '') {
  if (!blackjackMatch) return;
  const cap = getBenchCapacity();
  blackjackMatch.bench = blackjackMatch.bench || [];
  let removed = null;

  if (blackjackMatch.bench.length >= cap) {
    removed = blackjackMatch.bench.shift();
    try { if (window.SFX) SFX.play('bench_overflow'); } catch(e){}

    // keep armed index stable
    if (blackjackMatch.armedBenchIdx !== null && blackjackMatch.armedBenchIdx !== undefined) {
      if (blackjackMatch.armedBenchIdx === 0) blackjackMatch.armedBenchIdx = null;
      else blackjackMatch.armedBenchIdx = Math.max(0, blackjackMatch.armedBenchIdx - 1);
    }

    logEvent('BENCH_OVERFLOW', { removed: cardToString(removed), added: cardToString(card), cap, source });
    showToast(`Bench full (${cap}). Discarded ${cardToString(removed)}.`);
  }

  blackjackMatch.bench.push(card);
  try { if (window.SFX) SFX.play('bench_add'); } catch(e){}
  return removed;
}


    // =============================================
    // BOARD GENERATION
    // =============================================
    const NPC_NAMES = ['Rowan', 'Maris', 'Calder', 'June', 'Sable', 'Nico', 'Arden', 'Vale', 'Tamsin', 'Quinn', 'Otto', 'Liora'];

    function randomChoice(list) {
      return list[Math.floor(Math.random() * list.length)];
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function rollNpcRankValue(floor, type) {
      const roll = Math.random();
      if (type === 'STANDARD') {
        if (floor === 1) {
          if (roll < 0.02) return randInt(12, 14);
          if (roll < 0.12) return randInt(9, 11);
          return randInt(2, 8);
        }
        if (floor === 2) {
          if (roll < 0.02) return 14;
          if (roll < 0.12) return randInt(11, 13);
          return randInt(4, 10);
        }
        if (roll < 0.10) return randInt(13, 14);
        return randInt(6, 12);
      }
      if (type === 'HIGH_STAKES') {
        if (floor === 1) {
          if (roll < 0.10) return randInt(12, 14);
          return randInt(6, 11);
        }
        if (floor === 2) {
          if (roll < 0.10) return 14;
          return randInt(8, 13);
        }
        return randInt(10, 14);
      }
      if (type === 'BOSS') {
        if (floor === 1) {
          if (roll < 0.20) return 14;
          return randInt(10, 13);
        }
        if (floor === 2) return randInt(12, 14);
        return 14;
      }
      return randInt(4, 12);
    }

    function makeNpcName(type) {
      const base = randomChoice(NPC_NAMES);
      if (type === 'HIGH_STAKES') return `High Roller ${base}`;
      if (type === 'BOSS') return `Floor Boss: ${base}`;
      return base;
    }

    function createNpcForTile(floor, type) {
      const tableTypes = ['STANDARD', 'HIGH_STAKES', 'BOSS'];
      const roleSuits = {
        BARTENDER: 'â™¥',
        MERCHANT: 'â™¦',
        LOAN_SHARK: 'â™£'
      };

      if (!tableTypes.includes(type) && !roleSuits[type]) return null;

      const suit = roleSuits[type] || randomChoice(['â™¥', 'â™ ', 'â™¦', 'â™£']);
      const rankValue = rollNpcRankValue(floor, type);
      const rank = valueToRank(rankValue);
      const name = makeNpcName(type);
      const npc = { name, callingCard: { rank, suit } };

      if (type === 'STANDARD' || type === 'HIGH_STAKES') {
        const pool = (type === 'HIGH_STAKES') ? AI_PROFILE_WEIGHTS.HIGH_STAKES : AI_PROFILE_WEIGHTS.STANDARD;
        npc.aiProfileId = pickWeighted(pool);
        npc.aiQuirkBias = Array.from({ length: LANE_COUNT }, () => (Math.random() * 2 - 1));
        npc.aiRaiseQuirk = (Math.random() * 2 - 1) * 0.06;
      }

      return npc;
    }

    function buildTilePoolForFloor(floor) {
      const pool = [];
      const counts = FLOOR_COUNTS[floor];

      let standardCount = counts.standard;
      let highCount = counts.high;
      if (standardCount > 0) standardCount -= 1;
      else if (highCount > 0) highCount -= 1;

      for (let i = 0; i < standardCount; i++) pool.push('STANDARD');
      for (let i = 0; i < highCount; i++) pool.push('HIGH_STAKES');
      pool.push('COLLECTOR');

      pool.push('BARTENDER');
      pool.push('MINIGAME');
      pool.push('REST_STOP', 'REST_STOP');
      pool.push('MERCHANT', 'MODIFY');
      pool.push('LOAN_SHARK');

      return pool;
    }

    function assignTilesToNodes(floor) {
      const pool = shuffle(buildTilePoolForFloor(floor));
      const tiles = new Array(21).fill(null);

      // Boss at 0
      tiles[0] = 'BOSS';

      // Starting row: one must be bartender
      const startIds = [18, 19, 20];
      const bartenderId = startIds[Math.floor(Math.random() * startIds.length)];
      tiles[bartenderId] = 'BARTENDER';
      removeOne(pool, 'BARTENDER');

      // Fill other two starts
      for (const id of startIds) {
        if (!tiles[id]) tiles[id] = pool.pop();
      }

      // Fill 1-17
      for (let id = 1; id <= 17; id++) tiles[id] = pool.pop();
      return tiles;
    }

    function generateBoard(floor) {
      const tileTypes = assignTilesToNodes(floor);
      const tiles = [];

      for (const [id, x, y, connections] of NODES) {
        const tileType = tileTypes[id];
        const npc = createNpcForTile(floor, tileType);
        tiles.push({
          id,
          type: tileType,
          label: TILE_LABELS[tileType],
          color: TILE_COLORS[tileType],
          center: [x, y],
          svgPath: hexPath(x, y),
          connections,
          isStartRow: id >= 18,
          npc
        });
      }

      return tiles;
    }

    // =============================================
    // RUN INITIALIZATION
    // =============================================
    function initRun() {
      clearDealerTimers();

      run = {
        floor: 1,
        chips: STARTING_CHIPS,
        karma: 0,
        karmaWinStreak: 0,
        callingCard: null,
        callingCardChosenSuit: null,
        playerName: loadPlayerName() || '',
        playerDeck: makeStandardDeck52(),
        collectorShop: null,
        ownedActions: [],
        nextCardUid: 1,
        matchSeq: 0,
        encounterSeq: 0,
        activeEncounter: null,
        feedback: { comments: '', bugs: '', updatedAt: null },
        bankedTokens: 0,
        bossWins: 0,
        bossFight: null,
        secret: {
          keys: {
            highStakes: { obtained: false, floor: 1, tileId: null, hinted: false },
            merchant: { state: 'unseen', floor: 2, chance: 0.05 },
            boss: { obtained: false, floor: 3 }
          }
        },
        paidRemovalCount: 0,
        merchantStandardBuys: 0,
        merchantModifierBuys: 0,
        modPurchaseCounts: Object.fromEntries(MODIFIER_DELTAS.map(d => [String(d), 0])),
        loan: { active: false, repaid: false },
        board: {
          tiles: [],
          currentTileId: null,
          visited: new Set(),
          path: []
        },
        ui: {
          mode: 'INTRO',
          message: '',
          callingRankPulseUntil: 0,
          karmaTallyFast: false,
          hudCollapsed: (window.innerWidth <= 520),
          boardLegendOpen: false
        },
        intro: {
          step: null,
          name: '',
          suit: null,
          callingCard: null
        }
      };

      resetLog();
      run.playerDeck.forEach(card => assignUid(card));
      run.intro.name = run.playerName || '';
      run.intro.step = run.playerName ? 'suit' : 'name';
      renderAll();
    }

    function initFloor(floor) {
      clearDealerTimers();

      run.floor = floor;
      run.bossFight = null;
      run.board.tiles = generateBoard(floor);
      run.board.currentTileId = null;
      run.board.visited = new Set();
      run.board.path = [];
      if (run.secret && run.secret.keys && run.secret.keys.highStakes) {
        const hsKey = run.secret.keys.highStakes;
        if (!hsKey.obtained) {
          const hsTiles = run.board.tiles.filter(t => t.type === 'HIGH_STAKES');
          hsKey.tileId = hsTiles.length ? hsTiles[Math.floor(Math.random() * hsTiles.length)].id : null;
          hsKey.floor = floor;
          hsKey.hinted = false;
        }
      }
      run.ui.mode = 'BOARD';

      beginFloorTracking(floor);
      logEvent('FLOOR_START', { floor, chipsStart: run.chips, karmaStart: run.karma, layoutSeed: run.board.layoutSeed || null, deckSnapshot: deckSnapshot() });
      run.board.tiles.forEach(tile => {
        if (tile.npc) {
          logEvent('NPC_ASSIGNED', {
            floor,
            tileId: tile.id,
            tileType: tile.type,
            npcName: tile.npc.name,
            npcCallingCard: tile.npc.callingCard,
            aiProfileId: tile.npc.aiProfileId || null
          });
        }
      });

      renderAll();
    }

    // =============================================
    // MOVEMENT
    // =============================================
    function getAvailableMoves() {
      const currentId = run.board.currentTileId;
      if (currentId === null) return [18, 19, 20].filter(id => !run.board.visited.has(id));
      const current = run.board.tiles[currentId];
      return current.connections.filter(id => !run.board.visited.has(id));
    }

    function enterTile(tileId) {
      const fromTileId = run.board.currentTileId;
      const wasVisited = run.board.visited.has(tileId);
      run.board.currentTileId = tileId;
      run.board.visited.add(tileId);
      run.board.path.push(tileId);

      const tile = run.board.tiles[tileId];
      const tileType = tile.type;
      run.encounterSeq = safeNumber(run.encounterSeq, 0) + 1;
      run.activeEncounter = { seq: run.encounterSeq, type: tileType, tileId, tileType };
      logEvent('TILE_ENTER', { tileId, tileType, fromTileId, wasVisited, pathIndex: run.board.path.length - 1, npcName: tile && tile.npc ? tile.npc.name : null, npcCard: tile && tile.npc ? tile.npc.callingCard : null });

      renderBoard();
      resolveTileEncounter(tileType);
    }

    // =============================================
    // ENCOUNTERS
    // =============================================
    function maybeShowTableTutorial(continueFn) {
      if (uiSettings.tutorialsEnabled === false) return continueFn();
      if (hasSeenTableTutorial()) return continueFn();

      showModal('Quick Start', `
        <p class="modal-text">A fast primer before your first table.</p>
      `, [
        {
          text: 'Continue',
          primary: true,
          action: () => { markSeenTableTutorial(); closeModal(); continueFn(); }
        },
        {
          text: "Don't show again",
          action: () => { uiSettings.tutorialsEnabled = false; saveHelpPrefs(); markSeenTableTutorial(); closeModal(); continueFn(); }
        }
      ], { helpKey: 'Quick Start' });
    }

    function resolveTileEncounter(tileType) {
      switch (tileType) {
        case 'REST_STOP': encounterRest(); break;
        case 'BARTENDER': encounterBartender(); break;
        case 'MINIGAME': encounterMinigame(); break;
        case 'LOAN_SHARK': encounterLoanShark(); break;
        case 'MERCHANT': encounterMerchant(); break;
        case 'MODIFY': encounterModify(); break;
        case 'COLLECTOR': encounterCollector(); break;
        case 'STANDARD': maybeShowTableTutorial(() => encounterBlackjackStandard()); break;
        case 'HIGH_STAKES': maybeShowTableTutorial(() => encounterBlackjackHigh()); break;
        case 'BOSS': maybeShowTableTutorial(() => encounterBoss()); break;
      }
    }

    // --- Rest Stop: choose FREE removal OR +50 chips, then always +1 banked token ---
    function encounterRest() {
      showModal('Rest Stop', `
        <p class="modal-text">You take a moment to rest. Choose one benefit.</p>
        <p class="modal-text" style="margin-top:-6px;"><span style="color:var(--accent-purple); font-weight:700;">Also:</span> You will gain <strong>+1 banked Action Token</strong> regardless of choice.</p>
      `, [
        {
          text: 'Free Card Removal',
          primary: true,
          action: () => {
            logEvent('REST_CHOICE', { choice: 'free_removal', freeRemoval: true });
            openFreeRemovalPicker('Rest Stop - Free Removal', () => {
              clampAddBankedToken(1);
              logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
              renderHUD();
              showToast('+1 banked token');
            });
          }
        },
        {
          text: `Take +${REST_REWARD} Chips`,
          action: () => {
            run.chips = safeNumber(run.chips) + REST_REWARD;
            clampAddBankedToken(1);
            logEvent('REST_CHOICE', { choice: 'chips', chips: REST_REWARD });
            logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
            closeModal();
            renderAll();
            showToast(`+${REST_REWARD} chips, +1 banked token`);
          }
        },
        { text: 'Leave', action: () => {
          clampAddBankedToken(1);
          logEvent('REST_CHOICE', { choice: 'leave' });
          logEvent('TOKEN_GAIN', { amount: 1, source: 'REST_STOP' });
          closeModal();
          renderAll();
          showToast('+1 banked token');
        } }
      ]);
    }

    // helper: free removal picker (3 random cards, choose one or none)
    function openFreeRemovalPicker(title, onDone) {
      const pool = run.playerDeck.filter(c => !isKeyCard(c));
      const candidates = shuffle(pool.slice()).slice(0, Math.min(3, pool.length)).map(card => ({ card }));
      let selected = null;

      function renderPicker() {
        let body = `
          <p class="modal-text">Select a card to remove (free). You may also choose none.</p>
          <div class="removal-picker">
            <div class="removal-cards">
              ${candidates.map((d, idx) => {
                const sel = selected === idx ? 'selected' : '';
                return `
                  <div class="removal-card-option ${sel}" onclick="selectFreeRemoval(${idx})">
                    ${renderCard(d.card, false)}
                  </div>
                `;
              }).join('')}
            </div>
          </div>
        `;

        showModal(title, body, [
          { text: 'Confirm', primary: true, disabled: selected === null, action: confirm },
          { text: 'Choose None', action: skip },
        ]);
      }

      window.selectFreeRemoval = function(idx) {
        selected = idx;
        renderPicker();
      };

      function confirm() {
        if (selected === null) return;
        const d = candidates[selected];
        const idx = run.playerDeck.indexOf(d.card);
        if (idx !== -1) run.playerDeck.splice(idx, 1);
        logEvent('FREE_REMOVAL', { card: cardToString(d.card), cardUid: d.card.uid || null, cardRef: cardRef(d.card), deckSnapshot: deckSnapshot() });
        recordDeckSnapshot('FREE_REMOVAL');
        closeModal();
        renderAll();
        showToast(`Removed ${cardToString(d.card)} (free)`);
        if (onDone) onDone();
      }

      function skip() {
        logEvent('FREE_REMOVAL_SKIP', {});
        closeModal();
        renderAll();
        if (onDone) onDone();
      }

      renderPicker();
    }

    // --- Bartender: choose +50 chips OR buy cocktail (150). Only one choice. ---
    function encounterBartender() {
      const allIds = Object.keys(ACTIONS);
      const unowned = allIds.filter(id => !run.ownedActions.includes(id));
      const offeredId = unowned.length ? unowned[Math.floor(Math.random() * unowned.length)] : null;

      const canBuy = offeredId && run.chips >= COCKTAIL_COST;
      const ownedCount = run.ownedActions.length;

      let offerHtml = '';
      const hsKey = run.secret && run.secret.keys ? run.secret.keys.highStakes : null;
      if (hsKey && !hsKey.obtained && run.floor === hsKey.floor && !hsKey.hinted && hsKey.tileId !== null) {
        offerHtml += `<p class="modal-text">"Thereâ€™s a high-stakes table with a Key Card on this floor."</p>`;
        hsKey.hinted = true;
      }
      if (!offeredId) {
        offerHtml = `
          <p class="modal-text">The bartender has no new cocktails to offer right now.</p>
          <p class="modal-text">You can still take <strong>+${BARTENDER_REWARD} chips</strong> if you want.</p>
        `;
      } else {
        offerHtml = `
          <p class="modal-text">The bartender offers you a choice: take chips for luck, or buy a cocktail that unlocks a match action.</p>
          <div style="padding:12px; border:1px solid var(--border-color); border-radius:12px; background: var(--bg-card); margin: 14px 0;">
            <div style="font-family:'Cinzel', serif; color: var(--accent-gold); text-transform: uppercase; letter-spacing: 1px; font-size: 14px;">
              Cocktail Offer
            </div>
            <div style="margin-top:8px; display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap;">
              <div style="flex:1;">
                <div style="font-weight:800; color: var(--text-primary);">${ACTIONS[offeredId].name}</div>
                <div style="color: var(--text-secondary); font-size:12px; line-height:1.4; margin-top:4px;">${ACTIONS[offeredId].desc}</div>
              </div>
              <div style="font-family:'Fira Code', monospace; color: var(--accent-purple); font-weight:800;">${COCKTAIL_COST} chips</div>
            </div>
          </div>
          <p class="modal-text" style="margin-top:-6px; color: var(--text-muted);">Actions owned: ${ownedCount}</p>
        `;
      }

      showModal('Bartender', offerHtml, [
        {
          text: `Take +${BARTENDER_REWARD} Chips`,
          primary: true,
          action: () => {
            run.chips = safeNumber(run.chips) + BARTENDER_REWARD;
            logEvent('BARTENDER_TAKE', { chips: BARTENDER_REWARD });
            closeModal();
            renderAll();
            showToast(`+${BARTENDER_REWARD} chips`);
          }
        },
        {
          text: offeredId ? `Buy Cocktail (${COCKTAIL_COST})` : 'Buy Cocktail (Unavailable)',
          disabled: !canBuy,
          action: () => {
            if (!offeredId) return;
            if (run.chips < COCKTAIL_COST) return;
            run.chips -= COCKTAIL_COST;
            run.ownedActions.push(offeredId);
            logEvent('COCKTAIL_BOUGHT', { actionId: offeredId, actionName: ACTIONS[offeredId].name, cost: COCKTAIL_COST });
            closeModal();
            renderAll();
            showToast(`Unlocked: ${ACTIONS[offeredId].name}`);
          }
        },
        { text: 'Leave', action: () => { closeModal(); renderAll(); } }
      ]);
    }

    const Minigames = (() => {
      const overlay = () => document.getElementById('minigameOverlay');
      const frame = () => document.getElementById('minigameFrame');

      let active = null;
      let testSession = { active: false, kind: null };

      function setTestBarVisible(on, kindLabel) {
        const bar = document.getElementById('minigameTestBar');
        const title = document.getElementById('minigameTestTitle');
        if (!bar) return;
        if (on) {
          if (title) title.textContent = `TEST MODE â€” ${kindLabel || ''}`.trim();
          bar.classList.remove('hidden');
        } else {
          bar.classList.add('hidden');
        }
      }

      function openOverlayWithTemplate(tplId) {
        const tpl = document.getElementById(tplId);
        const html = tpl ? tpl.innerHTML : '';
        const ov = overlay();
        const fr = frame();

        const sfxBridge = `<script>(function(){
  document.addEventListener('pointerdown', function(e){
    try {
      if (typeof e.button === 'number' && e.button !== 0) return;
      var t = e.target;
      if (!t || !t.closest) return;
      if (t.closest('input, textarea, select')) return;
      var clickable = t.closest('button, [role="button"], a[href], [onclick], .bj-btn, .modal-btn');
      if (!clickable || clickable.disabled) return;
      if (clickable.getAttribute('data-sfx-skip') === '1') return;
      var key = clickable.getAttribute('data-sfx') || 'ui_click';
      parent.postMessage({ __p63: 1, type: 'P63_MINIGAME_SFX', name: key }, '*');
    } catch (err) {}
  }, true);
})();<\/script>`;

        if (html.includes('</body>')) fr.srcdoc = html.replace('</body>', `${sfxBridge}</body>`);
        else fr.srcdoc = `${html}${sfxBridge}`;
        ov.classList.remove('hidden');
        ov.setAttribute('aria-hidden', 'false');
      }

      function closeOverlay() {
        const ov = overlay();
        const fr = frame();
        ov.classList.add('hidden');
        ov.setAttribute('aria-hidden', 'true');
        fr.srcdoc = '';
        setTestBarVisible(false);
        active = null;
      }

      function postToFrame(msg) {
        const fr = frame();
        if (!fr || !fr.contentWindow) return;
        fr.contentWindow.postMessage(msg, '*');
      }

      function rollRarity() {
        const x = Math.random();
        let acc = 0;
        for (const row of MINIGAME_RARITY_ROLL) {
          acc += row.p;
          if (x <= acc) return row.r;
        }
        return 'common';
      }

      function pickDefIdByRarity(defsObj, rarity) {
        const all = Object.values(defsObj || {});
        const pool = all.filter((d) => d && d.rarity === rarity);
        const use = pool.length ? pool : all;
        if (!use.length) return null;
        return use[Math.floor(Math.random() * use.length)].id;
      }

      function makeRewardCard(opts = {}) {
        const forceRare = !!opts.forceRare;
        const c = {
          uid: null,
          rank: RANKS[Math.floor(Math.random() * RANKS.length)],
          suit: SUITS[Math.floor(Math.random() * SUITS.length)],
          stampId: null,
          sleeveId: null,
          laminationId: null,
          _forcedHighValue: forceRare
        };

        const sr = forceRare ? 'rare' : rollRarity();
        const lr = forceRare ? 'rare' : rollRarity();
        c.stampId = pickDefIdByRarity(STAMP_DEFS, sr);
        c.sleeveId = pickDefIdByRarity(SLEEVE_DEFS, lr);

        assignUid(c);
        return c;
      }

      function dedupeRewardCards(rewards) {
        const list = Array.isArray(rewards) ? rewards : [];
        const seen = new Set();

        for (let pass = 0; pass < 12; pass++) {
          let changed = false;
          seen.clear();

          for (const card of list) {
            const key = `${card.rank}${card.suit}|${card.stampId || ''}|${card.sleeveId || ''}`;
            if (!seen.has(key)) {
              seen.add(key);
              continue;
            }

            card.rank = RANKS[Math.floor(Math.random() * RANKS.length)];
            card.suit = SUITS[Math.floor(Math.random() * SUITS.length)];
            if (!card._forcedHighValue) {
              card.stampId = pickDefIdByRarity(STAMP_DEFS, rollRarity());
              card.sleeveId = pickDefIdByRarity(SLEEVE_DEFS, rollRarity());
            }
            assignUid(card);
            changed = true;
          }

          if (!changed) break;
        }

        return list;
      }

      function formatRewardForMinigame(card) {
        const sd = getStampDef(card.stampId);
        const ld = getSleeveDef(card.sleeveId);
        return {
          rank: card.rank,
          suitSym: card.suit,
          stampId: card.stampId,
          sleeveId: card.sleeveId,
          stampShort: (sd && (sd.icon || sd.name)) || card.stampId || '',
          sleeveShort: (ld && (ld.icon || ld.name)) || card.sleeveId || ''
        };
      }

      function beginPokerSlots(opts = {}) {
        const testMode = !!opts.testMode;

        if (!testMode) {
          if (run.chips < MINIGAME_POKER_ENTRY_COST) {
            showToast(`Need ${MINIGAME_POKER_ENTRY_COST} chips`);
            return;
          }
          run.chips -= MINIGAME_POKER_ENTRY_COST;
          logEvent('MINIGAME_START', { kind: 'POKER_SLOTS', entryCost: MINIGAME_POKER_ENTRY_COST });
          renderHUD();
        }

        active = { kind: 'POKER_SLOTS', testMode, poker: { entryCost: MINIGAME_POKER_ENTRY_COST } };
        openOverlayWithTemplate('tplMinigamePokerSlots');
        setTimeout(() => {
          postToFrame({
            __p63: 1,
            type: 'P63_INIT',
            kind: 'POKER_SLOTS',
            startChips: 100,
            ante: 25,
            freeSpins: 2,
            baseBurn: 15,
            heatStep: 10
          });
        }, 30);
      }

      function beginInfiltration(opts = {}) {
        const testMode = !!opts.testMode;
        if (!testMode) logEvent('MINIGAME_START', { kind: 'INFILTRATION' });
        active = { kind: 'INFILTRATION', testMode, infiltration: { rewardSetId: null, rewards: null } };
        openOverlayWithTemplate('tplMinigameInfiltration');
      }

      function onMessage(e) {
        const fr = frame();
        if (!fr || e.source !== fr.contentWindow) return;

        const d = e.data;
        if (!d || d.__p63 !== 1) return;
        if (!active) return;

        if (d.type === 'P63_MINIGAME_READY') return;

        if (d.type === 'P63_MINIGAME_SFX') {
          try { if (window.SFX) SFX.play(d.name || 'ui_click'); } catch (err) {}
          return;
        }

        if (d.type === 'P63_REQUEST_REWARD_SET' && d.kind === 'INFILTRATION' && active.kind === 'INFILTRATION') {
          const setId = `rw_${Date.now()}_${Math.floor(Math.random() * 1e9)}`;
          const forcedIdx = Math.floor(Math.random() * 3);
          const rewards = dedupeRewardCards([0, 1, 2].map((idx) => makeRewardCard({ forceRare: idx === forcedIdx })));
          active.infiltration.rewardSetId = setId;
          active.infiltration.rewards = rewards;

          if (!active.testMode) {
            logEvent('MINIGAME_REWARD_OFFER', {
              kind: 'INFILTRATION',
              rewardSetId: setId,
              rewards: rewards.map((r) => ({ rank: r.rank, suit: r.suit, stampId: r.stampId, sleeveId: r.sleeveId, uid: r.uid }))
            });
          }

          postToFrame({
            __p63: 1,
            type: 'P63_REWARD_SET',
            kind: 'INFILTRATION',
            rewardSetId: setId,
            rewards: rewards.map(formatRewardForMinigame)
          });
          return;
        }

        if (d.type === 'P63_MINIGAME_END') {
          if (d.kind === 'POKER_SLOTS' && active.kind === 'POKER_SLOTS') {
            const cashOut = Math.max(0, safeNumber(d.cashOut, 0));

            if (active.testMode && testSession.active) {
              showToast(cashOut > 0 ? `Test cash out: ${cashOut}` : 'Test busted');
              beginPokerSlots({ testMode: true });
              return;
            }

            run.chips += cashOut;
            logEvent('MINIGAME_END', { kind: 'POKER_SLOTS', reason: d.reason || null, cashOut, net: cashOut - MINIGAME_POKER_ENTRY_COST });
            closeOverlay();
            renderAll();
            showToast(cashOut > 0 ? `Cashed out ${cashOut} chips` : 'Busted');
            return;
          }

          if (d.kind === 'INFILTRATION' && active.kind === 'INFILTRATION') {
            if (active.testMode && testSession.active) {
              if (d.outcome === 'win') showToast('Test win (reward not applied)');
              else showToast('Test failed');
              beginInfiltration({ testMode: true });
              return;
            }

            if (d.outcome === 'win') {
              const setId = d.rewardSetId || null;
              const idx = safeNumber(d.chosenIdx, -1);

              if (!active.infiltration.rewards || setId !== active.infiltration.rewardSetId || idx < 0 || idx >= active.infiltration.rewards.length) {
                logEvent('MINIGAME_END', { kind: 'INFILTRATION', outcome: 'win', applied: false, reason: 'reward_mismatch' });
                closeOverlay();
                renderAll();
                showToast('Reward failed (mismatch)');
                return;
              }

              const card = active.infiltration.rewards[idx];
              run.playerDeck.push(card);
              logEvent('MINIGAME_END', {
                kind: 'INFILTRATION',
                outcome: 'win',
                applied: true,
                chosenIdx: idx,
                card: { rank: card.rank, suit: card.suit, stampId: card.stampId, sleeveId: card.sleeveId, uid: card.uid }
              });

              closeOverlay();
              renderAll();
              showToast(`Card acquired: ${card.rank}${card.suit}`);
              return;
            }

            logEvent('MINIGAME_END', { kind: 'INFILTRATION', outcome: d.outcome || 'dead', applied: false });
            closeOverlay();
            renderAll();
            showToast('No reward');
            return;
          }
        }
      }

      function startTest(kind) {
        testSession.active = true;
        testSession.kind = kind;

        setTestBarVisible(true, kind === 'POKER_SLOTS' ? 'Poker Slots' : 'Infiltration');

        if (kind === 'POKER_SLOTS') beginPokerSlots({ testMode: true });
        else beginInfiltration({ testMode: true });
      }

      function stopTest(returnToMenu) {
        testSession.active = false;
        testSession.kind = null;
        setTestBarVisible(false);

        closeOverlay();
        renderAll();

        if (returnToMenu) openTestGamesModal();
      }

      function openChoiceModal() {
        const canAfford = run.chips >= MINIGAME_POKER_ENTRY_COST;

        showModal('Minigame', `
          <p class="modal-text">A side path opens. Choose your wager.</p>
          <div class="modal-reward" style="display:flex; flex-direction:column; gap:8px;">
            <div><b>PLAY FOR CHIPS</b> â€” Poker Slots (Entry: ${MINIGAME_POKER_ENTRY_COST})</div>
            <div><b>PLAY FOR CARDS</b> â€” Infiltration Run (Win: choose 1 of 3)</div>
          </div>
        `, [
          {
            text: canAfford ? `PLAY FOR CHIPS (-${MINIGAME_POKER_ENTRY_COST})` : `PLAY FOR CHIPS (Need ${MINIGAME_POKER_ENTRY_COST})`,
            primary: true,
            disabled: !canAfford,
            action: () => {
              closeModal();
              beginPokerSlots();
            }
          },
          {
            text: 'PLAY FOR CARDS',
            action: () => {
              closeModal();
              beginInfiltration();
            }
          },
          { text: 'Leave', action: () => { closeModal(); renderAll(); } }
        ]);
      }

      (function bindTestBarOnce() {
        const btn = document.getElementById('btnEndTest');
        if (btn) btn.onclick = () => stopTest(true);
      })();

      window.addEventListener('message', onMessage);

      return { openChoiceModal, startTest, stopTest };
    })();

    function encounterMinigame() {
      Minigames.openChoiceModal();
    }

    function encounterLoanShark() {
      const canTakeLoan = !run.loan.active;

      let body = '<p class="modal-text">The loan shark eyes you carefully.</p>';

      if (canTakeLoan) {
        body += `<p class="modal-text">"Need some chips? I can lend you ${LOAN_AMOUNT}, but you'll owe me ${LOAN_REPAY} before you face the final boss."</p>`;
      } else if (run.loan.active && !run.loan.repaid) {
        body += `<p class="modal-text">"You already owe me ${LOAN_REPAY}. Don't forget to pay up before the final boss."</p>`;
      } else {
        body += '<p class="modal-text">"Our business is concluded. Good luck."</p>';
      }

      const buttons = [];
      if (canTakeLoan) {
        buttons.push({
          text: `Take Loan (+${LOAN_AMOUNT})`,
          primary: true,
          action: () => {
            run.chips = safeNumber(run.chips) + LOAN_AMOUNT;
            run.loan.active = true;
            run.loan.repaid = false;
            logEvent('LOAN_TAKEN', { amount: LOAN_AMOUNT, repay: LOAN_REPAY });
            closeModal();
            renderAll();
            showToast(`Borrowed ${LOAN_AMOUNT} chips. Repay ${LOAN_REPAY} before Floor 3 boss!`);
          }
        });
      }
      buttons.push({ text: 'Decline', action: () => { closeModal(); renderAll(); } });

      showModal('Loan Shark', body, buttons);
    }

    // =============================================
    // MODIFY
    // =============================================
    const MODIFY_CANDIDATE_COUNT = 5;
    const MODIFY_PREMIUM_CHANCE = 0.25;
    const MODIFY_RANK_SHIFT_MAX_STEPS = 3;
    const MODIFY_RANK_SHIFT_STEP_COST = 15;

    const MODIFY_SERVICES = {
      RESUIT: { id: 'RESUIT', name: 'Re-Suit', tier: 'core', kind: 'single' },
      RERANK: { id: 'RERANK', name: 'Rank Shift', tier: 'core', kind: 'single' },
      CALLING_SUIT_SWEEP: { id: 'CALLING_SUIT_SWEEP', name: 'Calling Suit Sweep', tier: 'premium', kind: 'bulk' },
      UNIFORM_RANK_PRESS: { id: 'UNIFORM_RANK_PRESS', name: 'Uniform Rank Press', tier: 'premium', kind: 'bulk' }
    };

    function rankIndex(rank) { return RANKS.indexOf(rank); }

    function computeShiftedRank(rank, delta) {
      const i = rankIndex(rank);
      if (i < 0) return rank;
      const j = i + delta;
      if (j < 0 || j >= RANKS.length) return null;
      return RANKS[j];
    }

    function getModifyPriceMult() {
      const ctx = run && run.ui && run.ui.modifyContext;
      const mult = ctx && typeof ctx.priceMult === 'number' ? ctx.priceMult : 1;
      return Math.max(0.75, Math.min(1.25, mult));
    }

    function getRankShiftExtraCost(delta) {
      const n = Math.abs(delta);
      if (n <= 1) return 0;
      const units = ((n - 1) * n) / 2;
      return Math.ceil(units * MODIFY_RANK_SHIFT_STEP_COST * getModifyPriceMult());
    }

    function getModifyRerollCost() {
      return Math.ceil(REMOVAL_REROLL_COST * getModifyPriceMult());
    }

    function getEligibleStandardIndices() {
      if (!run || !run.playerDeck) return [];
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (isStandardCard(card)) eligible.push(idx);
      });
      return eligible;
    }

    function rollModifyService() {
      const core = [MODIFY_SERVICES.RESUIT.id, MODIFY_SERVICES.RERANK.id];
      const premium = [MODIFY_SERVICES.UNIFORM_RANK_PRESS.id];
      if (run && run.callingCard) premium.push(MODIFY_SERVICES.CALLING_SUIT_SWEEP.id);

      if (premium.length && Math.random() < MODIFY_PREMIUM_CHANCE) {
        return randomChoice(premium);
      }
      return randomChoice(core);
    }

    function buildModifyOffers() {
      const eligible = getEligibleStandardIndices();
      if (!eligible.length) return [];
      const offers = [];
      for (let i = 0; i < 3; i += 1) offers.push(rollModifyService());
      return offers;
    }


    function modifyCounterBanner() {
      const ctx = run && run.ui && run.ui.modifyContext;
      const shopId = ctx && ctx.shopId;
      return shopId ? renderShopPurchaseCounter(shopId) : '';
    }

    function encounterModify() {
      const offers = buildModifyOffers();
      const eligibleCount = getEligibleStandardIndices().length;
      const tileId = run.board.currentTileId;
      const shopId = `modify-${safeNumber(run.encounterSeq, 0)}-${tileId}`;

      run.ui.modifyContext = {
        tileId,
        shopId,
        servicesOffered: offers,
        selectedServiceId: null,
        previewIndices: [],
        rankChoices: null,
        session: null,
        rankShift: null
      };

      logEvent('MODIFY_ENTER', {
        tileId,
        floor: run.floor,
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length,
        eligibleCount,
        servicesOffered: offers
      });

      renderModifyMenu();
    }

    function renderModifyMenu() {
      const ctx = run.ui.modifyContext || {};
      const eligibleCount = getEligibleStandardIndices().length;
      const offers = ctx.servicesOffered || [];
      const inProgress = !!ctx.selectedServiceId;
      const chipsNow = safeNumber(run.chips);
      const shopId = ctx.shopId;
      const counterHtml = renderShopPurchaseCounter(shopId);
      const capReached = !canShopPurchase(shopId);

      let body = `
        ${counterHtml}
        <p class="modal-text">Modify changes cards already in your deck (base cards only). Choose one service.</p>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong> | Eligible cards: <strong>${eligibleCount}</strong></p>
      `;

      if (offers.length && !inProgress) {
        body += `<div style="display:flex; flex-direction:column; gap:6px; margin-top:8px;">`;
        offers.forEach(serviceId => {
          const cost = getModifyServiceCost(serviceId, run.floor);
          const description = serviceId === MODIFY_SERVICES.RERANK.id
            ? 'Shift one card\'s rank up/down by up to 3 steps. Cost increases per step.'
            : (serviceId === MODIFY_SERVICES.RESUIT.id
              ? 'Change one card\'s suit.'
              : (serviceId === MODIFY_SERVICES.UNIFORM_RANK_PRESS.id
                ? 'Set 5 cards to one chosen rank.'
                : 'Set 5 cards to your calling suit.'));
          body += `<p class="modal-text" style="margin:0;"><strong>${MODIFY_SERVICES[serviceId]?.name || serviceId}</strong> (${cost}) â€” ${description}</p>`;
        });
        body += `</div>`;
      }

      if (!eligibleCount) {
        body += `<p class="modal-text" style="color:var(--text-muted);">No eligible cards to modify.</p>`;
      } else if (inProgress) {
        const meta = MODIFY_SERVICES[ctx.selectedServiceId];
        body += `<p class="modal-text" style="color:var(--accent-gold); font-weight:700;">Service in progress: ${meta ? meta.name : ctx.selectedServiceId}</p>`;
      }

      if (capReached && !inProgress) {
        body += `<p class="modal-text" style="color:var(--danger); font-weight:700;">Purchase cap reached for this shop.</p>`;
      }

      const buttons = [];
      if (eligibleCount && !inProgress) {
        offers.forEach(serviceId => {
          const meta = MODIFY_SERVICES[serviceId];
          const cost = getModifyServiceCost(serviceId, run.floor);
          buttons.push({
            text: `${meta ? meta.name : serviceId} (${cost})`,
            primary: true,
            disabled: chipsNow < cost || capReached,
            action: () => selectModifyService(serviceId)
          });
        });
      } else if (inProgress) {
        buttons.push({
          text: 'Continue',
          primary: true,
          action: () => openModifyService(ctx.selectedServiceId)
        });
      }

      if (!inProgress) {
        buttons.push({
          text: 'Leave',
          action: () => {
            logEvent('MODIFY_LEAVE', { tileId: run.board.currentTileId });
            run.ui.modifyContext = null;
            closeModal();
            renderAll();
          }
        });
      }

      showModal('Modify', body, buttons);
    }

    function selectModifyService(serviceId) {
      const ctx = run.ui.modifyContext;
      if (!ctx || !canShopPurchase(ctx.shopId)) {
        showToast('Purchase cap reached for this shop.');
        return;
      }
      if (!ctx) return;
      const meta = MODIFY_SERVICES[serviceId];
      const cost = getModifyServiceCost(serviceId, run.floor);
      if (run.chips < cost) return;

      const chipsBefore = run.chips;
      run.chips -= cost;
      recordShopPurchase(ctx.shopId, { shopType: 'MODIFY', kind: serviceId });
      ctx.selectedServiceId = serviceId;
      logEvent('MODIFY_SERVICE_SELECT', {
        serviceId,
        tier: meta ? meta.tier : null,
        kind: meta ? meta.kind : null,
        cost,
        chipsBefore,
        chipsAfter: run.chips
      });
      openModifyService(serviceId);
    }

    function rerollModifyCandidates(serviceId) {
      const ctx = run.ui.modifyContext;
      if (!ctx || !canShopPurchase(ctx.shopId)) {
        showToast('Purchase cap reached for this shop.');
        return;
      }
      const cost = getModifyRerollCost();
      if (run.chips < cost) return;
      const chipsBefore = run.chips;
      run.chips -= cost;
      recordShopPurchase(ctx.shopId, { shopType: 'MODIFY', kind: 'REROLL', serviceId });

      logEvent('MODIFY_REROLL', {
        serviceId,
        cost,
        chipsBefore,
        chipsAfter: run.chips
      });

      openModifyService(serviceId, true);
    }

    function openModifyService(serviceId, forceReroll = false) {
      if (serviceId === MODIFY_SERVICES.RESUIT.id) {
        openModifyCorePicker('Re-Suit', serviceId, forceReroll);
        return;
      }
      if (serviceId === MODIFY_SERVICES.RERANK.id) {
        openModifyRankShift(forceReroll);
        return;
      }
      if (serviceId === MODIFY_SERVICES.CALLING_SUIT_SWEEP.id) {
        openModifyCallingSuitSweep(forceReroll);
        return;
      }
      if (serviceId === MODIFY_SERVICES.UNIFORM_RANK_PRESS.id) {
        openModifyUniformRankPress(forceReroll);
      }
    }

    window.rerollModifyCandidatesUI = function(serviceId) {
      rerollModifyCandidates(serviceId);
    };

    function openModifyCorePicker(title, serviceId, forceReroll = false) {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      if (!ctx.previewIndices || !ctx.previewIndices.length || forceReroll) {
        ctx.previewIndices = shuffle(eligible).slice(0, Math.min(MODIFY_CANDIDATE_COUNT, eligible.length));
      }
      const sample = ctx.previewIndices;
      const meta = MODIFY_SERVICES[serviceId];
      logEvent('MODIFY_CANDIDATES_SHOWN', {
        serviceId,
        tier: meta ? meta.tier : null,
        countShown: sample.length,
        candidates: sample.map(i => cardRef(run.playerDeck[i]))
      });

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="selectModifyCoreCard(${idx})">Select</button>
          </div>
        `;
      }).join('');

      const rerollCost = getModifyRerollCost();
      const canReroll = run.chips >= rerollCost && canShopPurchase(ctx.shopId);

      showModal(`Modify - ${title}`, `
        ${modifyCounterBanner()}
        <p class="modal-text">Choose a card to modify.</p>
        <div class="merchant-cards">${cardsHtml}</div>
        <div style="display:flex; justify-content:center; margin-top:8px;">
          <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollModifyCandidatesUI('${serviceId}')">Re-roll (${rerollCost})</button>
        </div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ], { helpKey: 'Modify - Service' });


      window.selectModifyCoreCard = function(deckIdx) {
        logEvent('MODIFY_SELECTION', {
          serviceId,
          selected: cardRef(run.playerDeck[deckIdx])
        });
        if (serviceId === MODIFY_SERVICES.RESUIT.id) {
          openModifySuitPicker(deckIdx);
        }
      };
    }

    function openModifyRankShift(forceReroll = false) {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      if (!ctx || !eligible.length) return;

      if (!ctx.previewIndices || !ctx.previewIndices.length || forceReroll) {
        ctx.previewIndices = shuffle(eligible).slice(0, Math.min(MODIFY_CANDIDATE_COUNT, eligible.length));
      }
      const sample = ctx.previewIndices;
      const meta = MODIFY_SERVICES.RERANK;
      logEvent('MODIFY_CANDIDATES_SHOWN', {
        serviceId: MODIFY_SERVICES.RERANK.id,
        tier: meta ? meta.tier : null,
        countShown: sample.length,
        candidates: sample.map(i => cardRef(run.playerDeck[i]))
      });

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="selectModifyRankShiftCard(${idx})">Select</button>
          </div>
        `;
      }).join('');

      const rerollCost = getModifyRerollCost();
      const canReroll = run.chips >= rerollCost && canShopPurchase(ctx.shopId);

      showModal('Modify - Rank Shift', `
        ${modifyCounterBanner()}
        <p class="modal-text">Choose one card for rank shifting.</p>
        <div class="merchant-cards">${cardsHtml}</div>
        <div style="display:flex; justify-content:center; margin-top:8px;">
          <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollModifyCandidatesUI('${MODIFY_SERVICES.RERANK.id}')">Re-roll (${rerollCost})</button>
        </div>
      `, [
        { text: 'Back', action: () => renderModifyMenu() }
      ], { helpKey: 'Modify - Service' });


      window.selectModifyRankShiftCard = function(deckIdx) {
        logEvent('MODIFY_SELECTION', {
          serviceId: MODIFY_SERVICES.RERANK.id,
          selected: cardRef(run.playerDeck[deckIdx])
        });
        openModifyRankShiftStepper(deckIdx);
      };
    }

    function openModifyRankShiftStepper(deckIdx) {
      const ctx = run.ui.modifyContext;
      const card = run.playerDeck[deckIdx];
      if (!ctx || !card || !isStandardCard(card)) return;

      if (!ctx.rankShift || ctx.rankShift.deckIdx !== deckIdx) {
        ctx.rankShift = { deckIdx, delta: 0 };
      }
      ctx.session = { type: 'RANK_SHIFT', deckIdx };

      const delta = safeNumber(ctx.rankShift.delta, 0);
      const shiftedRank = computeShiftedRank(card.rank, delta);
      const canMinusByStep = delta > -MODIFY_RANK_SHIFT_MAX_STEPS && computeShiftedRank(card.rank, delta - 1) !== null;
      const canPlusByStep = delta < MODIFY_RANK_SHIFT_MAX_STEPS && computeShiftedRank(card.rank, delta + 1) !== null;
      const extraCost = getRankShiftExtraCost(delta);
      const canAfford = run.chips >= extraCost;
      const deltaLabel = delta > 0 ? `+${delta}` : `${delta}`;
      const previewLabel = shiftedRank ? `${card.rank} â†’ ${shiftedRank}` : `${card.rank} â†’ (invalid)`;

      showModal('Modify - Rank Shift', `
        ${modifyCounterBanner()}
        <p class="modal-text">Selected card:</p>
        <div class="merchant-cards" style="justify-content:center;">${renderCard(card, false)}</div>
        <p class="modal-text" style="margin-top:8px;">Rank preview: <strong>${previewLabel}</strong></p>
        <div style="display:flex; justify-content:center; gap:10px; margin-top:8px;">
          <button class="modal-btn" ${canMinusByStep ? '' : 'disabled'} onclick="adjustRankShiftDelta(-1)">-</button>
          <button class="modal-btn" ${canPlusByStep ? '' : 'disabled'} onclick="adjustRankShiftDelta(1)">+</button>
        </div>
        <p class="modal-text" style="margin-top:8px;">Steps: <strong>${deltaLabel}</strong> (extra cost: <strong>${extraCost}</strong>)</p>
        ${!canAfford ? '<p class="modal-text" style="color:var(--danger);">Not enough chips for this shift.</p>' : ''}
      `, [
        { text: 'Back', action: () => openModifyRankShift() },
        {
          text: `Confirm${extraCost ? ` (-${extraCost})` : ''}`,
          primary: true,
          disabled: delta === 0 || !shiftedRank || !canAfford,
          action: () => confirmModifyRankShift()
        }
      ], { helpKey: 'Modify - Service' });

      window.adjustRankShiftDelta = function(step) {
        const state = run.ui.modifyContext && run.ui.modifyContext.rankShift;
        if (!state) return;
        const targetCard = run.playerDeck[state.deckIdx];
        if (!targetCard || !isStandardCard(targetCard)) return;
        const nextDelta = safeNumber(state.delta, 0) + step;
        if (Math.abs(nextDelta) > MODIFY_RANK_SHIFT_MAX_STEPS) return;
        if (computeShiftedRank(targetCard.rank, nextDelta) === null) return;
        state.delta = nextDelta;
        openModifyRankShiftStepper(state.deckIdx);
      };

      window.confirmModifyRankShift = function() {
        const state = run.ui.modifyContext && run.ui.modifyContext.rankShift;
        if (!state) return;
        const currentCard = run.playerDeck[state.deckIdx];
        if (!currentCard || !isStandardCard(currentCard)) return;

        const applyDelta = safeNumber(state.delta, 0);
        const rankBefore = currentCard.rank;
        const rankAfter = computeShiftedRank(rankBefore, applyDelta);
        const extraCostNow = getRankShiftExtraCost(applyDelta);
        if (applyDelta === 0 || !rankAfter || run.chips < extraCostNow) return;

        if (extraCostNow > 0) run.chips -= extraCostNow;
        applyModifyService('RERANK', [state.deckIdx], () => {
          currentCard.rank = rankAfter;
        }, {
          delta: applyDelta,
          extraCost: extraCostNow,
          rankBefore,
          rankAfter
        });
      };
    }

    function openModifySuitPicker(deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;

      showModal('Modify - Re-Suit', `
        ${modifyCounterBanner()}
        <p class="modal-text">Choose a new suit for ${cardToString(card)}.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          ${SUITS.map(suit => `<button class="modal-btn" onclick="applyModifyResuit(${deckIdx}, '${suit}')">${suit}</button>`).join('')}
        </div>
      `, [
        { text: 'Back', action: () => openModifyCorePicker('Re-Suit', MODIFY_SERVICES.RESUIT.id) }
      ], { helpKey: 'Modify - Service' });
    }

    window.applyModifyResuit = function(deckIdx, suit) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card)) return;
      applyModifyService('RESUIT', [deckIdx], () => { card.suit = suit; });
    };

    function openModifyCallingSuitSweep(forceReroll = false) {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      if (!ctx.previewIndices || !ctx.previewIndices.length || forceReroll) {
        ctx.previewIndices = shuffle(eligible).slice(0, Math.min(MODIFY_CANDIDATE_COUNT, eligible.length));
      }
      const sample = ctx.previewIndices;

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return renderCard(card, false);
      }).join('');

      const rerollCost = getModifyRerollCost();
      const canReroll = run.chips >= rerollCost && canShopPurchase(ctx.shopId);

      showModal('Modify - Calling Suit Sweep', `
        ${modifyCounterBanner()}
        <p class="modal-text">Preview the cards that will be re-suited to ${run.callingCard ? run.callingCard.suit : ''}.</p>
        <div class="merchant-cards">${cardsHtml}</div>
        <div style="display:flex; justify-content:center; margin-top:8px;">
          <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollModifyCandidatesUI('${MODIFY_SERVICES.CALLING_SUIT_SWEEP.id}')">Re-roll (${rerollCost})</button>
        </div>
      `, [
        {
          text: 'Confirm',
          primary: true,
          action: () => {
            applyModifyService('CALLING_SUIT_SWEEP', sample, () => {
              sample.forEach(idx => {
                const card = run.playerDeck[idx];
                if (card && isStandardCard(card)) card.suit = run.callingCard.suit;
              });
            });
          }
        },
        { text: 'Back', action: () => renderModifyMenu() }
      ], { helpKey: 'Modify - Service' });

    }

    function openModifyUniformRankPress(forceReroll = false) {
      const ctx = run.ui.modifyContext;
      const eligible = getEligibleStandardIndices();
      if (!ctx.previewIndices || !ctx.previewIndices.length || forceReroll) {
        ctx.previewIndices = shuffle(eligible).slice(0, Math.min(MODIFY_CANDIDATE_COUNT, eligible.length));
      }
      const sample = ctx.previewIndices;
      if (!ctx.rankChoices || !ctx.rankChoices.length) {
        ctx.rankChoices = shuffle(RANKS.slice()).slice(0, 2);
      }
      const ranks = ctx.rankChoices;

      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return renderCard(card, false);
      }).join('');

      const rerollCost = getModifyRerollCost();
      const canReroll = run.chips >= rerollCost && canShopPurchase(ctx.shopId);

      showModal('Modify - Uniform Rank Press', `
        ${modifyCounterBanner()}
        <p class="modal-text">Choose a rank to press onto these cards.</p>
        <div class="merchant-cards">${cardsHtml}</div>
        <div style="display:flex; justify-content:center; margin-top:8px;">
          <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollModifyCandidatesUI('${MODIFY_SERVICES.UNIFORM_RANK_PRESS.id}')">Re-roll (${rerollCost})</button>
        </div>
      `, [
        ...ranks.map(rank => ({
          text: `Set to ${rank}`,
          primary: true,
          action: () => {
            applyModifyService('UNIFORM_RANK_PRESS', sample, () => {
              sample.forEach(idx => {
                const card = run.playerDeck[idx];
                if (card && isStandardCard(card)) card.rank = rank;
              });
            });
          }
        })),
        { text: 'Back', action: () => renderModifyMenu() }
      ], { helpKey: 'Modify - Service' });

    }

    function applyModifyService(serviceId, indices, applyFn, extraData = null) {
      const ctx = run.ui.modifyContext;
      const before = indices.map(i => cardToString(run.playerDeck[i]));
      const affectedUids = indices.map(i => run.playerDeck[i]?.uid || null);
      applyFn();
      const after = indices.map(i => cardToString(run.playerDeck[i]));

      logEvent('MODIFY_APPLY', {
        serviceId,
        count: indices.length,
        affectedCardUids: affectedUids,
        affectedBefore: before,
        affectedAfter: after,
        deckSnapshot: deckSnapshot(),
        ...(extraData || {})
      });
      recordDeckSnapshot('MODIFY_APPLY');

      if (ctx) {
        ctx.selectedServiceId = null;
        ctx.previewIndices = [];
        ctx.rankChoices = null;
        ctx.session = null;
        ctx.rankShift = null;
        ctx.servicesOffered = buildModifyOffers();
      }

      renderModifyMenu();
      renderAll();
      showToast('Modify service applied');
    }

    // =============================================
    // COLLECTOR
    // =============================================
    const COLLECTOR_CATALOG = [
      ...Object.values(STAMP_DEFS).map(def => ({ ...def, type: 'STAMP' })),
      ...Object.values(SLEEVE_DEFS).map(def => ({ ...def, type: 'SLEEVE' }))
    ];

    function rollCollectorRarity() {
      const roll = Math.random();
      if (roll < 0.55) return 'common';
      if (roll < 0.90) return 'uncommon';
      return 'rare';
    }

    function randomCollectorItem() {
      const rarity = rollCollectorRarity();
      const pool = COLLECTOR_CATALOG.filter(item => item.rarity === rarity);
      const fallback = COLLECTOR_CATALOG;
      const source = pool.length ? pool : fallback;
      const pick = source[Math.floor(Math.random() * source.length)];
      return { ...pick, purchased: false };
    }

    function getEligibleStampCardIndices() {
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (!isStandardCard(card) || isFused(card) || isKeyCard(card)) return;
        if (card.stampId) return;
        eligible.push(idx);
      });
      return eligible;
    }

    function getEligibleSleeveCardIndices() {
      const eligible = [];
      run.playerDeck.forEach((card, idx) => {
        if (!isStandardCard(card) || isFused(card) || isKeyCard(card)) return;
        if (card.sleeveId) return;
        eligible.push(idx);
      });
      return eligible;
    }

    function encounterCollector() {
      const tileId = run.board.currentTileId;
      if (!run.collectorShop || run.collectorShop.tileId !== tileId) {
        const shopId = `shop-${safeNumber(run.encounterSeq, 0)}-${tileId}`;
        run.collectorShop = {
          tileId,
          shopId,
          items: Array.from({ length: 5 }, () => randomCollectorItem()),
          activeItemIdx: null
        };
        logEvent('COLLECTOR_SHOP_GENERATED', {
          shopId,
          items: run.collectorShop.items.map((item, slot) => ({
            slot,
            itemId: item.id,
            type: item.type,
            rarity: item.rarity,
            cost: (item.cost || COLLECTOR_COST_BY_RARITY[item.rarity] || COLLECTOR_COST_BY_RARITY.common)
          }))
        });
      }

      logEvent('COLLECTOR_ENTER', {
        tileId,
        floor: run.floor,
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length
      });

      renderCollector();
    }

    function renderCollector() {
      const shop = run.collectorShop;
      if (!shop) return;
      const chipsNow = safeNumber(run.chips);
      const activeIdx = shop.activeItemIdx;
      const inProgress = activeIdx !== null && activeIdx !== undefined;

      const shopId = shop.shopId;
      const counterHtml = renderShopPurchaseCounter(shopId);

      let body = `
        ${counterHtml}
        <p class="modal-text">Buy an item, then apply it to a card.</p>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong></p>
      `;

      if (inProgress) {
        const active = shop.items[activeIdx];
        body += `<p class="modal-text" style="color:var(--accent-gold); font-weight:700;">Selection in progress: ${active ? active.name : ''}</p>`;
      }

      const itemsHtml = shop.items.map((item, idx) => {
        const eligible = item.type === 'STAMP' ? getEligibleStampCardIndices().length : getEligibleSleeveCardIndices().length;
        const itemCost = item.cost || COLLECTOR_COST_BY_RARITY[item.rarity] || COLLECTOR_COST_BY_RARITY.common;
        const disabled = chipsNow < itemCost || eligible === 0 || inProgress;
        const status = eligible === 0 ? 'No eligible cards' : '';
        const rarityClass = `rarity-${item.rarity}`;
        return `
          <div class="merchant-card-slot" style="min-width:180px;">
            <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
              <span class="rarity-pip ${rarityClass}"></span>
              <strong>${item.name}</strong>
            </div>
            <div style="font-size:12px; color:var(--text-secondary); min-height:32px;">${item.desc}</div>
            <button class="modal-btn" ${disabled ? 'disabled' : ''} onclick="buyCollectorItem(${idx})">
              Buy (${itemCost})
            </button>
            ${status ? `<div style="font-size:11px; color:var(--text-muted); margin-top:6px;">${status}</div>` : ''}
          </div>
        `;
      }).join('');

      body += `<div class="merchant-cards">${itemsHtml}</div>`;

      const buttons = [];
      if (inProgress) {
        buttons.push({
          text: 'Continue',
          primary: true,
          action: () => openCollectorSelection(activeIdx)
        });
      } else {
        buttons.push({
          text: 'Leave',
          action: () => {
            logEvent('COLLECTOR_LEAVE', { tileId: run.board.currentTileId });
            run.collectorShop = null;
            closeModal();
            renderAll();
          }
        });
      }

      showModal('Collector', body, buttons);
    }

    window.buyCollectorItem = function(idx) {
      const shop = run.collectorShop;
      if (!shop) return;
      const item = shop.items[idx];
      if (!item) return;
      const itemCost = item.cost || COLLECTOR_COST_BY_RARITY[item.rarity] || COLLECTOR_COST_BY_RARITY.common;
      const shopId = shop.shopId;
      if (!canShopPurchase(shopId)) {
        showToast('Purchase cap reached for this shop.');
        return;
      }
      if (run.chips < itemCost) return;

      if (item.type === 'STAMP' && getEligibleStampCardIndices().length === 0) return;
      if (item.type === 'SLEEVE' && getEligibleSleeveCardIndices().length === 0) return;

      const chipsBefore = run.chips;
      run.chips -= itemCost;
      recordShopPurchase(shopId, { shopType: 'COLLECTOR', kind: item.type || 'ITEM' });
      shop.activeItemIdx = idx;
      logEvent('COLLECTOR_BUY', {
        itemId: item.id,
        name: item.name,
        type: item.type,
        cost: (item.cost || COLLECTOR_COST_BY_RARITY[item.rarity] || COLLECTOR_COST_BY_RARITY.common),
        shopId: shop.shopId,
        slot: idx,
        chipsBefore,
        chipsAfter: run.chips
      });
      openCollectorSelection(idx);
    };

    function openCollectorSelection(idx) {
      const shop = run.collectorShop;
      if (!shop) return;
      const item = shop.items[idx];
      if (!item) return;
      if (item.type === 'STAMP') openStampSelection(item);
      else openSleeveSelection(item);
    }

    function openStampSelection(item) {
      const eligible = getEligibleStampCardIndices();
      if (!eligible.length) {
        renderCollector();
        return;
      }
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      logEvent('STAMP_CANDIDATES_SHOWN', {
        stampId: item.id,
        candidates: sample.map(idx => cardRef(run.playerDeck[idx]))
      });
      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="applyStampToCard('${item.id}', ${idx})">Select</button>
          </div>
        `;
      }).join('');

      showModal(`Collector - ${item.name}`, `
        <p class="modal-text">Choose a card to stamp.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        { text: 'Back', action: () => renderCollector() }
      ], { helpKey: 'Collector - Apply' });
    }

    window.applyStampToCard = function(stampId, deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card) || card.stampId) return;
      card.stampId = stampId;
      logEvent('STAMP_APPLY', { stampId, card: cardToString(card), cardUid: card.uid || null, cardRef: cardRef(card), shopId: run.collectorShop?.shopId, slot: run.collectorShop?.activeItemIdx ?? null });
      recordDeckSnapshot('STAMP_APPLY');
      finalizeCollectorItem();
      showToast(`${getStampDef(stampId).name} applied`);
    };

    function openSleeveSelection(item) {
      const eligible = getEligibleSleeveCardIndices();
      if (!eligible.length) {
        renderCollector();
        return;
      }
      const sample = shuffle(eligible).slice(0, Math.min(5, eligible.length));
      logEvent('SLEEVE_CANDIDATES_SHOWN', {
        sleeveId: item.id,
        candidates: sample.map(idx => cardRef(run.playerDeck[idx]))
      });
      const cardsHtml = sample.map(idx => {
        const card = run.playerDeck[idx];
        return `
          <div class="merchant-card-slot">
            ${renderCard(card, false)}
            <button class="modal-btn" onclick="applySleeveToCard('${item.id}', ${idx})">Select</button>
          </div>
        `;
      }).join('');

      showModal(`Collector - ${item.name}`, `
        <p class="modal-text">Choose a card to sleeve.</p>
        <div class="merchant-cards">${cardsHtml}</div>
      `, [
        { text: 'Back', action: () => renderCollector() }
      ], { helpKey: 'Collector - Apply' });
    }

    window.applySleeveToCard = function(sleeveId, deckIdx) {
      const card = run.playerDeck[deckIdx];
      if (!card || !isStandardCard(card) || card.sleeveId) return;
      card.sleeveId = sleeveId;
      if (card.laminationId === undefined) card.laminationId = null;
      logEvent('SLEEVE_APPLY', {
        sleeveId,
        card: cardToString(card),
        cardUid: card.uid || null,
        cardRef: cardRef(card),
        shopId: run.collectorShop?.shopId,
        slot: run.collectorShop?.activeItemIdx ?? null
      });
      recordDeckSnapshot('SLEEVE_APPLY');
      finalizeCollectorItem();
      showToast(`${getSleeveDef(sleeveId).name} applied`);
    };

    function finalizeCollectorItem() {
      const shop = run.collectorShop;
      if (!shop) return;
      const idx = shop.activeItemIdx;
      if (idx !== null && idx !== undefined) {
        shop.items[idx] = randomCollectorItem();
      }
      shop.activeItemIdx = null;
      renderCollector();
      renderAll();
    }

    // =============================================
    // MERCHANT
    // =============================================
    function encounterMerchant() {
      const tile = run.board.tiles[run.board.currentTileId];
      const npc = tile ? tile.npc : null;
      let affinity = 'neutral';
      let edgeDelta = 0;
      let priceMult = 1;
      if (npc && run.callingCard) {
        affinity = getAffinity(run.callingCard.suit, npc.callingCard.suit);
        edgeDelta = rankToValue(run.callingCard.rank) - rankToValue(npc.callingCard.rank);
        const affinityMod = affinity === 'resonant' ? -0.10 : (affinity === 'dissonant' ? 0.10 : 0);
        const edgeMod = Math.max(-0.10, Math.min(0.10, (rankToValue(npc.callingCard.rank) - rankToValue(run.callingCard.rank)) * 0.01));
        priceMult = Math.max(0.75, Math.min(1.25, 1 + affinityMod + edgeMod));
      }

      const tileId = run.board.currentTileId;
      const shopId = `merchant-${safeNumber(run.encounterSeq, 0)}-${tileId}`;

      run.ui.merchantContext = {
        tileId,
        shopId,
        rerolls: 0,
        offers: [],
        npc,
        affinity,
        edgeDelta,
        priceMult
      };

      merchantOffers = [randomCard(), randomCard(), randomCard()];
      merchantOffers.forEach(card => assignUid(card));
      run.ui.merchantContext.offers = merchantOffers.map(c => cloneCard(c));
      maybeInjectMerchantKey(merchantOffers);
      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;
      removalPaidCost = 0;
      removalPaidCost = 0;
      removalPaidCost = 0;

      logEvent('MERCHANT_ENTER', {
        npcName: npc ? npc.name : null,
        npcCallingCard: npc ? npc.callingCard : null,
        affinity,
        edgeDelta,
        priceMult: Number(priceMult.toFixed(2)),
        offers: merchantOffers.map(cardRef),
        chips: safeNumber(run.chips),
        deckSize: run.playerDeck.length
      });

      renderMerchant();
    }

    function renderMerchant() {
      const chipsNow = safeNumber(run.chips);
      const ctx = run.ui.merchantContext || {};
      const npc = ctx.npc;
      const shopId = ctx.shopId;
      const counterHtml = renderShopPurchaseCounter(shopId);
      const affinity = ctx.affinity || 'neutral';
      const priceMult = getMerchantPriceMult();
      const npcLine = npc
        ? `${npc.name} Â· ${cardToString(npc.callingCard)} Â· ${affinityIcon(affinity)} Â· Prices x${priceMult.toFixed(2)}`
        : `Prices x${priceMult.toFixed(2)}`;
      const rerollInvCost = getMerchantCost(MERCHANT_INVENTORY_REROLL_COST);
      let body = `
        ${counterHtml}
        <p class="modal-text">The merchant displays their wares.</p>
        <div class="log-kv" style="margin-bottom:10px;">${npcLine}</div>
        <p class="modal-text">Chips: <strong>${chipsNow}</strong> | Deck: <strong>${run.playerDeck.length}</strong></p>
      `;

      // Buy cards + inventory reroll (always visible)
      const canRerollInv = chipsNow >= rerollInvCost;
      body += `
        <div class="merchant-section">
          <div class="merchant-section-title">Buy Cards (Standard ${MERCHANT_BUY_BASE_STANDARD} flat Â· Mod ${MERCHANT_BUY_BASE_MOD}+ Â· +${MERCHANT_BUY_INCREMENT} per mod buy)</div>
          <div style="display:flex; justify-content:center; margin-bottom:12px;">
            <button class="modal-btn" ${canRerollInv ? '' : 'disabled'} onclick="rerollMerchantInventory()">Re-roll Inventory (${rerollInvCost})</button>
          </div>
          <div class="merchant-cards">
      `;

      merchantOffers.forEach((card, idx) => {
  const isMod = isModifier(card);
  const remaining = isMod ? getModifierRemaining(card.delta) : null;
  const soldOut = isMod && remaining <= 0;
  const slotCost = getMerchantBuyCost(card);
  const canBuy = (chipsNow >= slotCost) && !soldOut;
  const stockLine = isMod
    ? `<div style="margin-top:6px; font-size:12px; color:var(--text-muted);">${soldOut ? 'Sold out' : `Stock: ${remaining}/${MOD_PURCHASE_LIMIT_PER_DELTA}`}</div>`
    : '';

  body += `
    <div class="merchant-card-slot">
      ${renderCard(card, false)}
      ${stockLine}
      <button class="modal-btn" ${canBuy ? '' : 'disabled'} onclick="buyMerchantCard(${idx})">${soldOut ? 'Sold Out' : `Buy (${slotCost})`}</button>
    </div>
  `;
});

      body += '</div></div>';

      
// Removal section (cost paid on entry; reroll still allowed)
const removeCost = getMerchantRemovalCost();
const canEnterRemoval = chipsNow >= removeCost && run.playerDeck.length >= 3;

body += `
  <div class="merchant-section">
    <div class="merchant-section-title">Remove a Card (${removeCost})</div>
          ${removalMode ? `
            <p class="modal-text" style="margin-top:-4px; color: var(--text-muted);">
              Removal fee paid (<strong>${removalPaidCost}</strong>). No refund.
            </p>
          ` : `
            <button class="modal-btn danger" ${canEnterRemoval ? '' : 'disabled'} onclick="startRemoval()">Choose Card to Remove</button>
            <p class="modal-text" style="margin-top:10px; color: var(--text-muted);">Cost is deducted immediately when you enter removal mode.</p>
          `}
        </div>
      `;

      if (removalMode) {
        const removalRerollCost = getMerchantCost(REMOVAL_REROLL_COST);
        const canReroll = safeNumber(run.chips) >= removalRerollCost && run.playerDeck.length >= 1;

        body += `
          <div class="removal-picker">
            <p class="modal-text">Select a card to remove from your deck:</p>
            <div class="removal-cards">
        `;

        removalCandidates.forEach((data, idx) => {
          const card = data.card;
          const selected = selectedRemovalIdx === idx;
          body += `
            <div class="removal-card-option ${selected ? 'selected' : ''}" onclick="selectRemovalCard(${idx})">
              ${renderCard(card, false)}
            </div>
          `;
        });

        body += `
            </div>
            <div style="display:flex; justify-content:center; gap:12px; flex-wrap:wrap;">
              <button class="modal-btn" ${canReroll ? '' : 'disabled'} onclick="rerollRemoval()">Re-roll (${removalRerollCost})</button>
            </div>
          </div>
        `;
      }

      const buttons = [];
      if (removalMode) {
        buttons.push({
          text: 'Confirm Removal',
          primary: true,
          disabled: selectedRemovalIdx === null,
          action: confirmRemoval
        });
        buttons.push({ text: 'Exit Removal', action: cancelRemoval });
      } else {
        buttons.push({ text: 'Leave', action: () => { leaveMerchant(); } });
      }

      showModal('Merchant', body, buttons, { onClose: markMerchantKeyMissedIfOffered });
      renderHUD();
    }

    function markMerchantKeyMissedIfOffered() {
      if (!run || run.floor !== 2) return;
      const mk = run?.secret?.keys?.merchant;
      if (mk && mk.state === 'offered') mk.state = 'missed';
    }

    window.rerollMerchantInventory = function() {
      if (run && run.secret && run.secret.keys && run.floor === 2) {
        const mk = run.secret.keys.merchant;
        if (mk.state === 'offered') mk.state = 'missed';
      }
      const cost = getMerchantCost(MERCHANT_INVENTORY_REROLL_COST);
      if (run.chips < cost) return;
      run.chips -= cost;
      merchantOffers = [randomCard(), randomCard(), randomCard()];
      merchantOffers.forEach(card => assignUid(card));
      if (run && run.ui && run.ui.merchantContext) {
        run.ui.merchantContext.rerolls = safeNumber(run.ui.merchantContext.rerolls, 0) + 1;
        run.ui.merchantContext.offers = merchantOffers.map(c => cloneCard(c));
      }
      if (run.floor === 2 && run.secret && run.secret.keys) {
        const mk = run.secret.keys.merchant;
        mk.chance = Math.min(0.35, safeNumber(mk.chance, 0.05) + 0.03);
      }
      maybeInjectMerchantKey(merchantOffers);
      logEvent('MERCHANT_REROLL', { which: 'inventory', cost, offers: merchantOffers.map(cardRef) });
      renderMerchant();
      showToast(`Re-rolled inventory (-${cost})`);
    };

    window.buyMerchantCard = function(idx) {
  const ctx = run.ui.merchantContext;
  if (!ctx || !canShopPurchase(ctx.shopId)) {
    showToast('Purchase cap reached for this shop.');
    return;
  }

  const card = merchantOffers[idx];
  assignUid(card);
  const chipsBefore = run.chips;
  const cost = getMerchantBuyCost(card);
  if (run.chips < cost) return;

  // Per-run purchase limit on modifiers (-4..+4)
  if (isModifier(card) && getModifierRemaining(card.delta) <= 0) {
      showToast(`Sold out: ${cardToString(card)}`);
      logEvent('MODIFIER_SOLD_OUT', {
        floor: run.floor,
        card: cardToString(card),
        cardUid: card.uid || null,
        cardRef: cardRef(card),
        delta: card.delta,
        limit: MOD_PURCHASE_LIMIT_PER_DELTA,
        purchased: run.modPurchaseCounts[String(card.delta)]
      });
    renderMerchant();
    return;
  }

  run.chips -= cost;
  recordShopPurchase(ctx.shopId, { shopType: 'MERCHANT', kind: isModifier(card) ? 'MODIFIER' : 'STANDARD' });
  run.playerDeck.push(card);

  if (isKeyCard(card) && run.secret && run.secret.keys) {
    run.secret.keys.merchant.state = 'obtained';
    logEvent('KEYCARD_OBTAINED', { source: 'MERCHANT', card: cardRef(card), cost });
    recordDeckSnapshot('KEYCARD_MERCHANT');
  }

  if (isModifier(card)) {
    recordModifierPurchase(card.delta);
    run.merchantModifierBuys = safeNumber(run.merchantModifierBuys, 0) + 1;
  }

  logEvent('MERCHANT_BUY', {
    card: cardToString(card),
    cardUid: card.uid || null,
    cardRef: cardRef(card),
    cost,
    chipsBefore,
    chipsAfter: run.chips,
    isModifier: isModifier(card),
    modifierRemaining: isModifier(card) ? getModifierRemaining(card.delta) : null,
    deckSnapshot: deckSnapshot()
  });
  recordDeckSnapshot('MERCHANT_BUY');

  // Refresh that inventory slot
  merchantOffers[idx] = randomCard();
  assignUid(merchantOffers[idx]);
  maybeInjectMerchantKey(merchantOffers);

  renderMerchant();
  showToast(`Bought ${cardToString(card)}`);
};

    window.startRemoval = function() {
  const ctx = run.ui.merchantContext;
  if (!ctx || !canShopPurchase(ctx.shopId)) {
    showToast('Purchase cap reached for this shop.');
    return;
  }

  const cost = getMerchantRemovalCost();
  if (run.playerDeck.length < 3) return;

  const eligible = run.playerDeck
    .map((card, i) => ({ card, i }))
    .filter(d => !isKeyCard(d.card));
  if (eligible.length < 1) { showToast('No eligible cards to remove.'); return; }
  if (run.chips < cost) { showToast('Not enough chips.'); return; }

  // charge only after eligibility is confirmed
  run.chips -= cost;
  recordShopPurchase(ctx.shopId, { shopType: 'MERCHANT', kind: 'REMOVAL' });
  run.paidRemovalCount = safeNumber(run.paidRemovalCount, 0) + 1;
  removalPaidCost = cost;

  const picks = shuffle(eligible.slice()).slice(0, Math.min(3, eligible.length));
  removalCandidates = picks.map(d => ({ card: d.card }));
  removalMode = true;
  selectedRemovalIdx = null;

  logEvent('MERCHANT_REMOVE_START', {
    cost,
    removalCount: run.paidRemovalCount,
    candidates: removalCandidates.map(x => cardRef(x.card))
  });

  renderMerchant();
  showToast(`Removal started (-${cost})`);
};

    window.rerollRemoval = function() {
      if (!removalMode) return;
      const cost = getMerchantCost(REMOVAL_REROLL_COST);
      if (run.chips < cost) return;
      run.chips -= cost;

      const eligible = run.playerDeck
        .map((card, i) => ({ card, i }))
        .filter(d => !isKeyCard(d.card));
      const picks = shuffle(eligible.slice()).slice(0, Math.min(3, eligible.length));
      removalCandidates = picks.map(d => ({ card: d.card }));
      selectedRemovalIdx = null;

      logEvent('MERCHANT_REROLL', { which: 'removal', cost, candidates: removalCandidates.map(x => cardRef(x.card)) });

      renderMerchant();
      showToast(`Re-rolled removal (-${cost})`);
    };

    window.selectRemovalCard = function(idx) {
      selectedRemovalIdx = idx;
      renderMerchant();
    };

    window.confirmRemoval = function() {
      if (selectedRemovalIdx === null) return;

      const data = removalCandidates[selectedRemovalIdx];
      if (isKeyCard(data.card)) return;
      const idx = run.playerDeck.indexOf(data.card);
      if (idx !== -1) {
        run.playerDeck.splice(idx, 1);
        logEvent('MERCHANT_REMOVE_CONFIRM', { card: cardToString(data.card), cardUid: data.card.uid || null, cardRef: cardRef(data.card), deckSnapshot: deckSnapshot() });
        recordDeckSnapshot('MERCHANT_REMOVE_CONFIRM');
        showToast(`Removed ${cardToString(data.card)} from deck`);
      } else {
        logEvent('MERCHANT_REMOVE_CONFIRM', { card: cardToString(data.card), cardUid: data.card.uid || null, cardRef: cardRef(data.card), result: 'not_found' });
        showToast(`Card no longer available to remove`);
      }

      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;

      renderMerchant();
    };

    window.cancelRemoval = function() {
      logEvent('MERCHANT_REMOVE_EXIT', {});
      removalMode = false;
      removalCandidates = [];
      selectedRemovalIdx = null;
      renderMerchant();
    };

    function maybeInjectMerchantKey(offers) {
      if (!run || run.floor !== 2 || !run.secret || !run.secret.keys) return;
      const mk = run.secret.keys.merchant;
      if (mk.state === 'missed' || mk.state === 'obtained') return;
      const already = offers.some(isKeyCard);
      if (already) return;
      const chance = safeNumber(mk.chance, 0.05);
      if (Math.random() < chance) {
        const slot = Math.floor(Math.random() * offers.length);
        const key = makeKeyCard('MERCHANT');
        assignUid(key);
        offers[slot] = key;
        mk.state = 'offered';
      }
    }

    function leaveMerchant() {
      if (run && run.secret && run.secret.keys && run.floor === 2) {
        const mk = run.secret.keys.merchant;
        if (mk.state === 'offered') mk.state = 'missed';
      }
      closeModal();
      renderAll();
    }

    // Blackjack encounters
    function encounterBlackjackStandard() {
      if (run.chips < BUYIN_STANDARD) {
        logEvent('MATCH_START_FAILED', { type: 'STANDARD', buyIn: BUYIN_STANDARD, chips: run.chips, reason: 'INSUFFICIENT_CHIPS' });
        gameOver("You can't afford the buy-in.", 'INSUFFICIENT_BUYIN');
        return;
      }
      startBlackjackMatch('STANDARD', BUYIN_STANDARD);
    }

    function encounterBlackjackHigh() {
      if (run.chips < BUYIN_HIGH) {
        logEvent('MATCH_START_FAILED', { type: 'HIGH_STAKES', buyIn: BUYIN_HIGH, chips: run.chips, reason: 'INSUFFICIENT_CHIPS' });
        gameOver("You can't afford the buy-in.", 'INSUFFICIENT_BUYIN');
        return;
      }
      const hsKey = run.secret && run.secret.keys ? run.secret.keys.highStakes : null;
      const specialReward = (hsKey && !hsKey.obtained && run.board.currentTileId === hsKey.tileId) ? 'KEY_HIGH' : null;
      startBlackjackMatch('HIGH_STAKES', BUYIN_HIGH, { specialReward });
    }

    function encounterBoss() {
      if (run.floor === 3 && run.loan && run.loan.active && !run.loan.repaid) {
        const owed = LOAN_REPAY;
        const canRepayNow = run.chips >= owed;

        showModal(
          'Debt Due',
          `
            <div class="modal-text">
              You owe the Loan Shark <b>${owed}</b> chips.<br/>
              Repay before the final boss or youâ€™ll be turned away.
            </div>
          `,
          [
            {
              text: `Repay ${owed} & Enter`,
              primary: true,
              disabled: !canRepayNow,
              action: () => {
                repayLoan('BOSS_GATE');
                closeModal();
                encounterBoss_startFight();
              }
            },
            {
              text: 'Back',
              action: () => { closeModal(); renderAll(); }
            },
            {
              text: 'Enter Without Repaying',
              danger: true,
              action: () => {
                closeModal();
                logEvent('LOAN_DEFAULTED', { floor: run.floor, amountOwed: owed, at: 'BOSS_ENTRANCE' });
                gameOver(`You entered the final boss without repaying ${owed} chips.`, 'LOAN_DEFAULTED');
              }
            }
          ]
        );
        return;
      }
      encounterBoss_startFight();
    }

    function encounterBoss_startFight() {
      if (run.chips < BUYIN_BOSS) {
        logEvent('MATCH_START_FAILED', { type: 'BOSS', buyIn: BUYIN_BOSS, chips: run.chips, reason: 'INSUFFICIENT_CHIPS' });
        gameOver("You can't afford the buy-in.", 'INSUFFICIENT_BUYIN');
        return;
      }
      startBossFight();
    }

    function startBossFight() {

      run.bossFight = {
        active: true,
        floor: run.floor,
        round: 1,
        maxRounds: 3,
        roundsRemaining: 3,
        maxHp: 100,
        hp: 100,
        phase: 1,
        targetLaneIdx: null,
        benchCarry: [],
        phase2Announced: false
      };
      logEvent('BOSS_FIGHT_START', {
        floor: run.floor,
        round: 1,
        maxRounds: 3,
        roundsRemaining: 3,
        hp: run.bossFight.hp,
        maxHp: run.bossFight.maxHp
      });
      startBossRound(1);
    }

    function startBossRound(roundIdx) {
      const bf = run.bossFight;
      if (!bf) return;
      bf.round = roundIdx;
      const buyIn = roundIdx === 1 ? BUYIN_BOSS : 0;
      startBlackjackMatch('BOSS', buyIn, {
        initialBench: bf.benchCarry || []
      });
      blackjackMatch.bossRound = bf.round;
      blackjackMatch.bossMaxRounds = bf.maxRounds;
      logEvent('BOSS_ROUND_START', {
        round: bf.round,
        maxRounds: bf.maxRounds,
        hp: bf.hp,
        maxHp: bf.maxHp,
        phase: bf.phase
      });
      if (bf.phase === 2 && !bf.phase2Announced) {
        bf.phase2Announced = true;
        showToast("Surveillance Online â€” Countermeasures active.");
        logEvent('BOSS_PHASE2_START', { hp: bf.hp, maxHp: bf.maxHp, round: bf.round });
      }
      if (bf.phase === 2) updateThreatTargetLane(true, 'round_start');
    }

    const AI_PROFILES = {
      ACCOUNTANT: {
        id: 'ACCOUNTANT',
        verb: 'counts the margins',
        standShift: +1,
        riskMult: 1.20,
        winBonusMult: 1.00,
        closeBonusMult: 1.00,
        spreadPenalty: 0.0,
        focusStrength: 0.0,
        raiseDelta: -0.15,
        benchEarlyMult: 0.75,
        benchLateMult: 0.85,
        salvageMult: 0.90,
        jitter: 0.10,
        quirkLaneWeight: 1.2
      },
      CLOSER: {
        id: 'CLOSER',
        verb: 'closes lanes early',
        standShift: +2,
        riskMult: 1.05,
        winBonusMult: 1.20,
        closeBonusMult: 1.15,
        spreadPenalty: 0.0,
        focusStrength: 0.15,
        raiseDelta: -0.05,
        benchEarlyMult: 0.90,
        benchLateMult: 0.85,
        salvageMult: 0.90,
        jitter: 0.15,
        quirkLaneWeight: 1.0
      },
      SNIPER: {
        id: 'SNIPER',
        verb: 'targets a lane',
        standShift: 0,
        riskMult: 1.00,
        winBonusMult: 1.10,
        closeBonusMult: 1.05,
        spreadPenalty: 0.0,
        focusStrength: 1.0,
        focusMode: 'WEAKEST_PLAYER',
        raiseDelta: +0.05,
        benchEarlyMult: 1.00,
        benchLateMult: 1.00,
        salvageMult: 1.00,
        jitter: 0.20,
        quirkLaneWeight: 1.2
      },
      PRESSURIZER: {
        id: 'PRESSURIZER',
        verb: 'applies Pressure',
        standShift: -2,
        riskMult: 0.90,
        winBonusMult: 1.00,
        closeBonusMult: 0.95,
        spreadPenalty: 1.2,
        focusStrength: 0.0,
        raiseDelta: +0.15,
        benchEarlyMult: 1.35,
        benchLateMult: 1.10,
        salvageMult: 1.10,
        jitter: 0.25,
        quirkLaneWeight: 1.0
      },
      GAMBLER: {
        id: 'GAMBLER',
        verb: 'takes risks',
        standShift: -1,
        riskMult: 0.75,
        winBonusMult: 1.00,
        closeBonusMult: 1.00,
        spreadPenalty: 0.5,
        focusStrength: 0.0,
        raiseDelta: +0.20,
        benchEarlyMult: 1.00,
        benchLateMult: 1.00,
        salvageMult: 1.00,
        jitter: 0.90,
        quirkLaneWeight: 1.4
      },
      TRICKSTER: {
        id: 'TRICKSTER',
        verb: 'plays it late',
        standShift: -1,
        riskMult: 0.95,
        winBonusMult: 1.05,
        closeBonusMult: 1.00,
        spreadPenalty: 0.6,
        focusStrength: 0.70,
        focusMode: 'PUNISH_COMPLETES',
        raiseDelta: +0.10,
        benchEarlyMult: 0.55,
        benchLateMult: 1.55,
        salvageMult: 1.35,
        jitter: 0.35,
        quirkLaneWeight: 1.3
      }
    };

    const AI_PROFILE_WEIGHTS = {
      STANDARD: [
        ['ACCOUNTANT', 0.26],
        ['CLOSER',     0.22],
        ['SNIPER',     0.16],
        ['PRESSURIZER',0.14],
        ['TRICKSTER',  0.12],
        ['GAMBLER',    0.10]
      ],
      HIGH_STAKES: [
        ['PRESSURIZER',0.24],
        ['GAMBLER',    0.22],
        ['TRICKSTER',  0.18],
        ['SNIPER',     0.18],
        ['CLOSER',     0.10],
        ['ACCOUNTANT', 0.08]
      ]
    };

    function pickWeighted(pairs) {
      const r = Math.random();
      let acc = 0;
      for (const [k, w] of pairs) {
        acc += w;
        if (r <= acc) return k;
      }
      return pairs[pairs.length - 1][0];
    }

    function getDealerProfile() {
      if (!blackjackMatch) return AI_PROFILES.ACCOUNTANT;
      return blackjackMatch.aiProfile || AI_PROFILES.ACCOUNTANT;
    }

    // =============================================
    // SLOT BLACKJACK ENGINE
    // =============================================
    function getTransferMultiplierLimits(type) {
      if (type === 'BOSS') return { min: 2, max: 5 };
      if (type === 'HIGH_STAKES') return { min: 1, max: 4 };
      return { min: 1, max: 3 };
    }

    function startBlackjackMatch(type, buyIn, options = {}) {
      clearDealerTimers();

      run.chips -= buyIn;
      if (buyIn > 0) { try { if (window.SFX) SFX.play('bench_add'); } catch(e){} }
      run.matchSeq = safeNumber(run.matchSeq, 0) + 1;

      const playerDrawPile = shuffle(run.playerDeck.slice());

      // Dealer deck = standard 52 + random bench modifiers (2/4/6 by floor)
      const dealerBaseDeck = options.dealerDeckOverride ? options.dealerDeckOverride.slice() : makeStandardDeck52();
      const extraMods = options.dealerDeckOverride ? 0 : Math.max(0, Math.min(20, safeNumber(run.floor, 1) * 2)); // F1=2, F2=4, F3=6
      for (let i = 0; i < extraMods; i++) {
        const delta = MODIFIER_DELTAS[Math.floor(Math.random() * MODIFIER_DELTAS.length)];
        dealerBaseDeck.push({ type: 'MOD', delta });
      }
      const dealerDrawPile = shuffle(dealerBaseDeck.slice());

      // load tokens: base by floor + from bank
      // Floor 1=2, Floor 2=3, Floor 3=4
      const baseTokens = Math.max(2, safeNumber(run.floor, 1) + 1);
      const banked = run.bankedTokens || 0;
      const addFromBank = Math.min(banked, ACTION_TOKEN_MAX_BANKED);
      const tokensTotal = baseTokens + addFromBank;
      run.bankedTokens = Math.max(0, banked - addFromBank);

      blackjackMatch = {
        type,
        buyIn,
        matchSeq: run.matchSeq,
        npc: null,
        playerPositions: [],
        dealerPositions: [],
        playerDrawPile,
        dealerDrawPile,

        // NEW: dealer base deck + dealer bench
        dealerBaseDeck,
        dealerBench: [],

        drawnCard: null,
        turn: 'player',
        phase: 'betting',
        result: null,

        // Bench (player mods + normal cards)
        bench: options.initialBench ? options.initialBench.slice() : [],
        armedBenchIdx: null,

        // bonuses + transfers
        bonusAll21Awarded: false,
        bonusChipsEarned: 0,
        transferChipsNet: 0,
        transferMultiplier: null,
        transferMultiplierMin: null,
        transferMultiplierMax: null,
        transferMultiplierStage: 'player',
        transferRaiseOffer: null,
        callingProcChance: CALLING_PROC_CHANCE,
        spadePeekLanes: new Set(),
        lastCallingSuitPlay: null,
        scoreSeq: null,
        earningsSeq: null,
        procBanner: null,
        specialReward: options.specialReward || null,
        watcherTargetLaneIdx: null,
        traps: {
          player: Array(LANE_COUNT).fill(0),
          dealer: Array(LANE_COUNT).fill(0)
        },

        // Action tokens + action usage
        tokensTotal,
        tokensSpent: 0,
        autoPassToEnd: false,
        usedActions: {},
        actionUsedThisTurn: false,
        actionSelectionInProgress: false,

        // Action effects state
        spyReveals: new Set(),
        dealerForcedLane: null,
        pending: null,
        rewardPending: false,
        winnerReward: null,
        exhaustion: null,
        burnedSleeveCards: [],

        metrics: {
          startedAtMs: performance.now(),
          turns: 0,
          playerDraws: 0,
          dealerDraws: 0,
          playerStands: 0,
          dealerStands: 0,
          playerBustsFinal: 0,
          dealerBustsFinal: 0,
          modifiersBenched: 0,
          benchModsToPlayer: 0,
          benchModsToDealer: 0,
          benchCardsPlaced: 0,
          actionsUsed: 0,

          // NEW: dealer bench tracking
          dealerModifiersBenched: 0,
          dealerBenchModsUsed: 0,

          initialDealComplete: false,
          laneCards: {
            playerTotal: Array(LANE_COUNT).fill(0),
            dealerTotal: Array(LANE_COUNT).fill(0),
            playerAfterInitial: Array(LANE_COUNT).fill(0),
            dealerAfterInitial: Array(LANE_COUNT).fill(0)
          }
        }
      };

      const limits = getTransferMultiplierLimits(type);
      blackjackMatch.transferMultiplier = limits.min;
      blackjackMatch.transferMultiplierMin = limits.min;
      blackjackMatch.transferMultiplierMax = limits.max;

      const currentTile = run.board.tiles[run.board.currentTileId];
      const npc = options.npcOverride || (currentTile ? currentTile.npc : null);
      blackjackMatch.npc = npc;

      let profileId = (npc && npc.aiProfileId) ? npc.aiProfileId : 'ACCOUNTANT';
      if (options && options.aiProfileId) profileId = options.aiProfileId;

      blackjackMatch.aiProfileId = profileId;
      blackjackMatch.aiProfile = AI_PROFILES[profileId] || AI_PROFILES.ACCOUNTANT;
      blackjackMatch.aiQuirkBias = (npc && Array.isArray(npc.aiQuirkBias)) ? npc.aiQuirkBias.slice() : Array.from({ length: LANE_COUNT }, () => 0);
      blackjackMatch.aiRaiseQuirk = (npc && typeof npc.aiRaiseQuirk === 'number') ? npc.aiRaiseQuirk : 0;
      blackjackMatch.aiFocusLane = null;

      if (npc && blackjackMatch.aiProfile && blackjackMatch.aiProfile.verb) {
        showToast(`${npc.name} ${blackjackMatch.aiProfile.verb}.`);
      }
      if (blackjackMatch.type === 'HIGH_STAKES') {
        showToast(`High Stakes rule: Karma x${HIGH_STAKES_KARMA_MULT}`);
      }

      let affinity = 'neutral';
      let edgeDelta = 0;
      let procChance = CALLING_PROC_CHANCE;
      if (npc && run.callingCard) {
        affinity = getAffinity(run.callingCard.suit, npc.callingCard.suit);
        edgeDelta = rankToValue(run.callingCard.rank) - rankToValue(npc.callingCard.rank);
        const affinityMod = affinity === 'resonant' ? 0.10 : (affinity === 'dissonant' ? -0.10 : 0);
        const edgeMod = Math.max(-0.12, Math.min(0.12, edgeDelta * 0.01));
        procChance = Math.max(0.10, Math.min(0.90, CALLING_PROC_CHANCE + affinityMod + edgeMod));
      }
      blackjackMatch.callingProcChance = procChance;
      blackjackMatch.affinity = affinity;
      blackjackMatch.edgeDelta = edgeDelta;

      logEvent('MATCH_START', {
        type,
        buyIn,
        matchSeq: blackjackMatch.matchSeq,
        baseTokens,
        tokensTotal,
        bankedTokensUsed: addFromBank,
        bankedTokensRemaining: run.bankedTokens,
        dealerExtraMods: extraMods,
        transferMultiplierMin: limits.min,
        transferMultiplierMax: limits.max,
        npcName: npc ? npc.name : null,
        npcCallingCard: npc ? npc.callingCard : null,
        affinity,
        edgeDelta,
        callingProcChance: procChance,
        deckSnapshot: deckSnapshot()
      });

      run.ui.mode = 'BLACKJACK';

      // Initialize 5 positions each
      for (let i = 0; i < LANE_COUNT; i++) {
        blackjackMatch.playerPositions.push({
          cards: [],
          mods: [],
          lastPlay: null,
          isOpen: i < 3,
          isComplete: false,
          isBust: false,
          bonus21Awarded: false,
          lastPlayedCard: null,
          lastPlayedAttackValue: 0,
          attackFired: false,
          pendingFusionUid: null,
          eraserCharges: 0
        });
        blackjackMatch.dealerPositions.push({
          cards: [],
          mods: [],
          lastPlay: null,
          isOpen: i < 3,
          isComplete: false,
          isBust: false,
          lastPlayedCard: null,
          lastPlayedAttackValue: 0,
          attackFired: false,
          pendingFusionUid: null,
          eraserCharges: 0
        });
      }

      // Deal initial cards (modifiers never go into lane hands)
      for (let i = 0; i < 3; i++) {
        const okP = dealToPosition(blackjackMatch.playerPositions[i], blackjackMatch.playerDrawPile, run.playerDeck, 'player', i);
        if (!okP) { triggerDeckExhaustion('player', 'initial-deal'); return; }
        maybeAward21BonusForPlayerPos(i);

        const okD = dealToPosition(blackjackMatch.dealerPositions[i], blackjackMatch.dealerDrawPile, dealerBaseDeck, 'dealer', i);
        if (!okD) { triggerDeckExhaustion('dealer', 'initial-deal'); return; }
      }

      blackjackMatch.metrics.initialDealComplete = true;
      run.ui.mode = 'BLACKJACK';
      if (run.ui) run.ui.hudCollapsed = true;
      renderAll();
    }

    window.setTransferMultiplier = function(multiplier) {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'player') return;
      const min = blackjackMatch.transferMultiplierMin || 1;
      const max = blackjackMatch.transferMultiplierMax || 1;
      if (multiplier < min || multiplier > max) return;
      blackjackMatch.transferMultiplier = multiplier;
      blackjackMatch.transferMultiplierStage = 'dealer';
      resolveDealerTransferDecision();
    };

    function resolveDealerTransferDecision() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'dealer') return;
      const current = blackjackMatch.transferMultiplier || 1;
      const max = blackjackMatch.transferMultiplierMax || current;
      const canRaise = current < max;
      const prof = getDealerProfile();
      const diff = getOpponentDifficulty();
      const base = (blackjackMatch.type === 'HIGH_STAKES') ? 0.55 : 0.35;
      const diffAdj = (diff === 'hard') ? 0.10 : (diff === 'easy' ? -0.10 : 0);
      const profAdj = safeNumber(prof.raiseDelta, 0);
      const quirkAdj = safeNumber(blackjackMatch.aiRaiseQuirk, 0);
      let p = base + diffAdj + profAdj + quirkAdj;
      p = Math.max(0.05, Math.min(0.90, p));
      const willRaise = canRaise && Math.random() < p;

      if (willRaise) {
        blackjackMatch.transferRaiseOffer = current + 1;
        blackjackMatch.transferMultiplierStage = 'response';
        logEvent('TRANSFER_BET', { playerMultiplier: current, dealerAction: 'raise', offer: blackjackMatch.transferRaiseOffer });
      } else {
        logEvent('TRANSFER_BET', { playerMultiplier: current, dealerAction: 'call' });
        finishTransferBetting();
      }
      renderBlackjack();
    }

    window.acceptTransferRaise = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'response') return;
      blackjackMatch.transferMultiplier = blackjackMatch.transferRaiseOffer || blackjackMatch.transferMultiplier;
      logEvent('TRANSFER_BET_RESPONSE', { response: 'accept', finalMultiplier: blackjackMatch.transferMultiplier });
      finishTransferBetting();
    };

    window.declineTransferRaise = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'betting') return;
      if (blackjackMatch.transferMultiplierStage !== 'response') return;
      logEvent('TRANSFER_BET_RESPONSE', { response: 'decline', finalMultiplier: blackjackMatch.transferMultiplier });
      finishTransferBetting();
    };

    function finishTransferBetting() {
      blackjackMatch.transferRaiseOffer = null;
      blackjackMatch.transferMultiplierStage = 'done';
      blackjackMatch.phase = 'playing';
      blackjackMatch.turn = 'player';
      renderBlackjack();
      showToast(`Transfer multiplier locked at x${blackjackMatch.transferMultiplier}`);
    }


    function drawCardFromPile(pile) {
      if (!pile || pile.length === 0) return null;
      return pile.pop();
    }

    // Draw until a NON-modifier is found. Any modifiers drawn are benched (player side).
// Draw until a NON-modifier is found.
// Player: any modifiers drawn are benched.
// Dealer: any modifiers drawn go to dealerBench (not revealed), then draw continues.
    function drawNonModifierCard(pile, fallbackDeck, side) {
      let safety = 0;
      while (safety++ < 300) {
        const fb = (side === 'dealer' && blackjackMatch && blackjackMatch.dealerBaseDeck)
          ? blackjackMatch.dealerBaseDeck
          : fallbackDeck;

        const c = drawCardFromPile(pile, fb);
        if (!c) return null;
        if (isModifier(c) || (side === 'player' && c && c.sleeveId === 'BLUE')) {
          if (blackjackMatch) {
            if (side === 'player') {
              const src = isModifier(c) ? 'auto-bench' : 'blue-sleeve-deal';
              benchPush(c, src);
              blackjackMatch.metrics.modifiersBenched += 1;
              logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: src });
            } else if (side === 'dealer') {
              blackjackMatch.dealerBench = blackjackMatch.dealerBench || [];
              blackjackMatch.dealerBench.push(c);
              blackjackMatch.metrics.dealerModifiersBenched = safeNumber(blackjackMatch.metrics.dealerModifiersBenched, 0) + 1;
              logEvent('DEALER_BENCH_GAIN', { card: cardToString(c), source: 'dealer-draw' });
            }
          }
          continue;
        }
        return c;
      }
      return null;
    }


    function dealToPosition(pos, pile, fallbackDeck, side, laneIdx) {
      const a = drawNonModifierCard(pile, fallbackDeck, side);
      const b = drawNonModifierCard(pile, fallbackDeck, side);
      if (!a || !b) return false;

      pos.cards.push(a);
      handleFusionOnCardPlaced(pos, a);

      pos.cards.push(b);
      const placed = handleFusionOnCardPlaced(pos, b);

      pos.lastPlay = { kind: 'card', rank: b.rank, value: getStrikeValueFromCard(placed) };
      if (side === 'dealer') onCardPlacedForAttack(pos, placed);
      recordLaneCard(side, laneIdx, 1);
      recordLaneCard(side, laneIdx, 1);
      return true;
    }

    function getPositionTotal(pos) {
      const modSum = (pos.mods || []).reduce((a, b) => a + b, 0);
      const transformed = (pos.cards || []).map(card => {
        if (!card) return card;
        if (card.sleeveId !== 'NEGATIVE') return card;
        const clone = { ...card, rank: card.rank };
        if (isFused(card)) return card;
        const val = getCardValueOptions(card)[0] || 0;
        return { ...clone, __negValue: -Math.abs(val) };
      });
      const base = calcBestTotal(transformed, modSum);
      return safeNumber(base, 0);
    }

    function getStrikeValueFromCard(card) {
      if (!card || isModifier(card)) return 0;
      if (isFused(card)) {
        const options = getCardValueOptions(card);
        if (options.includes(11)) return 11;
        return options.length ? Math.min(10, Math.max(...options)) : 0;
      }
      if (card.rank === 'A') return 11;
      if (['J', 'Q', 'K'].includes(card.rank)) return 10;
      const n = Number(card.rank);
      return Number.isFinite(n) ? Math.min(10, n) : 0;
    }

    function getAttackValueFromCard(card) {
      if (!card) return 0;
      if (isModifier(card)) return Math.abs(safeNumber(card.delta, 0));
      return Math.min(11, Math.max(0, getStrikeValueFromCard(card)));
    }

    function onCardPlacedForAttack(pos, card) {
      if (!pos || !card) return;
      pos.lastPlayedCard = card;
      pos.lastPlayedAttackValue = getAttackValueFromCard(card);
    }

    function tryFireCloseAttack(attackerSide, laneIdx) {
      if (!blackjackMatch) return;
      const a = attackerSide === 'player' ? blackjackMatch.playerPositions[laneIdx] : blackjackMatch.dealerPositions[laneIdx];
      const d = attackerSide === 'player' ? blackjackMatch.dealerPositions[laneIdx] : blackjackMatch.playerPositions[laneIdx];
      if (!a || !d) return;
      if (a.attackFired) return;
      if (d.isComplete) return;
      const dmg = safeNumber(a.lastPlayedAttackValue, 0);
      if (!dmg) return;
      d.mods = d.mods || [];
      d.mods.push(-dmg);
      a.attackFired = true;
      if (!blackjackMatch.metrics) blackjackMatch.metrics = {};
      if (attackerSide === 'player') blackjackMatch.metrics.playerAttackDealt = safeNumber(blackjackMatch.metrics.playerAttackDealt, 0) + dmg;
      else blackjackMatch.metrics.dealerAttackDealt = safeNumber(blackjackMatch.metrics.dealerAttackDealt, 0) + dmg;
      logEvent('LANE_CLOSE_ATTACK', { attacker: attackerSide, lane: laneIdx + 1, damage: dmg, card: a.lastPlayedCard ? cardToString(a.lastPlayedCard) : null });
      showToast(`${attackerSide === 'player' ? 'Attack dealt' : 'Attack taken'}: lane #${laneIdx + 1} ${dmg}`);
    }

    function computeStrikeDeltaFromLastPlay(lastPlay) {
      if (!lastPlay) return 0;
      if (lastPlay.kind === 'mod') return -lastPlay.delta;
      if (lastPlay.kind === 'card') return -safeNumber(lastPlay.value, 0);
      return 0;
    }

    function applyLaneMod(side, laneIdx, delta) {
      const positions = side === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const pos = positions[laneIdx];
      if (!pos) { try { if (window.SFX) SFX.play('mod_block'); } catch(e){} return 'invalid'; }
      if (pos.isComplete) { try { if (window.SFX) SFX.play('mod_block'); } catch(e){} return 'closed'; }
      if (!pos.isOpen) {
        blackjackMatch.traps[side][laneIdx] += delta;
        try { if (window.SFX) SFX.play('mod_block'); } catch(e){}
        return 'unopened';
      }
      if ((pos.eraserCharges || 0) > 0) {
        pos.eraserCharges -= 1;
        try { if (window.SFX) SFX.play('mod_block'); } catch(e){}
        return 'erased';
      }
      pos.mods = pos.mods || [];
      pos.mods.push(delta);
      try { if (window.SFX) SFX.play('mod', { delta }); } catch(e){}
      return 'open';
    }

    function tryTempoStrike(attackerSide, laneIdx, reason) {
      if (!blackjackMatch) return;
      const attackerPositions = attackerSide === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const targetSide = attackerSide === 'dealer' ? 'player' : 'dealer';
      const targetPositions = targetSide === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const attackerPos = attackerPositions[laneIdx];
      const targetPos = targetPositions[laneIdx];
      if (!attackerPos || !targetPos) return;
      if (!attackerPos.isComplete || attackerPos.isBust) return;

      const delta = computeStrikeDeltaFromLastPlay(attackerPos.lastPlay);
      if (!delta) return;

      if (targetPos.isComplete) {
        logEvent('TEMPO_STRIKE_BLOCKED', {
          attacker: attackerSide,
          lane: laneIdx + 1,
          delta,
          lastPlay: attackerPos.lastPlay,
          targetState: 'closed',
          trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
          reason
        });
        return;
      }

      if (attackerSide === 'dealer' && targetSide === 'player' && laneHasSleeve(targetPos, 'STEEL')) {
        logEvent('TEMPO_STRIKE_BLOCKED', {
          attacker: attackerSide,
          lane: laneIdx + 1,
          delta,
          lastPlay: attackerPos.lastPlay,
          targetState: 'blocked_steel',
          trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
          reason
        });
        return;
      }

      const targetState = applyLaneMod(targetSide, laneIdx, delta);
      const eventType = (targetState === 'unopened') ? 'TEMPO_STRIKE_TRAP_SET' : 'TEMPO_STRIKE_APPLIED';
      logEvent(eventType, {
        attacker: attackerSide,
        lane: laneIdx + 1,
        delta,
        lastPlay: attackerPos.lastPlay,
        targetState,
        trapTotalAfter: blackjackMatch.traps[targetSide][laneIdx],
        reason
      });
    }

    function bossUpdateTargetLane(force = false, reason = '') {
      const bf = run && run.bossFight;
      if (!bf || !bf.active || bf.phase !== 2) return;

      const current = bf.targetLaneIdx;
      if (!force && current !== null) {
        const curPos = blackjackMatch.playerPositions[current];
        if (curPos && curPos.isOpen && !curPos.isComplete) return;
      }

      let best = null;
      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const p = blackjackMatch.playerPositions[i];
        if (!p.isOpen || p.isComplete) continue;
        const t = getPositionTotal(p);
        const diff = (t <= 21) ? (21 - t) : (1000 + (t - 21));
        const score = diff * 100 - t;
        if (!best || score < best.score) best = { i, score, t, diff };
      }

      bf.targetLaneIdx = best ? best.i : null;
      logEvent('BOSS_TARGET_SET', { laneIdx: bf.targetLaneIdx, reason });
    }

    function watcherUpdateTargetLane(force = false, reason = '') {
      if (!blackjackMatch || blackjackMatch.type !== 'WATCHER') return;
      const current = blackjackMatch.watcherTargetLaneIdx;
      if (!force && current !== null) {
        const curPos = blackjackMatch.playerPositions[current];
        if (curPos && curPos.isOpen && !curPos.isComplete) return;
      }
      let best = null;
      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const p = blackjackMatch.playerPositions[i];
        if (!p.isOpen || p.isComplete) continue;
        const t = getPositionTotal(p);
        const diff = (t <= 21) ? (21 - t) : (1000 + (t - 21));
        const score = diff * 100 - t;
        if (!best || score < best.score) best = { i, score };
      }
      blackjackMatch.watcherTargetLaneIdx = best ? best.i : null;
      logEvent('WATCHER_TARGET_SET', { laneIdx: blackjackMatch.watcherTargetLaneIdx, reason });
    }

    function updateThreatTargetLane(force = false, reason = '') {
      if (run && run.bossFight && run.bossFight.active) return bossUpdateTargetLane(force, reason);
      if (blackjackMatch && blackjackMatch.type === 'WATCHER') return watcherUpdateTargetLane(force, reason);
    }

    function bossTryCountermeasure() {
      const bf = run && run.bossFight;
      if (!bf || !bf.active || bf.phase !== 2) return false;
      if (bf.targetLaneIdx === null) bossUpdateTargetLane(true, 'countermeasure_no_target');
      let targetIdx = bf.targetLaneIdx;
      let targetPos = (targetIdx !== null) ? blackjackMatch.playerPositions[targetIdx] : null;
      if (!targetPos || !targetPos.isOpen || targetPos.isComplete) {
        bossUpdateTargetLane(true, 'countermeasure_retarget');
        targetIdx = bf.targetLaneIdx;
        targetPos = (targetIdx !== null) ? blackjackMatch.playerPositions[targetIdx] : null;
      }
      if (!targetPos || !targetPos.isOpen || targetPos.isComplete) return false;

      const bench = blackjackMatch.dealerBench || [];
      if (!bench.length) return false;

      const laneIdx = targetIdx;
      const p = targetPos;
      if (laneHasSleeve(p, 'STEEL')) {
        logEvent('BOSS_COUNTERMEASURE', {
          lane: laneIdx + 1,
          dealerBenchMod: null,
          appliedDelta: 0,
          targetState: 'blocked_steel'
        });
        return false;
      }
      const cur = getPositionTotal(p);

      let pick = 0;
      let bestScore = -Infinity;
      for (let i = 0; i < bench.length; i++) {
        const m = bench[i];
        if (!isModifier(m)) continue;
        const applied = -m.delta;
        const next = cur + applied;
        const bust = next > 21 ? 1 : 0;
        const away = (next <= 21) ? (21 - next) : (50 + (next - 21));
        const score = (bust ? 1000 : 0) - away;
        if (score > bestScore) { bestScore = score; pick = i; }
      }

      const mod = bench[pick];
      const appliedDelta = -mod.delta;
      const state = applyLaneMod('player', laneIdx, appliedDelta);
      if (state !== 'open' && state !== 'erased') return false;

      bench.splice(pick, 1);

      logEvent('BOSS_COUNTERMEASURE', {
        lane: laneIdx + 1,
        dealerBenchMod: cardRef(mod),
        appliedDelta,
        targetState: state
      });
      showToast(`Countermeasure: Lane ${laneIdx + 1}`);
      return true;
    }

    function recordLaneCard(side, laneIdx, count = 1, afterInitial = null) {
      if (!blackjackMatch || !blackjackMatch.metrics || laneIdx === null || laneIdx === undefined) return;
      const laneCards = blackjackMatch.metrics.laneCards;
      if (!laneCards || laneIdx < 0 || laneIdx > 4) return;
      const isAfterInitial = afterInitial !== null ? afterInitial : !!blackjackMatch.metrics.initialDealComplete;
      if (side === 'dealer') {
        laneCards.dealerTotal[laneIdx] += count;
        if (isAfterInitial) laneCards.dealerAfterInitial[laneIdx] += count;
      } else {
        laneCards.playerTotal[laneIdx] += count;
        if (isAfterInitial) laneCards.playerAfterInitial[laneIdx] += count;
      }
    }

    // bust is finalized only at end-of-turn (or when explicitly closes a lane)
    function finalizeBusts(positions, side) {
      for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        if (!pos.isOpen) continue;
        if (pos.isComplete) continue;
        const total = getPositionTotal(pos);
        if (total > 21) {
          pos.isBust = true;
          pos.isComplete = true;
        }
      }
    }


    function countOpenPositions(positions) {
      return positions.filter(p => p.isOpen && !p.isComplete).length;
    }

    function anyOpenIncomplete(positions) {
      return positions.some(p => p.isOpen && !p.isComplete);
    }

    function openNextPosition(positions, pile, fallbackDeck, side) {
      for (let i = 0; i < positions.length; i++) {
        if (!positions[i].isOpen) {
          positions[i].isOpen = true;
          const ok = dealToPosition(positions[i], pile, fallbackDeck, side, i);
          if (!ok) {
            triggerDeckExhaustion(side, 'open-lane');
            return -1;
          }

          const trapDelta = blackjackMatch && blackjackMatch.traps ? blackjackMatch.traps[side][i] : 0;
          if (trapDelta) {
            if (side === 'player' && laneHasSleeve(positions[i], 'STEEL')) {
              logEvent('TEMPO_STRIKE_BLOCKED', {
                attacker: 'dealer',
                lane: i + 1,
                delta: trapDelta,
                lastPlay: null,
                targetState: 'blocked_steel',
                trapTotalAfter: blackjackMatch.traps[side][i],
                reason: 'trap_trigger'
              });
              blackjackMatch.traps[side][i] = 0;
            } else {
              positions[i].mods = positions[i].mods || [];
              positions[i].mods.push(trapDelta);
              blackjackMatch.traps[side][i] = 0;
              const attacker = side === 'dealer' ? 'player' : 'dealer';
              logEvent('TEMPO_STRIKE_TRAP_TRIGGERED', {
                attacker,
                lane: i + 1,
                delta: trapDelta,
                lastPlay: null,
                targetState: 'open',
                trapTotalAfter: blackjackMatch.traps[side][i]
              });
            }
          }

          if (blackjackMatch && side === 'player') maybeAward21BonusForPlayerPos(i);
          return i;
        }
      }
      return -1;
    }

    function maintainOpenPositions(positions, pile, fallbackDeck, side) {
      while (countOpenPositions(positions) < 3) {
        const opened = openNextPosition(positions, pile, fallbackDeck, side);
        if (opened === -1) break;
      }
    }

    function triggerDeckExhaustion(side, reason) {
      if (!blackjackMatch || blackjackMatch.phase === 'resolved') return;
      blackjackMatch.exhaustion = { side, reason };
      logEvent('DECK_EXHAUSTION', { side, reason });
      const forcedOutcome = side === 'dealer' ? 'WIN' : 'LOSS';
      resolveMatch({ forcedOutcome, exhaustion: blackjackMatch.exhaustion });
    }

    function allPositionsComplete(positions) {
      return positions.every(p => p.isComplete);
    }

    // =============================================
    // BONUSES: +21 chips for any PLAYER position reaching total==21 (any way)
    // =============================================
    function maybeAward21BonusForPlayerPos(posIdx) {
      if (!blackjackMatch || !['playing', 'betting'].includes(blackjackMatch.phase)) return;
      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos || !pos.isOpen) return;
      if (pos.bonus21Awarded) return;

      const total = getPositionTotal(pos);
      if (total === 21) {
        pos.bonus21Awarded = true;
        run.chips += BLACKJACK_21_REWARD;
        blackjackMatch.bonusChipsEarned += BLACKJACK_21_REWARD;

        logEvent('BONUS_21', { lane: posIdx + 1, amount: BLACKJACK_21_REWARD });

        renderHUD();
        showToast(`Blackjack! +${BLACKJACK_21_REWARD} chips`);

        if (!blackjackMatch.bonusAll21Awarded) {
          const all = blackjackMatch.playerPositions.every(p => p.bonus21Awarded);
          if (all) {
            blackjackMatch.bonusAll21Awarded = true;
            run.chips += ALL_FIVE_21_BONUS;
            blackjackMatch.bonusChipsEarned += ALL_FIVE_21_BONUS;

            logEvent('BONUS_ALL_FIVE', { amount: ALL_FIVE_21_BONUS });

            renderHUD();
            showToast(`All five! +${ALL_FIVE_21_BONUS} chips`);
          }
        }
      }
    }


    function flattenLaneForPatterns(laneCards) {
      const out = [];
      for (const c of laneCards || []) {
        if (!c) continue;
        if (isModifier(c) || isKeyCard(c)) continue;
        if (isFused(c)) {
          if (c.a && !isModifier(c.a) && !isKeyCard(c.a)) out.push({ rank: c.a.rank, suit: c.a.suit, parentUid: c.uid || null });
          if (c.b && !isModifier(c.b) && !isKeyCard(c.b)) out.push({ rank: c.b.rank, suit: c.b.suit, parentUid: c.uid || null });
          continue;
        }
        out.push({ rank: c.rank, suit: c.suit, parentUid: c.uid || null });
      }
      return out;
    }

    function detectLanePatterns(laneCards) {
      const atoms = flattenLaneForPatterns(laneCards);
      if (!atoms.length) return [];
      const byRank = new Map();
      const bySuit = new Map();
      for (const a of atoms) {
        if (!a.rank || !a.suit) continue;
        if (!byRank.has(a.rank)) byRank.set(a.rank, []);
        byRank.get(a.rank).push(a.parentUid);
        if (!bySuit.has(a.suit)) bySuit.set(a.suit, []);
        bySuit.get(a.suit).push(a.parentUid);
      }
      const uniqueUids = (arr) => Array.from(new Set((arr || []).filter(v => v !== null && v !== undefined)));
      const rankCounts = Array.from(byRank.entries()).map(([rank, uids]) => ({ rank, count: uids.length, cardUids: uniqueUids(uids) }));
      const pairRanks = rankCounts.filter(r => r.count >= 2);
      const trips = rankCounts.find(r => r.count >= 3);
      const quads = rankCounts.find(r => r.count >= 4);
      const flush = Array.from(bySuit.entries()).find(([, uids]) => uids.length >= 3);

      const values = Array.from(new Set(atoms.map(a => rankToValue(a.rank)).filter(v => v > 0)));
      if (values.includes(14)) values.push(1);
      const sorted = Array.from(new Set(values)).sort((a,b)=>a-b);
      let bestRun = [];
      let cur = [];
      for (const v of sorted) {
        if (!cur.length || v === cur[cur.length-1] + 1) cur.push(v);
        else cur = [v];
        if (cur.length > bestRun.length) bestRun = cur.slice();
      }
      const patterns=[];
      if (quads) patterns.push({ name:'Quads', delta:35, cardUids:quads.cardUids });
      if (trips && pairRanks.some(p => p.rank !== trips.rank)) patterns.push({ name:'Full House', delta:26, cardUids: uniqueUids([...trips.cardUids, ...pairRanks.filter(p=>p.rank!==trips.rank).flatMap(p=>p.cardUids)]) });
      if (trips) patterns.push({ name:'Trips', delta:18, cardUids:trips.cardUids });
      if (pairRanks.length >= 2) patterns.push({ name:'Two Pair', delta:14, cardUids: uniqueUids(pairRanks.slice(0,2).flatMap(p=>p.cardUids)) });
      if (pairRanks.length >= 1) patterns.push({ name:'Pair', delta:8, cardUids: pairRanks[0].cardUids });
      if (flush) patterns.push({ name:'Flush', delta:14, cardUids: uniqueUids(flush[1]) });
      if (bestRun.length >= 3) {
        const runVals = new Set(bestRun);
        const runUids = uniqueUids(atoms.filter(a => {
          const v = rankToValue(a.rank);
          return runVals.has(v) || (v === 14 && runVals.has(1));
        }).map(a => a.parentUid));
        patterns.push({ name:'Straight', delta:14, cardUids: runUids });
      }
      return patterns;
    }

    function countGoldSleeves(pos) {
      const laneCards = pos && pos.cards ? pos.cards : [];
      return collectLaneCardsForEffects(laneCards).filter(c => cardHasSleeve(c, 'GOLD')).length;
    }

    function buildKarmaBreakdown(positionResults, playerTotals) {
      const lanes = positionResults.map((result, idx) => {
        const isWin = result === 'player';
        const base = isWin ? safeNumber(playerTotals[idx], 0) : 0;
        const laneCards = blackjackMatch.playerPositions[idx].cards || [];
        const laneSize = laneCards.length || 1;
        const stamps = [];
        let stampTotal = 0;
        let stampUids = [];
        if (isWin) {
          collectLaneCardsForEffects(laneCards).forEach(card => {
            const stampId = getCardStampId(card);
            if (!stampId) return;
            const def = getStampDef(stampId);
            let delta = getStampKarmaContribution(stampId, base, laneSize);
            const foilMult = cardHasSleeve(card, 'FOIL') ? 2 : 1;
            if (stampId === 'HOUSE_EDGE' && base === 21) delta = laneSize * 10;
            delta *= foilMult;
            stampTotal += delta;
            if (card && card.uid !== null && card.uid !== undefined) stampUids.push(card.uid);
            stamps.push({ stampId, name: def ? def.name : stampId, icon: def ? def.icon : '', delta, cardUid: card?.uid ?? null });
          });
        }
        const patterns = isWin ? detectLanePatterns(laneCards) : [];
        const patternTotal = patterns.reduce((sum, p) => sum + safeNumber(p.delta, 0), 0);
        const mods = blackjackMatch.playerPositions[idx].mods || [];
        const modsText = mods.length ? mods.map(m => (m > 0 ? `+${m}` : `${m}`)).join(' ') : '';
        return {
          idx, outcome: result, base,
          stamps, stampTotal,
          patterns, patternTotal,
          stampUids: Array.from(new Set(stampUids)),
          patternUids: Array.from(new Set(patterns.flatMap(p => p.cardUids || []))),
          modsText,
          laneTotal: base + stampTotal + patternTotal
        };
      });
      return { lanes };
    }

    function isResolutionAnimationActive() {
      return !!(blackjackMatch && ((blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active) || (blackjackMatch.earningsSeq && blackjackMatch.earningsSeq.active)));
    }

    function startEarningsSequence(parts, onDone) {
      if (!blackjackMatch) return;
      const steps = [];
      const push = (name, delta, kind) => { if (safeNumber(delta, 0) !== 0) steps.push({ name, delta: safeNumber(delta, 0), kind }); };
      push('Payout', parts.payout || 0, 'payout');
      push('Side Bet', parts.sideBet || 0, 'sidebet');
      push('Rake', -(parts.rake || 0), 'rake');
      push('Bonus', parts.bonus || 0, 'bonus');
      blackjackMatch.earningsSeq = { active: true, steps, idx: 0, accrued: 0, message: 'Earnings tallyâ€¦', onDone, laneAccrued: Array(LANE_COUNT).fill(0) };
      advanceEarningsSequence();
    }

    function advanceEarningsSequence() {
      if (!blackjackMatch || !blackjackMatch.earningsSeq || !blackjackMatch.earningsSeq.active) return;
      const es = blackjackMatch.earningsSeq;
      if (es.idx >= es.steps.length) {
        es.active = false;
        try { if (window.SFX && es.accrued > 0) SFX.play('chip_done'); } catch(e){}
        const cb = es.onDone;
        if (typeof cb === 'function') cb();
        renderAll();
        return;
      }
      const step = es.steps[es.idx++];
      es.accrued += step.delta;
      const r = blackjackMatch.result;
      if (r && r.laneChip) {
        if (step.kind === 'sidebet') {
          const arr = r.laneChip.transferNetByLane || [];
          for (let i = 0; i < es.laneAccrued.length; i++) es.laneAccrued[i] += safeNumber(arr[i], 0);
        }
        if (step.kind === 'bonus') {
          const arr = r.laneChip.bonusByLane || [];
          for (let i = 0; i < es.laneAccrued.length; i++) es.laneAccrued[i] += safeNumber(arr[i], 0);
        }
      }
      es.message = `${step.name}: ${step.delta >= 0 ? '+' : ''}${step.delta}`;
      try {
        if (window.SFX) {
          if (step.delta > 0) SFX.play('chip_tick');
          else if (step.delta < 0) SFX.play('bench_overflow');
        }
      } catch(e){}
      renderAll();
      setTimeout(advanceEarningsSequence, 650);
    }

    function startScoreSequence(breakdown, extras, total, levelUpSummary = null) {
      if (!blackjackMatch) return;
      const steps = [];
      (breakdown.lanes || []).forEach(lane => {
        if (lane.base > 0) steps.push({ type: 'laneBase', lane, delta: lane.base, message: `Lane ${lane.idx + 1} win +${lane.base}`, cardUids: [] });
        (lane.stamps || []).forEach(stamp => {
          if (safeNumber(stamp.delta, 0) <= 0) return;
          steps.push({ type: 'laneStamp', lane, delta: safeNumber(stamp.delta, 0), message: `Lane ${lane.idx + 1} ${stamp.name || 'Stamp'} +${stamp.delta}`, cardUids: stamp.cardUid ? [stamp.cardUid] : [] });
        });
        (lane.patterns || []).forEach(pattern => {
          if (safeNumber(pattern.delta, 0) <= 0) return;
          steps.push({ type: 'lanePattern', lane, delta: safeNumber(pattern.delta, 0), message: `Lane ${lane.idx + 1} ${pattern.name || 'Pattern'} +${pattern.delta}`, cardUids: pattern.cardUids || [] });
        });
      });
      for (const extra of (extras || [])) {
        if (safeNumber(extra.delta, 0) <= 0) continue;
        steps.push({ type: 'extra', lane: null, delta: safeNumber(extra.delta, 0), message: `${extra.name} +${extra.delta}`, cardUids: [] });
      }
      if (levelUpSummary && levelUpSummary.levelsGained > 0) {
        steps.push({ type: 'levelUp', lane: null, delta: 0, message: `Calling rank up ${levelUpSummary.fromRank} â†’ ${levelUpSummary.toRank}`, cardUids: [] });
      }

      blackjackMatch.scoreSeq = {
        active: true,
        steps,
        stepIndex: 0,
        accrued: 0,
        total,
        laneAccrued: Array(LANE_COUNT).fill(0),
        focusLane: null,
        focusSide: null,
        focusCardUids: [],
        float: null,
        message: 'Karma tallyâ€¦',
        speedMs: 1150,
        fastMs: 250,
        isFast: !!(run && run.ui && run.ui.karmaTallyFast)
      };
      advanceScoreSequence();
    }

    function finishScoreSequence() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq) return;
      blackjackMatch.scoreSeq.active = false;
      blackjackMatch.scoreSeq.focusLane = null;
      blackjackMatch.scoreSeq.focusSide = null;
      blackjackMatch.scoreSeq.focusCardUids = [];
      blackjackMatch.scoreSeq.float = null;
      renderAll();
      if (blackjackMatch.pendingRewardStart) {
        blackjackMatch.pendingRewardStart = false;
        startWinnerRewardFlow();
      }
    }

    function advanceScoreSequence() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq || !blackjackMatch.scoreSeq.active) return;
      const seq = blackjackMatch.scoreSeq;
      if (seq.stepIndex >= seq.steps.length) {
        finishScoreSequence();
        return;
      }
      const step = seq.steps[seq.stepIndex];
      seq.focusLane = step.lane ? step.lane.idx : null;
      seq.focusSide = step.lane ? 'player' : null;
      seq.focusCardUids = step.cardUids || [];
      seq.message = step.message || 'Karma tallyâ€¦';
      if (step.type === 'levelUp') { try { if (window.SFX) SFX.play('karma_done'); } catch(e){} }
      if (step.delta > 0) {
        seq.accrued += step.delta;
      try { if (window.SFX && step.delta > 0) SFX.play('karma_tick'); } catch(e){}
        if (step.lane && typeof step.lane.idx === 'number') seq.laneAccrued[step.lane.idx] += step.delta;
        seq.float = {
          id: `${Date.now()}_${seq.stepIndex}`,
          laneIdx: step.lane ? step.lane.idx : null,
          side: step.lane ? 'player' : null,
          text: `+${step.delta}`,
          kind: step.type
        };
      } else {
        seq.float = null;
      }
      seq.stepIndex += 1;
      renderAll();
      const delay = seq.isFast ? seq.fastMs : seq.speedMs;
      setTimeout(advanceScoreSequence, delay);
    }

    window.skipScoreSequence = function() {
      if (!blackjackMatch || !blackjackMatch.scoreSeq || !blackjackMatch.scoreSeq.active) return;
      blackjackMatch.scoreSeq.isFast = true;
    };


    window.skipResolutionAnimations = function(){
      if (!blackjackMatch) return;
      if (blackjackMatch.earningsSeq && blackjackMatch.earningsSeq.active){
        const es = blackjackMatch.earningsSeq;
        while (es.idx < es.steps.length){
          const step = es.steps[es.idx++];
          es.accrued += step.delta;
          const r = blackjackMatch.result;
          if (r && r.laneChip){
            if (step.kind === 'sidebet'){
              const arr = r.laneChip.transferNetByLane || [];
              for (let i=0;i<5;i++) es.laneAccrued[i] += safeNumber(arr[i],0);
            }
            if (step.kind === 'bonus'){
              const arr = r.laneChip.bonusByLane || [];
              for (let i=0;i<5;i++) es.laneAccrued[i] += safeNumber(arr[i],0);
            }
          }
        }
        es.active = false;
      }
      if (blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active){
        const ss = blackjackMatch.scoreSeq;
        while (ss.stepIndex < ss.steps.length){
          const step = ss.steps[ss.stepIndex++];
          if (step.delta > 0){
            ss.accrued += step.delta;
            if (step.lane && typeof step.lane.idx === 'number') ss.laneAccrued[step.lane.idx] += step.delta;
          }
        }
        finishScoreSequence();
        return;
      }
      renderAll();
    };

    // =============================================
    // BENCH
    // =============================================
    window.armBench = function(i) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      blackjackMatch.armedBenchIdx = (blackjackMatch.armedBenchIdx === i) ? null : i;
      renderBlackjack();
    };

    window.applyBenchTo = function(side, posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (tokensRemaining() <= 0) return;

      const bi = blackjackMatch.armedBenchIdx;
      if (bi === null || bi === undefined) return;

      const mod = blackjackMatch.bench[bi];
      if (!mod || !isModifier(mod)) return;

      const positions = side === 'dealer' ? blackjackMatch.dealerPositions : blackjackMatch.playerPositions;
      const pos = positions[posIdx];
      if (!pos || !pos.isOpen || pos.isComplete) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      logEvent('TOKEN_SPENT', { amount: 1, source: 'BENCH_USE' });

      const laneState = applyLaneMod(side, posIdx, mod.delta);
      if (laneState !== 'open' && laneState !== 'erased') return;
      pos.lastPlay = { kind: 'mod', delta: laneState === 'erased' ? 0 : mod.delta };
      onCardPlacedForAttack(pos, mod);

      blackjackMatch.bench.splice(bi, 1);
      blackjackMatch.armedBenchIdx = null;

      if (side === 'player') blackjackMatch.metrics.benchModsToPlayer += 1;
      else blackjackMatch.metrics.benchModsToDealer += 1;

      logEvent('BENCH_APPLY', { card: cardToString(mod), cardUid: mod.uid || null, cardRef: cardRef(mod), side, lane: posIdx + 1, delta: mod.delta });

      if (side === 'player') maybeAward21BonusForPlayerPos(posIdx);

      renderAll();
      showToast(`Played ${cardToString(mod)} to ${side} #${posIdx + 1}`);
    };

    function handleCallingSuitOnPlayerCardPlaced(placedCard, laneIdx, onComplete) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return false;
      if (!run || !run.callingCard) return false;
      if (!isStandardCard(placedCard)) return false;

      const stampId = getCardStampId(placedCard);
      const proxySuit = stampId === 'PROXY_SUIT';
      const matchesCalling = placedCard.suit === run.callingCard.suit || proxySuit;
      const procMult = 1;
      const effectiveSuit = proxySuit ? run.callingCard.suit : placedCard.suit;

      if (!matchesCalling) {
        blackjackMatch.lastCallingSuitPlay = null;
        return false;
      }

      const procced = Math.random() < blackjackMatch.callingProcChance;
      blackjackMatch.lastCallingSuitPlay = {
        laneIdx,
        suit: effectiveSuit,
        procced,
        card: placedCard,
        procMult
      };

      if (!procced) return false;

      if (effectiveSuit === 'â™¦') {
        const bonus = DIAMOND_BONUS_CHIPS * procMult;
        run.chips += bonus;
        blackjackMatch.bonusChipsEarned += bonus;
        logEvent('CALLING_PROC_DIAMOND', {
          laneIdx: laneIdx + 1,
          amount: bonus,
          callingCard: run.callingCard,
          playedCard: placedCard,
          multiplier: procMult
        });
        renderHUD();
        showToast(`+${bonus} chips (Wealth)`);
        showProcBanner({ suit: 'â™¦', title: 'Calling Proc Â· Wealth', desc: `+${bonus} chips awarded` });
        return false;
      }

      if (effectiveSuit === 'â™ ') {
        blackjackMatch.spadePeekLanes.add(laneIdx);
        logEvent('CALLING_PROC_SPADES', {
          laneIdx: laneIdx + 1,
          callingCard: run.callingCard,
          playedCard: placedCard,
          multiplier: procMult
        });
        showToast(`Intel: Revealed Dealer lane #${laneIdx + 1}`);
        showProcBanner({ suit: 'â™ ', title: 'Calling Proc Â· Intel', desc: `Dealer lane #${laneIdx + 1} revealed` });
        renderBlackjack();
        return false;
      }

      if (effectiveSuit === 'â™£') {
        const dPos = blackjackMatch.dealerPositions[laneIdx];
        if (!dPos || !dPos.isOpen || dPos.isComplete) {
          logEvent('CALLING_PROC_CLUBS', {
            laneIdx: laneIdx + 1,
            delta: null,
            blocked: true,
            callingCard: run.callingCard,
            playedCard: placedCard,
            multiplier: procMult
          });
          return false;
        }

        showModal('Power Proc', `
          <p class="modal-text">Choose effect on Dealer lane #${laneIdx + 1}.</p>
          <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
            <button class="modal-btn" onclick="applyCallingClubs(${laneIdx}, 1)">+1</button>
            <button class="modal-btn danger" onclick="applyCallingClubs(${laneIdx}, -1)">-1</button>
          </div>
        `, []);

        window.applyCallingClubs = function(targetIdx, delta) {
          const target = blackjackMatch.dealerPositions[targetIdx];
          if (target && target.isOpen && !target.isComplete) {
            target.mods = target.mods || [];
            for (let i = 0; i < procMult; i++) target.mods.push(delta);
            logEvent('CALLING_PROC_CLUBS', {
              laneIdx: targetIdx + 1,
              delta,
              callingCard: run.callingCard,
              playedCard: placedCard,
              multiplier: procMult
            });
            showToast(`Power: Dealer lane #${targetIdx + 1} ${delta > 0 ? '+1' : '-1'}`);
          }
          closeModal();
          delete window.applyCallingClubs;
          renderAll();
          onComplete();
        };
        return true;
      }

      return false;
    }

    window.playerPlaceBenchCard = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (tokensRemaining() <= 0) return;

      const bi = blackjackMatch.armedBenchIdx;
      if (bi === null || bi === undefined) return;
      const c = blackjackMatch.bench[bi];
      if (!c || isModifier(c)) return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos || !pos.isOpen || pos.isComplete) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      logEvent('TOKEN_SPENT', { amount: 1, source: 'BENCH_USE' });

      pos.cards.push(c);
      const placedForHooks = handleFusionOnCardPlaced(pos, c);
      pos.lastPlay = { kind: 'card', rank: c.rank, value: getStrikeValueFromCard(placedForHooks) };
      onCardPlacedForAttack(pos, placedForHooks);
      recordLaneCard('player', posIdx);
      blackjackMatch.bench.splice(bi, 1);
      blackjackMatch.armedBenchIdx = null;

      blackjackMatch.metrics.benchCardsPlaced += 1;
      logEvent('BENCH_PLACE', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), lane: posIdx + 1 });

      maybeAward21BonusForPlayerPos(posIdx);
      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'bench_place');
      const deferred = handleCallingSuitOnPlayerCardPlaced(placedForHooks, posIdx, endPlayerTurn);
      if (!deferred) endPlayerTurn();
    };


    function fuseCardsInDeck(cardA, cardB) {
      const fused = { uid: nextCardUid(), type: 'FUSE', a: cardA, b: cardB, sleeveId: 'FUSION' };
      run.playerDeck = (run.playerDeck || []).filter(c => c !== cardA && c !== cardB);
      run.playerDeck.push(fused);
      recordDeckSnapshot('FUSION_CREATED', { a: cardRef(cardA), b: cardRef(cardB), fused: cardRef(fused) });
      return fused;
    }


    function handleFusionOnCardPlaced(pos, placed) {
      if (!pos || !placed || !isStandardCard(placed)) return placed;

      if (pos.pendingFusionUid) {
        const pendingIdx = (pos.cards || []).findIndex(c => c && c.uid === pos.pendingFusionUid);
        const placedIdx = (pos.cards || []).findIndex(c => c && c.uid === placed.uid);
        if (pendingIdx !== -1 && placedIdx !== -1 && pendingIdx !== placedIdx) {
          const fusionCard = pos.cards[pendingIdx];
          const placedCard = pos.cards[placedIdx];
          const fusedDeckCard = fuseCardsInDeck(fusionCard, placedCard);
          pos.cards = pos.cards.filter((_, i) => i !== pendingIdx && i !== placedIdx);
          pos.cards.push(fusedDeckCard);
          pos.pendingFusionUid = null;
          logEvent('FUSION_TRIGGERED', {
            laneCards: (pos.cards || []).map(cardRef),
            a: cardRef(fusionCard),
            b: cardRef(placedCard),
            fused: cardRef(fusedDeckCard)
          });
          return fusedDeckCard;
        }
      }

      if (!isFused(placed) && placed.sleeveId === 'FUSION') pos.pendingFusionUid = placed.uid;
      if (placed.sleeveId === 'ERASER') pos.eraserCharges = safeNumber(pos.eraserCharges, 0) + 1;
      return placed;
    }

    // =============================================
    // PLAYER TURN: drawing places modifiers into bench automatically
    // =============================================
    window.playerDrawCard = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;
      if (countOpenPositions(blackjackMatch.playerPositions) === 0) return;

      let safety = 0;
      while (safety++ < 300) {
        const c = drawCardFromPile(blackjackMatch.playerDrawPile, run.playerDeck);
        if (!c) {
          triggerDeckExhaustion('player', 'draw');
          return;
        }
        if (isModifier(c)) {
          benchPush(c, 'player-draw');
          blackjackMatch.metrics.modifiersBenched += 1;
          logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c) });
          renderBlackjack();
          showToast(`Benched ${cardToString(c)}`);
          continue;
        }
        if (c && c.sleeveId === 'BLUE') {
          benchPush(c, 'blue-sleeve');
          blackjackMatch.metrics.modifiersBenched += 1;
          logEvent('PLAYER_DRAW_BENCH', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: 'blue-sleeve' });
          renderBlackjack();
          showToast(`Benched ${cardToString(c)} (Blue Sleeve)`);
          continue;
        }
        blackjackMatch.drawnCard = c;
        try { if (window.SFX) SFX.play('card_draw'); } catch(e){}
        blackjackMatch.metrics.playerDraws += 1;
        logEvent('PLAYER_DRAW', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c) });
        renderBlackjack();
        return;
      }

      triggerDeckExhaustion('player', 'draw');
    };

    window.playerPlaceCard = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (!blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos.isOpen || pos.isComplete) return;

      const placed = blackjackMatch.drawnCard;
      pos.cards.push(placed);
      try { if (window.SFX) SFX.play('card_place'); } catch(e){}
      const placedForHooks = handleFusionOnCardPlaced(pos, placed);
      pos.lastPlay = { kind: 'card', rank: placed.rank, value: getStrikeValueFromCard(placedForHooks) };
      onCardPlacedForAttack(pos, placedForHooks);
      recordLaneCard('player', posIdx);
      blackjackMatch.drawnCard = null;

      logEvent('PLAYER_PLACE', { card: cardToString(placed), cardUid: placed.uid || null, cardRef: cardRef(placed), lane: posIdx + 1 });

      maybeAward21BonusForPlayerPos(posIdx);
      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'player_place');

      // Apply pending splitDecision dealer gift (after player placement)
      if (blackjackMatch.pending && blackjackMatch.pending.type === 'splitDecision') {
        const gift = blackjackMatch.pending.dealerGiftCard;
        blackjackMatch.pending = null;
        dealerPlaceOneCard(gift, true);
      }

      const deferred = handleCallingSuitOnPlayerCardPlaced(placedForHooks, posIdx, endPlayerTurn);
      if (!deferred) endPlayerTurn();
    };

    window.playerStand = function(posIdx) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.drawnCard || blackjackMatch.turn !== 'player') return;

      const pos = blackjackMatch.playerPositions[posIdx];
      if (!pos.isOpen || pos.isComplete) return;

      tryFireCloseAttack('player', posIdx);
      pos.isComplete = true;
      try { if (window.SFX) SFX.play('lane_close'); } catch(e){}

      // If they close while >21, it is a bust now (closure reveals score)
      const total = getPositionTotal(pos);
      pos.isBust = total > 21;
      if (pos.isBust) { try { if (window.SFX) SFX.play('bust'); } catch(e){} }

      blackjackMatch.metrics.playerStands += 1;

      logEvent('PLAYER_STAND', { lane: posIdx + 1, total, bust: pos.isBust });


      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'player_stand');

      if (checkMatchEnd()) return;

      if (countOpenPositions(blackjackMatch.playerPositions) === 0) {
        endPlayerTurn();
        return;
      }

      renderBlackjack();
    };

    window.playerEndTurn = function() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (blackjackMatch.drawnCard) return;

      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const pos = blackjackMatch.playerPositions[i];
        if (!pos || !pos.isOpen || pos.isComplete) continue;
        tryFireCloseAttack('player', i);
        pos.isComplete = true;
        const total = getPositionTotal(pos);
        pos.isBust = total > 21;
        blackjackMatch.metrics.playerStands += 1;
        logEvent('PLAYER_STAND', { lane: i + 1, total, bust: pos.isBust, source: 'CLOSE_END' });
      }

      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');
      updateThreatTargetLane(false, 'player_end_turn_close');
      if (checkMatchEnd()) return;
      if (blackjackMatch) blackjackMatch.autoPassToEnd = false;
      endPlayerTurn();
    };

    window.passTillMatchEnd = function() {
      if (!blackjackMatch || blackjackMatch.turn !== 'player') return;
      if (countOpenPositions(blackjackMatch.playerPositions) > 0) {
        showToast('Close all lanes first.');
        return;
      }
      blackjackMatch.autoPassToEnd = true;
      blackjackMatch.turn = 'dealer';
      renderBlackjack();
      setTimeout(dealerTurn, 250);
    };

    function endPlayerTurn() {
      blackjackMatch.metrics.turns += 1;

      // Finalize busts at end of player's turn (per spec)
      const preBust = blackjackMatch.playerPositions.map(p => !!p.isBust);
      finalizeBusts(blackjackMatch.playerPositions, 'player');
      updateThreatTargetLane(false, 'bust_finalize');

      const lastPlay = blackjackMatch.lastCallingSuitPlay;
      if (lastPlay && lastPlay.procced && lastPlay.suit === 'â™¥') {
        const newlyBusted = blackjackMatch.playerPositions
          .map((p, idx) => ({ p, idx }))
          .filter(({ p, idx }) => !preBust[idx] && p.isBust);

        const triageCount = Math.max(1, safeNumber(lastPlay.procMult, 1));
        let remaining = triageCount;

        while (newlyBusted.length && remaining > 0) {
          let targetIdx = newlyBusted.findIndex(n => n.idx === lastPlay.laneIdx);
          if (targetIdx === -1) targetIdx = 0;
          const target = newlyBusted.splice(targetIdx, 1)[0];
          const pos = target.p;
          const discarded = pos.cards.pop();
          pos.isBust = false;
          pos.isComplete = false;
          logEvent('CALLING_PROC_HEARTS_TRIAGE', {
            laneIdx: target.idx + 1,
            discardedCard: cardToString(discarded),
            callingCard: run.callingCard,
            playedCard: lastPlay.card,
            multiplier: triageCount
          });
          showToast(`Health: Triage saved lane #${target.idx + 1}`);
          showProcBanner({ suit: 'â™¥', title: 'Calling Proc Â· Triage', desc: `Recovered lane #${target.idx + 1}` });
          remaining -= 1;
        }
      }
      blackjackMatch.lastCallingSuitPlay = null;

      maintainOpenPositions(blackjackMatch.playerPositions, blackjackMatch.playerDrawPile, run.playerDeck, 'player');

      if (checkMatchEnd()) return;

      blackjackMatch.turn = 'dealer';
      renderBlackjack();

      clearDealerTimers();
      dealerTimerA = setTimeout(dealerTurn, 800);
    }

    // =============================================
    // DEALER AI + placement helpers
    // =============================================
function dealerRiskPenalty(total) {
  if (total <= 11) return 0;          // explicitly prefers <=11 (e.g. 11 over 12)
  if (total === 12) return 2.2;
  if (total === 13) return 1.8;
  if (total === 14) return 1.5;
  if (total === 15) return 1.2;
  if (total === 16) return 1.0;
  if (total === 17) return 0.55;
  if (total === 18) return 0.30;
  if (total === 19) return 0.18;
  if (total === 20) return 0.10;
  return 0; // 21
}

function estimatePlayerTargetForLane(idx, diff) {
  const pPos = blackjackMatch.playerPositions[idx];
  if (!pPos) return 18;

  const pTotal = getPositionTotal(pPos);
  const pComplete = !!pPos.isComplete;
  const pBust = !!pPos.isBust || (pComplete && pTotal > 21);

  if (pBust) return 0;
  if (pComplete) return Math.min(21, pTotal);

  // Incomplete lanes: heuristic expectation
  if (diff === 'easy') return Math.min(21, pTotal);
  if (diff === 'medium') return Math.min(21, Math.max(pTotal, 17));

  // hard: assumes player pushes safely to ~17-18 when low
  if (pTotal <= 11) return 18;
  if (pTotal <= 14) return 18;
  if (pTotal <= 16) return 17;
  return Math.min(21, pTotal);
}

function dealerLaneScore(idx, total, diff) {
  if (total > 21) return -10000 - total;

  const prof = getDealerProfile();
  const target = estimatePlayerTargetForLane(idx, diff);

  if (target === 0) {
    return 120 + (total <= 11 ? (11 - Math.abs(11 - total)) : 0) - dealerRiskPenalty(total) * 12 * (prof.riskMult || 1);
  }

  const winNeed = Math.min(21, target + 1);
  const winBonus = (total >= winNeed) ? (140 * (prof.winBonusMult || 1)) : 0;
  const closeBonusBase = (total === 21) ? 260 : (total === 20) ? 90 : (total === 19) ? 45 : 0;
  const closeBonus = closeBonusBase * (prof.closeBonusMult || 1);
  const pushPenalty = (total === target) ? 14 : 0;

  const risk = dealerRiskPenalty(total) * 12 * (prof.riskMult || 1);

  return total + winBonus + closeBonus - risk - pushPenalty;
}

    function dealerPlaceOneCard(card, fromAction = false) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const diff = getOpponentDifficulty();

      if (run.bossFight && run.bossFight.active && run.bossFight.phase === 2) {
        bossTryCountermeasure();
      }
      if (blackjackMatch.type === 'WATCHER') {
        updateThreatTargetLane(false, 'dealer_turn_start');
      }

      const open = blackjackMatch.dealerPositions
        .map((p, i) => ({ pos: p, idx: i }))
        .filter(d => d.pos.isOpen && !d.pos.isComplete);

      if (open.length === 0) return;

      // Forced lane (Forced Play action)
      let targetIdx = -1;
      const forced = blackjackMatch.dealerForcedLane;
      if (forced !== null && forced !== undefined) {
        const fp = blackjackMatch.dealerPositions[forced];
        if (fp && fp.isOpen && !fp.isComplete) targetIdx = forced;
        blackjackMatch.dealerForcedLane = null;
      }

      // If not forced, choose by marginal improvement (and some randomness on Easy)
      if (targetIdx === -1) {
        const scored = open.map(({ pos, idx }) => {
          const before = getPositionTotal(pos);
          const beforeScore = dealerLaneScore(idx, before, diff);

          const simulated = { cards: [...pos.cards, card], mods: pos.mods || [] };
          const after = getPositionTotal(simulated);
          const afterScore = dealerLaneScore(idx, after, diff);

          return { idx, before, after, delta: (afterScore - beforeScore), afterScore };
        });

        const prof = getDealerProfile();
        const quirk = blackjackMatch.aiQuirkBias || [];
        let focusLane = blackjackMatch.aiFocusLane;

        if (focusLane == null && safeNumber(prof.focusStrength, 0) > 0) {
          if (prof.focusMode === 'WEAKEST_PLAYER') {
            let best = null;
            for (const s of scored) {
              const pPos = blackjackMatch.playerPositions[s.idx];
              if (!pPos || !pPos.isOpen || pPos.isComplete) continue;
              const pt = getPositionTotal(pPos);
              if (!best || pt < best.pt) best = { idx: s.idx, pt };
            }
            if (best) focusLane = best.idx;
          } else if (prof.focusMode === 'PUNISH_COMPLETES') {
            let best = null;
            for (const s of scored) {
              const pPos = blackjackMatch.playerPositions[s.idx];
              if (pPos && pPos.isComplete && !pPos.isBust) {
                const pt = getPositionTotal(pPos);
                if (!best || pt > best.pt) best = { idx: s.idx, pt };
              }
            }
            if (best) focusLane = best.idx;
          }
          blackjackMatch.aiFocusLane = focusLane;
        }

        for (const s of scored) {
          s.delta += (quirk[s.idx] || 0) * (prof.quirkLaneWeight || 1);

          if (prof.spreadPenalty) {
            const dPos = blackjackMatch.dealerPositions[s.idx];
            const laneCards = (dPos && dPos.cards) ? dPos.cards.length : 0;
            s.delta -= prof.spreadPenalty * Math.max(0, laneCards - 2);
          }

          if (focusLane != null && s.idx === focusLane) {
            s.delta += 12 * (prof.focusStrength || 0);
          }

          const j = prof.jitter || 0;
          if (j) s.delta += (Math.random() * 2 - 1) * j;
        }

        scored.sort((a, b) => b.delta - a.delta);

        if (prof.id === 'GAMBLER' && diff !== 'easy') {
          const top = scored.slice(0, Math.min(3, scored.length));
          top.sort((a, b) => b.delta - a.delta);
          targetIdx = top[Math.floor(Math.random() * top.length)].idx;
        } else if (diff === 'easy') {
          const top = scored.slice(0, Math.min(2, scored.length));
          top.sort((a, b) => b.afterScore - a.afterScore);
          targetIdx = (top.length === 1) ? top[0].idx : (Math.random() < 0.55 ? top[0].idx : top[1].idx);
        } else {
          if (scored[0].delta >= 0) targetIdx = scored[0].idx;
          else targetIdx = scored.slice().sort((a, b) => b.afterScore - a.afterScore)[0].idx;
        }
      }

      if (targetIdx >= 0) {
        blackjackMatch.dealerPositions[targetIdx].cards.push(card);
        try { if (window.SFX) SFX.play('dealer_place'); } catch(e){}
        const dealerPlaced = handleFusionOnCardPlaced(blackjackMatch.dealerPositions[targetIdx], card);
        blackjackMatch.dealerPositions[targetIdx].lastPlay = { kind: 'card', rank: card.rank, value: getStrikeValueFromCard(dealerPlaced) };
        onCardPlacedForAttack(blackjackMatch.dealerPositions[targetIdx], dealerPlaced);
        recordLaneCard('dealer', targetIdx);
        if (blackjackMatch.spadePeekLanes) blackjackMatch.spadePeekLanes.delete(targetIdx);

        blackjackMatch.metrics.dealerDraws += 1;

        if (fromAction) {
          renderBlackjack();
          showToast(`Dealer played ${cardToString(card)}`);
        }
      }
    }


function dealerDrawPlayableCard() {
  // draw until non-mod; mods go to dealerBench
  let safety = 0;
  while (safety++ < 300) {
    const fb = (blackjackMatch && blackjackMatch.dealerBaseDeck) ? blackjackMatch.dealerBaseDeck : makeStandardDeck52();
    const c = drawCardFromPile(blackjackMatch.dealerDrawPile, fb);
    if (!c) return null;
    if (isModifier(c)) {
      blackjackMatch.dealerBench = blackjackMatch.dealerBench || [];
      blackjackMatch.dealerBench.push(c);
      blackjackMatch.metrics.dealerModifiersBenched = safeNumber(blackjackMatch.metrics.dealerModifiersBenched, 0) + 1;
      logEvent('DEALER_BENCH_GAIN', { card: cardToString(c), cardUid: c.uid || null, cardRef: cardRef(c), source: 'dealer-turn-draw' });
      continue;
    }
    return c;
  }
  return null;
}

function dealerApplyBenchMod(bestMove) {
  const { modIdx, laneIdx, modCard, reason } = bestMove;
  const pos = blackjackMatch.dealerPositions[laneIdx];
  if (!pos || !pos.isOpen || pos.isComplete) return false;

  const laneState = applyLaneMod('dealer', laneIdx, modCard.delta);
  if (laneState !== 'open' && laneState !== 'erased') return false;
  pos.lastPlay = { kind: 'mod', delta: laneState === 'erased' ? 0 : modCard.delta };
  onCardPlacedForAttack(pos, modCard);

  blackjackMatch.dealerBench.splice(modIdx, 1);
  blackjackMatch.metrics.dealerBenchModsUsed = safeNumber(blackjackMatch.metrics.dealerBenchModsUsed, 0) + 1;

  logEvent('DEALER_BENCH_APPLY', { card: cardToString(modCard), cardUid: modCard.uid || null, cardRef: cardRef(modCard), lane: laneIdx + 1, delta: modCard.delta, reason });
  return true;
}

function dealerFindBestBenchMove(diff, phase) {
  const bench = blackjackMatch.dealerBench || [];
  if (!bench.length) return null;

  const open = blackjackMatch.dealerPositions
    .map((p, i) => ({ pos: p, idx: i }))
    .filter(d => d.pos.isOpen && !d.pos.isComplete);

  if (!open.length) return null;

  let best = null;

  for (let mi = 0; mi < bench.length; mi++) {
    const m = bench[mi];
    if (!isModifier(m)) continue;

    for (const { pos, idx } of open) {
      const before = getPositionTotal(pos);
      const after = getPositionTotal({ cards: pos.cards, mods: [...(pos.mods || []), m.delta] });

      // Phase rules:
      // - salvage: prioritize fixing would-be busts (before>21 -> after<=21)
      // - strategic: only play if it *improves* lane score (no forced plays)
      const beforeScore = dealerLaneScore(idx, before, diff);
      const afterScore = dealerLaneScore(idx, after, diff);
      const gain = afterScore - beforeScore;

      if (phase === 'salvage') {
        const fixesBust = (before > 21 && after <= 21);
        if (!fixesBust && gain <= 0) continue;
      } else {
        if (gain <= 0) continue;
      }

      // Prefer â€œcloser to 21â€ but still safe; risk penalty encodes 11>12 preference.
      const move = {
        modIdx: mi,
        laneIdx: idx,
        modCard: m,
        gain,
        reason: (phase === 'salvage') ? 'salvage' : 'strategic'
      };

      if (!best || move.gain > best.gain) best = move;
    }
  }

  return best;
}

function dealerShouldStandLane(idx, diff) {
  const dPos = blackjackMatch.dealerPositions[idx];
  const prof = getDealerProfile();
  const shift = safeNumber(prof.standShift, 0);
  if (!dPos || !dPos.isOpen || dPos.isComplete) return false;

  const total = getPositionTotal(dPos);
  if (total > 21) return false;

  const pPos = blackjackMatch.playerPositions[idx];
  const pTotal = pPos ? getPositionTotal(pPos) : 0;
  const pComplete = !!(pPos && pPos.isComplete);
  const pBustKnown = !!(pPos && pPos.isComplete && (pPos.isBust || pTotal > 21));

  // If player lane is definitively busted, lock it in (hard/medium); easy sometimes dithers.
  if (pBustKnown) {
    if (diff === 'easy') return (total >= 12) || (Math.random() < 0.25);
    return true;
  }

  // If player lane is complete (known target)
  if (pComplete) {
    if (total > pTotal && total >= 13) return true;
    if (diff === 'hard') return total >= Math.max(16, 19 + shift);
    return total >= Math.max(15, 17 + shift);
  }

  // Player lane incomplete: estimate and choose
  const target = estimatePlayerTargetForLane(idx, diff);

  if (diff === 'easy') {
    return (total >= Math.max(14, 16 + shift) && Math.random() < 0.70) || total >= Math.max(17, 19 + shift);
  }
  if (diff === 'medium') {
    if (total >= Math.max(15, 17 + shift)) return true;
    if (total >= 15 && total >= target + 2) return true;
    return false;
  }

  // hard
  if (total >= Math.max(16, 19 + shift)) return true;
  if (total >= 17 && total >= target + 1) return true;
  if (total >= 15 && total >= target + 3) return true;
  return false;
}

function dealerStandPhase(diff, maxPasses = 6) {
  let passes = 0;
  let changed = true;

  while (changed && passes++ < maxPasses) {
    changed = false;

    for (let i = 0; i < blackjackMatch.dealerPositions.length; i++) {
      const pos = blackjackMatch.dealerPositions[i];
      if (!pos.isOpen || pos.isComplete) continue;

      if (dealerShouldStandLane(i, diff)) {
        tryFireCloseAttack('dealer', i);
        pos.isComplete = true;
        pos.isBust = (getPositionTotal(pos) > 21);
        blackjackMatch.metrics.dealerStands += 1;
        changed = true;


        // Keep 3 open lanes
        const fb = blackjackMatch.dealerBaseDeck || makeStandardDeck52();
        maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, fb, 'dealer');
      }
    }
  }
}

    function dealerTurn() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const diff = getOpponentDifficulty();

      if (blackjackMatch.type === 'WATCHER') {
        updateThreatTargetLane(true, 'watcher_turn_start');
        const idx = blackjackMatch.watcherTargetLaneIdx;
        if (idx !== null && idx !== undefined && blackjackMatch.dealerForcedLane == null) {
          blackjackMatch.dealerForcedLane = idx;
        }
      }

      // 1) Strategic bench use (no forced plays; only if improves)
      const prof = getDealerProfile();
      const draws = safeNumber(blackjackMatch.metrics.dealerDraws, 0);
      const late = draws >= 6;
      let benchBudget = (diff === 'hard') ? 2 : (diff === 'medium') ? 1 : (Math.random() < 0.35 ? 1 : 0);
      benchBudget = Math.round(benchBudget * (late ? (prof.benchLateMult || 1) : (prof.benchEarlyMult || 1)));
      for (let k = 0; k < benchBudget; k++) {
        const move = dealerFindBestBenchMove(diff, 'strategic');
        if (!move) break;
        dealerApplyBenchMod(move);
      }

      // 2) Standing decisions (dynamic)
      dealerStandPhase(diff);

      renderBlackjack();
      if (checkMatchEnd()) return;

      // 3) Draw + place one card (mods drawn become dealer bench)
      const openPositions = blackjackMatch.dealerPositions
        .map((p, i) => ({ pos: p, idx: i }))
        .filter(d => d.pos.isOpen && !d.pos.isComplete);

      if (openPositions.length === 0) {
        endDealerTurn();
        return;
      }

      clearDealerTimers();
      dealerTimerB = setTimeout(() => {
        const card = dealerDrawPlayableCard();
        if (!card) {
          triggerDeckExhaustion('dealer', 'draw');
          return;
        }
        dealerPlaceOneCard(card);

        // 4) Salvage: if any lanes would bust at end-of-turn, try negatives first
        let salvageBudget = (diff === 'hard') ? 2 : 1;
        salvageBudget = Math.round(salvageBudget * (prof.salvageMult || 1));
        for (let k = 0; k < salvageBudget; k++) {
          const move = dealerFindBestBenchMove(diff, 'salvage');
          if (!move) break;
          dealerApplyBenchMod(move);
        }

        // Optional final stand pass (locks in â€œalready winningâ€ lanes)
        if (diff !== 'easy') dealerStandPhase(diff, 2);

        endDealerTurn();
      }, 600);
    }

    function endDealerTurn() {
      // Finalize busts at end of dealer turn
      finalizeBusts(blackjackMatch.dealerPositions, 'dealer');
      updateThreatTargetLane(false, 'bust_finalize');

      const fb = blackjackMatch.dealerBaseDeck || makeStandardDeck52();
      maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, fb, 'dealer');

      if (checkMatchEnd()) return;

      const playerDone = (countOpenPositions(blackjackMatch.playerPositions) === 0);
      const dealerDone = allPositionsComplete(blackjackMatch.dealerPositions);

      if (blackjackMatch.autoPassToEnd && playerDone && !dealerDone) {
        blackjackMatch.turn = 'dealer';
        renderBlackjack();
        setTimeout(dealerTurn, 250);
        return;
      }

      blackjackMatch.autoPassToEnd = false;
      blackjackMatch.turn = 'player';
      blackjackMatch.actionUsedThisTurn = false;
      blackjackMatch.actionSelectionInProgress = false;
      renderBlackjack();
    }


    function checkMatchEnd() {
      const playerDone = allPositionsComplete(blackjackMatch.playerPositions);
      const dealerDone = allPositionsComplete(blackjackMatch.dealerPositions);

      if (playerDone && dealerDone) {
        resolveMatch();
        return true;
      }

      if (playerDone && !dealerDone && blackjackMatch.turn === 'player') {
        blackjackMatch.turn = 'dealer';
        renderBlackjack();
        clearDealerTimers();
        dealerTimerA = setTimeout(dealerTurn, 800);
        return true;
      }

      return false;
    }

    function resolveMatch(options = {}) {
      blackjackMatch.phase = 'resolved';
      blackjackMatch.autoPassToEnd = false;
      clearDealerTimers();
      const chipsBefore = safeNumber(run.chips, 0);

      // defensive finalize
      finalizeBusts(blackjackMatch.playerPositions, 'player');
      finalizeBusts(blackjackMatch.dealerPositions, 'dealer');

      let playerWins = 0;
      let dealerWins = 0;
      const positionResults = [];
      let transferNet = 0;

      const playerTotals = [];
      const dealerTotals = [];
      const playerBusts = [];
      const dealerBusts = [];
      const laneTransferRaw = Array(LANE_COUNT).fill(0);
      const laneBonus = Array(LANE_COUNT).fill(0);

      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const pPos = blackjackMatch.playerPositions[i];
        const dPos = blackjackMatch.dealerPositions[i];

        const pTotal = getPositionTotal(pPos);
        const dTotal = getPositionTotal(dPos);
        const pBust = !!pPos.isBust;
        const dBust = !!dPos.isBust;

        playerTotals.push(pTotal);
        dealerTotals.push(dTotal);
        playerBusts.push(pBust);
        dealerBusts.push(dBust);

        let result;
        if (!pBust && (dBust || pTotal > dTotal)) {
          playerWins++;
          result = 'player';
        } else if (!dBust && (pBust || dTotal > pTotal)) {
          dealerWins++;
          result = 'dealer';
        } else {
          result = 'push';
        }
        positionResults.push(result);

        let raw = 0;
        if ((pBust && dBust) || (!pBust && !dBust && pTotal === dTotal)) raw = 0;
        else if (!pBust && dBust) raw = pTotal;
        else if (pBust && !dBust) raw = -dTotal;
        else raw = pTotal - dTotal;
        laneTransferRaw[i] = raw;

        // Transfers
        if ((pBust && dBust) || (!pBust && !dBust && pTotal === dTotal)) continue;

        if (!pBust && dBust) transferNet += pTotal;
        else if (pBust && !dBust) transferNet -= dTotal;
        else if (!pBust && !dBust) {
          const diff = Math.abs(pTotal - dTotal);
          transferNet += (pTotal > dTotal) ? diff : -diff;
        }
      }

      const transferMultiplier = blackjackMatch.transferMultiplier || 1;
      transferNet *= transferMultiplier;
      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const p = blackjackMatch.playerPositions[i];
        if (p && p.bonus21Awarded) laneBonus[i] += BLACKJACK_21_REWARD;
      }

      let outcome;
      let payout;
      if (playerWins > dealerWins) {
        outcome = 'WIN';
        payout = blackjackMatch.buyIn * 2;
      } else if (dealerWins > playerWins) {
        outcome = 'LOSS';
        payout = 0;
      } else {
        outcome = 'TIE';
        payout = blackjackMatch.buyIn;
      }

      const bf = run && run.bossFight;
      const isBossRound = blackjackMatch.type === 'BOSS' && bf && bf.active;

      // Boss tie = loss (only for legacy single-round boss fights)
      if (!isBossRound && blackjackMatch.type === 'BOSS' && outcome === 'TIE') {
        outcome = 'LOSS';
        payout = 0;
      }

      if (options && options.forcedOutcome) {
        outcome = options.forcedOutcome;
        if (outcome === 'WIN') payout = blackjackMatch.buyIn * 2;
        else if (outcome === 'LOSS') payout = 0;
        else payout = blackjackMatch.buyIn;
      }

      blackjackMatch.transferChipsNet = transferNet;
      let bossDefeatedNow = false;

      if (isBossRound && outcome === 'WIN') {
        const laneDamage = positionResults.reduce((sum, r, i) => sum + (r === 'player' ? playerTotals[i] : 0), 0);
        const lanesWon = playerWins;
        const tm = blackjackMatch.transferMultiplier || 1;
        const bonusDamage = Math.min(5, Math.round(Math.min(5, lanesWon) * ((tm - 1) / 4)));
        const totalDamage = laneDamage + bonusDamage;
        const hpBefore = bf.hp;
        bf.hp = Math.max(0, bf.hp - totalDamage);
        bossDefeatedNow = bf.hp === 0;

        blackjackMatch.bossDamage = {
          laneDamage,
          bonusDamage,
          totalDamage,
          hpBefore,
          hpAfter: bf.hp,
          lanesWon,
          transferMultiplier: tm
        };

        logEvent('BOSS_DAMAGE', blackjackMatch.bossDamage);
      }

      if (isBossRound && bf.phase === 1 && bf.hp > 0 && bf.hp <= bf.maxHp / 2) {
        bf.phase = 2;
        bf.targetLaneIdx = null;
      }

      let goldBonusTotal = 0;
      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const goldCount = countGoldSleeves(blackjackMatch.playerPositions[i]);
        if (!goldCount) continue;
        if (positionResults[i] !== 'player') continue;

        const amount = safeNumber(playerTotals[i], 0) * goldCount;
        if (amount > 0) {
          goldBonusTotal += amount;
          laneBonus[i] = safeNumber(laneBonus[i], 0) + amount;
          blackjackMatch.bonusChipsEarned = safeNumber(blackjackMatch.bonusChipsEarned, 0) + amount;
          run.chips = safeNumber(run.chips) + amount;
          logEvent('GOLD_SLEEVE_BONUS', { laneIdx: i + 1, amount, count: goldCount });
        }
      }

      const callingRankBefore = run.callingCard ? run.callingCard.rank : null;
      const karmaBreakdown = buildKarmaBreakdown(positionResults, playerTotals);
      const karmaLaneGain = karmaBreakdown.lanes.reduce((sum, lane) => sum + lane.laneTotal, 0);
      const karmaStampTotal = karmaBreakdown.lanes.reduce((sum, lane) => sum + lane.stampTotal, 0);
      const karmaPatternTotal = karmaBreakdown.lanes.reduce((sum, lane) => sum + lane.patternTotal, 0);
      const karmaExtras = [];

      if (outcome === 'WIN') {
        const decisiveMap = { 2: 10, 3: 25, 4: 45, 5: 70 };
        const decisive = decisiveMap[playerWins] || 0;
        if (decisive > 0) karmaExtras.push({ name: 'Decisive Win', delta: decisive, kind: 'decisive' });

        run.karmaWinStreak = safeNumber(run.karmaWinStreak, 0) + 1;
        const s = run.karmaWinStreak;
        let streakBonus = 0;
        if (s >= 5) streakBonus = 75;
        else if (s === 4) streakBonus = 50;
        else if (s === 3) streakBonus = 30;
        else if (s === 2) streakBonus = 15;
        if (streakBonus > 0) karmaExtras.push({ name: `Win Streak x${s}`, delta: streakBonus, kind: 'streak' });

        if (safeNumber(blackjackMatch.metrics.playerBustsFinal, 0) === 0) {
          karmaExtras.push({ name: 'No Bust Win', delta: 20, kind: 'clean' });
        }

        const twentyOneWins = positionResults.reduce((n, r, i) => n + ((r === 'player' && safeNumber(playerTotals[i], 0) === 21) ? 1 : 0), 0);
        const exact21Bonus = Math.min(50, twentyOneWins * 10);
        if (exact21Bonus > 0) karmaExtras.push({ name: '21-on-Win', delta: exact21Bonus, kind: 'twentyone' });
      } else {
        run.karmaWinStreak = 0;
      }

      if (outcome === 'WIN') {
        if (isBossRound) {
          const roundWeight = Math.max(1, (bf.maxRounds - bf.round + 1));
          const lanesWon = playerWins;
          const bonusDamage = blackjackMatch.bossDamage ? blackjackMatch.bossDamage.bonusDamage : 0;
          const bossWinBonus = (25 * roundWeight) + (10 * lanesWon) + (5 * bonusDamage);
          if (bossWinBonus > 0) karmaExtras.push({ name: 'Boss Win Bonus', delta: bossWinBonus, kind: 'boss_win' });
          if (bossDefeatedNow) {
            karmaExtras.push({ name: 'Boss Defeat Bonus', delta: 50 * roundWeight, kind: 'boss_defeat' });
          }
        } else {
          const baseBonus = blackjackMatch.type === 'STANDARD' ? 50 : 100;
          const standardWinBonus = baseBonus * transferMultiplier;
          if (standardWinBonus > 0) karmaExtras.push({ name: 'Match Win Bonus', delta: standardWinBonus, kind: 'match_win' });
        }
      }

      const karmaExtraTotal = karmaExtras.reduce((sum, e) => sum + safeNumber(e.delta, 0), 0);
      let karmaGained = karmaLaneGain + karmaExtraTotal;

      if (blackjackMatch.type === 'HIGH_STAKES') {
        const bonus = Math.floor(karmaGained * (HIGH_STAKES_KARMA_MULT - 1));
        if (bonus > 0) {
          karmaExtras.push({ name: `High Stakes x${HIGH_STAKES_KARMA_MULT}`, delta: bonus, kind: 'high_stakes' });
          karmaGained += bonus;
        }
      }
      let ventureFundChips = 0;
      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        if (positionResults[i] !== 'player') continue;
        const laneCards = blackjackMatch.playerPositions[i].cards || [];
        const vfCount = collectLaneCardsForEffects(laneCards).filter(c => getCardStampId(c) === 'VENTURE_FUND').length;
        const laneKarmaTotal = safeNumber(karmaBreakdown.lanes[i]?.laneTotal, 0);
        if (vfCount > 0) {
          const gain = laneKarmaTotal * vfCount;
          ventureFundChips += gain;
          laneBonus[i] += gain;
        }
      }
      if (ventureFundChips > 0) {
        run.chips = safeNumber(run.chips) + ventureFundChips;
        blackjackMatch.bonusChipsEarned += ventureFundChips;
      }
      run.karma = Math.max(0, safeNumber(run.karma, 0) + karmaGained);
      const levelUpSummary = maybeLevelUpCallingCardFromKarma();
      const callingRankAfter = run.callingCard ? run.callingCard.rank : null;

      blackjackMatch.result = {
        outcome,
        payout,
        playerWins,
        dealerWins,
        positionResults,
        transferMultiplier,
        exhaustion: options.exhaustion || null,
        karmaGained,
        karmaBreakdown: { ...karmaBreakdown, extras: karmaExtras, total: karmaGained }
      };
      const laneTransferNet = laneTransferRaw.map(v => safeNumber(v, 0) * transferMultiplier);
      const laneTotal = laneTransferNet.map((v, i) => v + safeNumber(laneBonus[i], 0));
      blackjackMatch.result.laneChip = {
        transferMultiplier,
        transferRawByLane: laneTransferRaw.slice(),
        transferNetByLane: laneTransferNet.slice(),
        bonusByLane: laneBonus.slice(),
        totalByLane: laneTotal
      };

      // finalize bust counts for match metrics
      blackjackMatch.metrics.playerBustsFinal = blackjackMatch.playerPositions.filter(p => p.isBust).length;
      blackjackMatch.metrics.dealerBustsFinal = blackjackMatch.dealerPositions.filter(p => p.isBust).length;

      const burnCards = [];
      blackjackMatch.playerPositions.forEach(pos => {
        collectLaneCardsForEffects(pos.cards).forEach(card => {
          if (getCardStampId(card) === 'BURN_AFTER_READING') burnCards.push(card);
        });
      });
      const burnedSleeves = blackjackMatch.burnedSleeveCards || [];
      if (burnCards.length || burnedSleeves.length) {
        const burnSet = new Set([...burnCards, ...burnedSleeves]);
        run.playerDeck = run.playerDeck.filter(card => isKeyCard(card) || !burnSet.has(card));
        recordDeckSnapshot('BURN_AFTER_READING');
      }
      if (burnCards.length) {
        logEvent('BURN_AFTER_READING', {
          count: burnCards.length,
          cards: burnCards.map(cardToString),
          cardUids: burnCards.map(card => card.uid || null),
          cardRefs: burnCards.map(cardRef)
        });
      }

      // House rake applies to positive net results (payout + transfer) only
const grossWin = payout + transferNet;
const rakeRate = getHouseRakeRate(run.floor);
const rake = (grossWin > 0 && rakeRate > 0) ? Math.floor(grossWin * rakeRate) : 0;

blackjackMatch.result.rake = rake;
blackjackMatch.result.rakeRate = rakeRate;

run.chips = safeNumber(run.chips) + payout + transferNet - rake;
      blackjackMatch.result.chipsBefore = chipsBefore;
      blackjackMatch.result.chipsAfter = safeNumber(run.chips, 0);
      blackjackMatch.postMatchGameOver = run.chips < 0;
      blackjackMatch.postMatchGameOverReason = blackjackMatch.postMatchGameOver ? 'CHIPS_NEGATIVE' : null;

      const durationMs = Math.round(performance.now() - blackjackMatch.metrics.startedAtMs);

      logEvent('MATCH_END', {
        type: blackjackMatch.type,
        outcome,
        matchSeq: blackjackMatch.matchSeq,
        buyIn: blackjackMatch.buyIn,
        payout,
        playerWins,
        dealerWins,
        transferNet,
        transferMultiplier,
        rake,
        rakeRate,
        bonusChips: blackjackMatch.bonusChipsEarned || 0,
        karmaGained,
        callingRankBefore,
        callingRankAfter,
        levelsGained: levelUpSummary ? levelUpSummary.levelsGained : 0,
        karmaLaneGain,
        karmaStampTotal,
        karmaPatternTotal,
        karmaExtraTotal,
        karmaExtras,
        exhaustion: options.exhaustion || null,
        durationMs,
        lanes: {
          playerTotals, dealerTotals,
          playerBusts, dealerBusts,
          laneWinners: positionResults
        },
        metrics: { ...blackjackMatch.metrics },
        laneCards: blackjackMatch.metrics.laneCards,
        deckSnapshot: deckSnapshot()
      });

      if (karmaGained > 0) {
        logEvent('KARMA_GAIN', { amount: karmaGained, total: run.karma, laneKarma: karmaLaneGain, stampKarma: karmaStampTotal, patternKarma: karmaPatternTotal, extraKarma: karmaExtraTotal });
      }

      const bonus = blackjackMatch.bonusChipsEarned || 0;
      startEarningsSequence({ payout, sideBet: transferNet, rake, bonus }, () => startScoreSequence(karmaBreakdown, karmaExtras, karmaGained, levelUpSummary));

      renderAll();

      if (transferNet !== 0) showToast(`Side bet result: ${transferNet > 0 ? '+' : ''}${transferNet} chips`);

      // Winner reward flow (only if WIN)
      if (blackjackMatch.result.outcome === 'WIN') {
        if (isBossRound) {
          if (bossDefeatedNow) {
            blackjackMatch.rewardPending = true;
            blackjackMatch.pendingRewardStart = true;
            if (!isResolutionAnimationActive()) {
              blackjackMatch.pendingRewardStart = false;
              startWinnerRewardFlow();
            }
          }
        } else {
          blackjackMatch.rewardPending = true;
          blackjackMatch.pendingRewardStart = true;
          if (!isResolutionAnimationActive()) {
            blackjackMatch.pendingRewardStart = false;
            startWinnerRewardFlow();
          }
        }
      }
    }

    // =============================================
    // WINNER REWARD FLOW (after a WIN)
    // =============================================
    function startWinnerRewardFlow() {
      if (blackjackMatch.specialReward === 'KEY_HIGH') {
        const key = makeKeyCard('HIGH_STAKES');
        assignUid(key);
        run.playerDeck.push(key);
        if (run.secret && run.secret.keys) run.secret.keys.highStakes.obtained = true;
        logEvent('KEYCARD_OBTAINED', { source: 'HIGH_STAKES', card: cardRef(key) });
        recordDeckSnapshot('KEYCARD_HIGH_STAKES');
        blackjackMatch.rewardPending = false;
        blackjackMatch.winnerReward = null;
        showToast('You won a star keycard.');
        return;
      }
      if (blackjackMatch.type === 'BOSS' && run.floor === 3 && run.secret && run.secret.keys && !run.secret.keys.boss.obtained) {
        const key = makeKeyCard('BOSS');
        assignUid(key);
        run.playerDeck.push(key);
        run.secret.keys.boss.obtained = true;
        logEvent('KEYCARD_OBTAINED', { source: 'BOSS', card: cardRef(key) });
        recordDeckSnapshot('KEYCARD_BOSS');
        blackjackMatch.rewardPending = false;
        blackjackMatch.winnerReward = null;
        showToast('The boss dropped a star keycard.');
        return;
      }
      if (blackjackMatch.type === 'BOSS') {
        startBossFusionRewardFlow();
        return;
      }
      blackjackMatch.winnerReward = { stage: 'mode', mode: null, candidates: [], selected: null };
      showWinnerRewardModeModal();
    }

    function startBossFusionRewardFlow() {
      blackjackMatch.winnerReward = { stage: 'pick', mode: 'fuse', candidates: [], selected: [] };
      const eligible = run.playerDeck
        .map((c, i) => ({ card: c, index: i }))
        .filter(d => isStandardCard(d.card));

      const picks = shuffle(eligible).slice(0, 5);
      blackjackMatch.winnerReward.candidates = picks;
      blackjackMatch.winnerReward.selected = [];

      showBossFusionModal();
    }

    function showBossFusionModal() {
      const wr = blackjackMatch.winnerReward;
      const candidates = wr.candidates || [];
      const selected = wr.selected || [];
      const canFuse = candidates.length >= 2;

      const body = `
        <p class="modal-text">Boss reward: pick two cards to fuse (or choose none).</p>
        <div class="removal-picker">
          <div class="removal-cards">
            ${candidates.map((d, idx) => {
              const sel = selected.includes(idx) ? 'selected' : '';
              return `
                <div class="removal-card-option ${sel}" onclick="selectFusionCard(${idx})">
                  ${renderCard(d.card, false)}
                </div>
              `;
            }).join('')}
          </div>
        </div>
        ${canFuse ? '' : '<p class="modal-text" style="color:var(--text-muted); text-align:center;">Not enough eligible cards to fuse.</p>'}
      `;

      showModal('Fuse Cards', body, [
        { text: 'Confirm Fusion', primary: true, disabled: !canFuse || selected.length !== 2, action: confirmFusionReward },
        { text: 'Choose None', action: () => finishFusionReward(null) }
      ]);
    }

    window.selectFusionCard = function(idx) {
      const wr = blackjackMatch.winnerReward;
      if (!wr || wr.mode !== 'fuse') return;
      const selected = wr.selected || [];
      if (selected.includes(idx)) {
        wr.selected = selected.filter(i => i !== idx);
      } else if (selected.length < 2) {
        wr.selected = [...selected, idx];
      }
      showBossFusionModal();
    };

    function confirmFusionReward() {
      const wr = blackjackMatch.winnerReward;
      if (!wr || wr.mode !== 'fuse') return;
      if (!wr.selected || wr.selected.length !== 2) return;
      const picks = wr.selected.map(i => wr.candidates[i]).filter(Boolean);
      if (picks.length !== 2) return;
      finishFusionReward(picks);
    }

    function finishFusionReward(picks) {
      if (!blackjackMatch) return;
      if (picks && picks.length === 2) {
        const [a, b] = picks;
        const sorted = [a.index, b.index].sort((x, y) => y - x);
        const cardA = run.playerDeck[a.index];
        const cardB = run.playerDeck[b.index];
        sorted.forEach(idx => run.playerDeck.splice(idx, 1));
        const fused = { uid: null, type: 'FUSE', a: cardA, b: cardB };
        assignUid(fused);
        run.playerDeck.push(fused);
        logEvent('WINNER_REWARD_FUSE', {
          cards: [cardToString(cardA), cardToString(cardB)],
          cardUids: [cardA?.uid || null, cardB?.uid || null],
          cardRefs: [cardRef(cardA), cardRef(cardB)],
          fused: `${cardToString(cardA)}/${cardToString(cardB)}`,
          deckSnapshot: deckSnapshot()
        });
        recordDeckSnapshot('REWARD_FUSE');
        showToast(`Fused ${cardToString(cardA)} + ${cardToString(cardB)}`);
      } else {
        logEvent('WINNER_REWARD_SKIP', { mode: 'fuse' });
        showToast('Fusion skipped');
      }

      blackjackMatch.rewardPending = false;
      blackjackMatch.winnerReward = null;
      closeModal();
      renderAll();
    }

    function showWinnerRewardModeModal() {
      showModal('Winner Reward', `
        <p class="modal-text">You won the match. Choose a deck reward:</p>
        <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:12px;">
          <button class="modal-btn danger" onclick="chooseWinnerRewardMode('remove')">Remove</button>
          <button class="modal-btn" onclick="chooseWinnerRewardMode('duplicate')">Duplicate</button>
        </div>
        <p class="modal-text" style="margin-top:14px; color:var(--text-muted); text-align:center;">You will see 5 random cards and may pick one or choose none.</p>
      `, [
        { text: 'Skip', action: () => { finishWinnerReward(null, null); } }
      ]);
    }

    window.chooseWinnerRewardMode = function(mode) {
      if (!blackjackMatch || blackjackMatch.phase !== 'resolved') return;
      blackjackMatch.winnerReward.mode = mode;
      blackjackMatch.winnerReward.stage = 'pick';

      const eligibleIdxs = run.playerDeck.map((c,i)=>({c,i})).filter(d => !isKeyCard(d.c)).map(d=>d.i);
      const picks = shuffle(eligibleIdxs).slice(0, Math.min(5, eligibleIdxs.length));
      blackjackMatch.winnerReward.candidates = picks.map(i => ({ index: i, card: run.playerDeck[i] }));
      blackjackMatch.winnerReward.selected = null;

      logEvent('WINNER_REWARD_MODE', { mode });

      showWinnerRewardPickModal();
    };

    function showWinnerRewardPickModal() {
      const wr = blackjackMatch.winnerReward;
      const mode = wr.mode;

      const title = mode === 'remove' ? 'Remove a Card' : 'Duplicate a Card';
      const sub = mode === 'remove'
        ? 'Select a card to remove (one copy).'
        : 'Select a card to duplicate (add one copy).';

      const candidates = wr.candidates;
      const selected = wr.selected;

      const body = `
        <p class="modal-text">${sub}</p>
        <div class="removal-picker">
          <div class="removal-cards">
            ${candidates.map((d, idx) => {
              const sel = selected === idx ? 'selected' : '';
            return `
              <div class="removal-card-option ${sel}" onclick="selectWinnerRewardCard(${idx})">
                  ${renderCard(d.card, false)}
              </div>
            `;
            }).join('')}
          </div>
        </div>
      `;

      showModal(title, body, [
        { text: 'Confirm', primary: true, disabled: selected === null, action: confirmWinnerReward },
        { text: 'Choose None', action: () => finishWinnerReward(mode, null) }
      ]);
    }

    window.selectWinnerRewardCard = function(idx) {
      blackjackMatch.winnerReward.selected = idx;
      showWinnerRewardPickModal();
    };

    function confirmWinnerReward() {
      const wr = blackjackMatch.winnerReward;
      if (wr.selected === null) return;
      const d = wr.candidates[wr.selected];
      finishWinnerReward(wr.mode, d);
    }

    function finishWinnerReward(mode, pickData) {
      if (!blackjackMatch) return;

      if (mode && pickData) {
        if (mode === 'remove') {
          const removed = run.playerDeck[pickData.index];
          if (!removed || isKeyCard(removed)) { showToast('Cannot remove keycards'); return; }
          run.playerDeck.splice(pickData.index, 1);
          logEvent('WINNER_REWARD_APPLY', { mode, card: cardToString(removed), cardUid: removed?.uid || null, cardRef: cardRef(removed), deckSnapshot: deckSnapshot() });
          recordDeckSnapshot('REWARD_REMOVE');
          showToast(`Removed ${cardToString(removed)}`);
        } else if (mode === 'duplicate') {
          const c = run.playerDeck[pickData.index];
          if (!c || isKeyCard(c)) { showToast('Cannot duplicate keycards'); return; }
          if (c) {
            const clone = cloneCardWithNewUid(c);
            assignUid(clone);
            run.playerDeck.push(clone);
          }
          logEvent('WINNER_REWARD_APPLY', { mode, card: cardToString(c), cardUid: c?.uid || null, cardRef: cardRef(c), deckSnapshot: deckSnapshot() });
          recordDeckSnapshot('REWARD_DUPLICATE');
          showToast(`Duplicated ${cardToString(c)}`);
        }
      } else {
        logEvent('WINNER_REWARD_SKIP', { mode: mode || null });
        showToast('Reward skipped');
      }

      blackjackMatch.rewardPending = false;
      blackjackMatch.winnerReward = null;

      closeModal();
      renderAll();
    }

    // =============================================
    // ACTION TOKENS + ACTION PICKER
    // =============================================
    function isPlayerActionContextOK(m) {
      return !!m && m.phase === 'playing' && m.turn === 'player';
    }

    function tokensRemaining() {
      if (!blackjackMatch) return 0;
      return Math.max(0, (blackjackMatch.tokensTotal || 0) - (blackjackMatch.tokensSpent || 0));
    }

    function canClickToken() {
      if (!blackjackMatch) return false;
      if (!isPlayerActionContextOK(blackjackMatch)) return false;
      if (blackjackMatch.actionUsedThisTurn) return false;
      if (blackjackMatch.actionSelectionInProgress) return false;
      if (tokensRemaining() <= 0) return false;
      if (!run.ownedActions || run.ownedActions.length === 0) return false;
      if (blackjackMatch.drawnCard) return false;
      return true;
    }

    window.onActionTokenClick = function() {
      if (!canClickToken()) return;

      blackjackMatch.tokensSpent += 1;
      blackjackMatch.actionUsedThisTurn = true;
      blackjackMatch.actionSelectionInProgress = true;

      logEvent('TOKEN_SPENT', { amount: 1, source: 'ACTION_PICKER' });

      renderBlackjack();
      openActionPickerModal();
    };

    window.useActionFromBar = function(actionId) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;
      if (blackjackMatch.turn !== 'player') return;
      if (!run.ownedActions || !run.ownedActions.includes(actionId)) return;

      const def = ACTIONS[actionId];
      if (!def) return;

      if (blackjackMatch.actionSelectionInProgress) return;
      if (blackjackMatch.actionUsedThisTurn) return;
      if (blackjackMatch.usedActions && blackjackMatch.usedActions[actionId]) return;

      if (tokensRemaining() <= 0) { showToast('No tokens left'); return; }
      if (def.isUsable && !def.isUsable(blackjackMatch)) { showToast('Action unavailable'); return; }

      blackjackMatch.tokensSpent = safeNumber(blackjackMatch.tokensSpent, 0) + 1;
      blackjackMatch.actionUsedThisTurn = true;
      blackjackMatch.actionSelectionInProgress = true;

      logEvent('TOKEN_SPENT', { amount: 1, source: 'COCKTAIL', actionId, via: 'ACTION_BAR' });
      renderAll();

      try {
        def.activate();
      } catch (e) {
        blackjackMatch.actionSelectionInProgress = false;
        renderAll();
        console.error(e);
        showToast('Action failed');
      }
    };

    function openActionPickerModal() {
      const owned = run.ownedActions || [];
      const used = blackjackMatch.usedActions || {};

      const listHtml = owned.map(id => {
        const def = ACTIONS[id];
        const alreadyUsed = !!used[id];
        const usable = def && def.isUsable(blackjackMatch);
        const disabled = alreadyUsed || !usable;

        const statusText = alreadyUsed ? 'USED' : (!usable ? 'UNAVAILABLE' : 'READY');
        const statusColor = alreadyUsed ? 'var(--text-muted)' : (!usable ? 'var(--accent-red)' : 'var(--accent-green)');

        return `
          <div class="action-row ${disabled ? 'disabled' : ''}">
            <div class="action-row-left">
              <div class="action-row-title">${def ? def.name : id}</div>
              <div class="action-row-desc">${def ? def.desc : ''}</div>
              <div class="action-row-desc" style="margin-top:6px; color:${statusColor}; font-weight:800;">${statusText}</div>
            </div>
            <div class="action-row-right">
              <button class="modal-btn" ${disabled ? 'disabled' : ''} onclick="attemptUseAction('${id}')">Use</button>
            </div>
          </div>
        `;
      }).join('');

      const body = `
        <p class="modal-text">Choose one action to perform. This selection consumes your token even if you cancel.</p>
        <div class="action-list">${listHtml || '<p class="modal-text">No actions unlocked.</p>'}</div>
      `;

      showModal('Actions', body, [
        {
          text: 'Cancel',
          action: () => {
            blackjackMatch.actionSelectionInProgress = false;
            closeModal();
            renderAll();
          }
        }
      ]);
    }

    window.attemptUseAction = function(actionId) {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing' || blackjackMatch.turn !== 'player') return;
      const def = ACTIONS[actionId];
      if (!def) return;

      if (blackjackMatch.usedActions[actionId]) {
        showToast('Already used this match');
        return;
      }
      if (!def.isUsable(blackjackMatch)) {
        showToast('Not usable right now');
        return;
      }

      def.activate();
    };

    function markActionUsed(actionId) {
      blackjackMatch.usedActions[actionId] = true;
      blackjackMatch.actionSelectionInProgress = false;

      blackjackMatch.metrics.actionsUsed += 1;

      const def = ACTIONS[actionId];
      logEvent('ACTION_USED', {
        actionId,
        actionName: def ? def.name : actionId,
        tokensRemaining: tokensRemaining()
      });
    }

    // =============================================
    // ACTION IMPLEMENTATIONS
    // =============================================
    function closeModalAndRender() {
      closeModal();
      renderAll();
    }

    function cancelActionSelection() {
      if (blackjackMatch) blackjackMatch.actionSelectionInProgress = false;
      closeModalAndRender();
    }

    function drawPlayableToHandOrBench() {
      let safety = 0;
      while (safety++ < 300) {
        const c = drawCardFromPile(blackjackMatch.playerDrawPile, run.playerDeck);
        if (!c) {
          triggerDeckExhaustion('player', 'action-draw');
          return null;
        }
        if (isModifier(c)) {
          benchPush(c, 'action-draw');
          blackjackMatch.metrics.modifiersBenched += 1;
          continue;
        }
        return c;
      }
      return null;
    }

    function showLanePickerModal(title, text, laneIndices, onPick) {
      if (!laneIndices || !laneIndices.length) {
        showToast('No valid lanes');
        cancelActionSelection();
        return;
      }

      const btns = laneIndices.map(i => ({
        text: `Lane #${i + 1}`,
        action: () => onPick(i)
      }));

      btns.push({ text: 'Cancel', action: cancelActionSelection });

      showModal(title, `<p class="modal-text">${text}</p>`, btns);
    }

    function pickDealerLaneModal(title, text, onPick) {
      const laneIndices = blackjackMatch.dealerPositions
        .map((p, i) => ({ p, i }))
        .filter(x => x.p.isOpen && !x.p.isComplete)
        .map(x => x.i);

      showLanePickerModal(title, text, laneIndices, onPick);
    }

    function pickPlayerRevivalLaneModal(title, text, eligible, onPick) {
      showLanePickerModal(title, text, eligible, onPick);
    }

    // Eligible revival lanes: any "closed" = isOpen && isComplete (stood OR busted)
    function getEligibleRevivalLanes(m) {
      const eligible = [];
      for (let i = 0; i < m.playerPositions.length; i++) {
        const p = m.playerPositions[i];
        if (p && p.isOpen && p.isComplete) eligible.push(i);
      }
      return eligible;
    }

    window.chooseSplitDecision = function(choiceIdx) {
      if (!blackjackMatch) return;
      const choices = blackjackMatch.splitDecisionChoices;
      if (!choices || !choices.a || !choices.b) return;

      const a = choices.a;
      const b = choices.b;

      const playerCard = choiceIdx === 0 ? a : b;
      const dealerCard = choiceIdx === 0 ? b : a;

      delete blackjackMatch.splitDecisionChoices;

      blackjackMatch.drawnCard = playerCard;
      blackjackMatch.pending = { type: 'splitDecision', dealerGiftCard: dealerCard };

      markActionUsed('splitDecision');
      closeModal();
      renderAll();
      showToast('Place your chosen card');
    };

    // Split Decision
    function activateSplitDecision() {
      const a = drawPlayableToHandOrBench();
      const b = drawPlayableToHandOrBench();
      if (!a || !b) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      blackjackMatch.splitDecisionChoices = { a, b };

      showModal('Split Decision', `
        <p class="modal-text">Choose a card to play. The other card will be played by the Dealer immediately after your placement.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          <button class="modal-btn primary" onclick="chooseSplitDecision(0)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(a)}</span>
          </button>
          <button class="modal-btn primary" onclick="chooseSplitDecision(1)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(b)}</span>
          </button>
        </div>
      `, [
        {
          text: 'Cancel',
          action: () => {
            delete blackjackMatch.splitDecisionChoices;
            blackjackMatch.actionSelectionInProgress = false;
            closeModal();
            renderAll();
          }
        }
      ]);
    }

    // Second Opinion
    function activateSecondOpinion() {
      const a = drawPlayableToHandOrBench();
      const b = drawPlayableToHandOrBench();
      if (!a || !b) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }

      showModal('Second Opinion', `
        <p class="modal-text">Choose a card to play. The other will be discarded.</p>
        <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
          <button class="modal-btn primary" onclick="chooseSecondOpinion(0)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(a)}</span>
          </button>
          <button class="modal-btn primary" onclick="chooseSecondOpinion(1)">
            <span style="font-family:'Fira Code', monospace;">${cardToString(b)}</span>
          </button>
        </div>
      `, [
        { text: 'Cancel', action: () => { blackjackMatch.actionSelectionInProgress = false; closeModal(); renderAll(); } }
      ]);

      window.chooseSecondOpinion = function(choiceIdx) {
        const chosen = choiceIdx === 0 ? a : b;
        blackjackMatch.drawnCard = chosen;

        markActionUsed('secondOpinion');
        closeModal();
        renderAll();
        showToast('Place your chosen card');
      };
    }

    // Benched (ends turn)
    function activateBenched() {
      const c = drawPlayableToHandOrBench();
      if (!c) {
        showToast('No playable cards');
        blackjackMatch.actionSelectionInProgress = false;
        closeModal();
        renderAll();
        return;
      }
      benchPush(c, 'action-benched');

      markActionUsed('benched');
      closeModal();
      renderAll();
      showToast(`Benched ${cardToString(c)}`);
      endPlayerTurn();
    }

    // Spy Network
    function activateSpyGlass() {
      for (let i = 0; i < blackjackMatch.dealerPositions.length; i++) blackjackMatch.spyReveals.add(i);
      markActionUsed('spyGlass');
      closeModal();
      renderAll();
      showToast('Revealed all Dealer lanes');
    }

    // Forced Play
    function activateForcedPlay() {
      pickDealerLaneModal('Forced Play', 'Choose a Dealer lane. The Dealer\'s next placed card must go there if still valid.', (idx) => {
        blackjackMatch.dealerForcedLane = idx;
        markActionUsed('forcedPlay');
        closeModal();
        renderAll();
        showToast(`Forced next Dealer play into lane #${idx + 1}`);
      });
    }

    // Revival
    function activateRevival() {
      const eligible = getEligibleRevivalLanes(blackjackMatch);
      pickPlayerRevivalLaneModal(
        'Revival',
        'Choose any of your closed lanes (stood or busted) to reopen.',
        eligible,
        (idx) => {
          const pos = blackjackMatch.playerPositions[idx];
          pos.isComplete = false;
          pos.isBust = false;
          markActionUsed('revival');
          closeModal();
          renderAll();
          showToast(`Reopened lane #${idx + 1}`);
        }
      );
    }

    // Find My Card (ends turn)
    function activateFindMyCard() {
      const pile = blackjackMatch.playerDrawPile;
      const scanN = Math.min(10, pile.length);
      let foundIndexFromEnd = -1;

      for (let k = 0; k < scanN; k++) {
        const idx = pile.length - 1 - k;
        const c = pile[idx];
        if (isModifier(c)) { foundIndexFromEnd = idx; break; }
      }

      if (foundIndexFromEnd >= 0) {
        const mod = pile.splice(foundIndexFromEnd, 1)[0];
        benchPush(mod, 'action-findMyCard');
        blackjackMatch.metrics.modifiersBenched += 1;
        showToast(`Found ${cardToString(mod)} (benched)`);
      } else {
        showToast('No modifier found');
      }

      markActionUsed('findMyCard');
      closeModal();
      renderAll();
      endPlayerTurn();
    }

    // Closer
    function activateCloser() {
      pickDealerLaneModal('Closer', 'Choose a Dealer lane to close immediately.', (idx) => {
        const pos = blackjackMatch.dealerPositions[idx];
        pos.isComplete = true;
        pos.isBust = getPositionTotal(pos) > 21;
        blackjackMatch.metrics.dealerStands += 1;

        maintainOpenPositions(blackjackMatch.dealerPositions, blackjackMatch.dealerDrawPile, makeStandardDeck52(), 'dealer');

        markActionUsed('closer');
        closeModal();
        renderAll();
        showToast(`Closed Dealer lane #${idx + 1}`);
      });
    }

    function shouldStartWatcher() {
      const keyCount = (run.playerDeck || []).filter(isKeyCard).length;
      const callingRank = run.callingCard ? rankToValue(run.callingCard.rank) : 0;
      return keyCount >= 3 && callingRank >= 10;
    }

    function startWatcherEncounter() {
      showModal('A New Opponent', `
        <p class="modal-text">"I've been watching. Your progress is... impressive."</p>
      `, [{
        text: 'Face The Watcher',
        primary: true,
        action: () => {
          closeModal();
          try { if (window.SFX) SFX.play('watcher_intro'); } catch(e){}
          const watcherCard = run.callingCard ? { ...run.callingCard } : { rank: 'A', suit: 'â™ ' };
          startBlackjackMatch('WATCHER', 0, {
            npcOverride: { name: 'The Watcher', callingCard: watcherCard },
            dealerDeckOverride: cloneDeck(run.playerDeck),
            enableTargeting: true
          });
          blackjackMatch.watcherTargetLaneIdx = null;
          updateThreatTargetLane(true, 'watcher_start');
          logEvent('WATCHER_START', { deckSize: run.playerDeck.length });
        }
      }]);
    }

    function showBossAdvanceModal(nextFloor) {
      const benchCap = BENCH_BASE_CAPACITY + (nextFloor - 1);

      const tokenLine = `
        <div style="display:flex;align-items:center;gap:10px;margin:10px 0;">
          <span class="token-icon" style="cursor:default;">+1</span>
          <div><b>Token</b> (Floor ${nextFloor} base)</div>
        </div>
      `;

      const benchLine = `<div style="margin:8px 0;"><b>Bench Capacity</b>: ${benchCap}</div>`;

      showModal(
        'Boss Cleared',
        `${tokenLine}${benchLine}<div class="muted">Continue to Floor ${nextFloor}</div>`,
        [{
          text: 'Continue',
          primary: true,
          action: () => {
            closeModal();
            initFloor(nextFloor);
            showToast(`Floor ${run.floor} begins!`);
            renderAll();
          }
        }]
      );
    }

    // =============================================
    // CONTINUE / END CONDITIONS
    // =============================================
    function skipResolutionAnimationsIfActive() {
      if (!blackjackMatch) return;
      if (!isResolutionAnimationActive()) return;

      if (blackjackMatch.earningsSeq && blackjackMatch.earningsSeq.active) blackjackMatch.earningsSeq.active = false;
      if (blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active) blackjackMatch.scoreSeq.active = false;

      if (blackjackMatch.pendingRewardStart) {
        blackjackMatch.pendingRewardStart = false;
        startWinnerRewardFlow();
      }

      renderAll();
    }

    function handleContinueRewardPending() {
      if (!blackjackMatch || !blackjackMatch.rewardPending) return false;

      if (blackjackMatch.pendingRewardStart) {
        blackjackMatch.pendingRewardStart = false;
        startWinnerRewardFlow();
      } else if (blackjackMatch.winnerReward) {
        showToast('Choose a reward to continue.');
      }
      return true;
    }

    function handleContinuePostMatchGameOver() {
      if (!blackjackMatch || !blackjackMatch.postMatchGameOver) return false;
      triggerGameOver(blackjackMatch.postMatchGameOverReason || 'CHIPS_NEGATIVE');
      return true;
    }

    function handleContinueWatcherMatch() {
      if (!blackjackMatch || blackjackMatch.type !== 'WATCHER') return false;

      const result = blackjackMatch.result;
      const win = result && result.outcome === 'WIN';
      logEvent(win ? 'WATCHER_CLEARED' : 'WATCHER_FAILED', { floor: run.floor });

      blackjackMatch = null;

      if (win) victory();
      else gameOver('You were outplayed by The Watcher.', 'WATCHER_LOSS');

      return true;
    }

    function handleContinueBossFightActive() {
      if (!blackjackMatch || blackjackMatch.type !== 'BOSS' || !(run && run.bossFight && run.bossFight.active)) return false;

      const bf = run.bossFight;
      const result = blackjackMatch.result;

      if (bf.hp <= 0) {
        try { if (window.SFX) SFX.play('boss_cleared'); } catch(e){}
        logEvent('BOSS_FIGHT_DEFEATED', { floor: run.floor, round: bf.round, maxRounds: bf.maxRounds });
        run.bossWins = safeNumber(run.bossWins, 0) + 1;
        run.bossFight = null;

        logEvent('BOSS_CLEARED', { floor: run.floor, bossWins: run.bossWins, benchCapacity: getBenchCapacity() });

        endCurrentFloorIfOpen({ endReason: 'BOSS_CLEARED' });
        blackjackMatch = null;

        if (run.floor < 3) {
          showBossAdvanceModal(run.floor + 1);
        } else {
          if (shouldStartWatcher()) startWatcherEncounter();
          else victory();
        }
        return true;
      }

      bf.benchCarry = (blackjackMatch.bench || []).slice();
      bf.roundsRemaining = Math.max(0, safeNumber(bf.roundsRemaining, bf.maxRounds) - 1);

      if (bf.roundsRemaining <= 0 && bf.hp > 0) {
        logEvent('BOSS_FIGHT_FAILED', { reason: 'TIME', floor: run.floor, boss: { hp: bf.hp, maxHp: bf.maxHp, round: bf.round, roundsRemaining: bf.roundsRemaining } });
        gameOver("Time expired. The boss remains.", 'BOSS_TIMER_EXPIRED');
        return true;
      }

      if (bf.round < bf.maxRounds) {
        startBossRound(bf.round + 1);
        renderAll();
      } else {
        logEvent('BOSS_FIGHT_FAILED', { reason: 'WITHSTOOD', floor: run.floor, boss: { hp: bf.hp, maxHp: bf.maxHp, round: bf.round } });
        gameOver("The boss withstands the assault.", 'BOSS_WITHSTOOD');
      }

      return true;
    }

    function handleContinueBossSingleMatch() {
      if (!blackjackMatch || blackjackMatch.type !== 'BOSS') return false;

      const result = blackjackMatch.result;
      if (result.outcome === 'WIN') {
        run.bossWins = safeNumber(run.bossWins, 0) + 1;
        logEvent('BOSS_CLEARED', { floor: run.floor, bossWins: run.bossWins, benchCapacity: getBenchCapacity() });

        endCurrentFloorIfOpen({ endReason: 'BOSS_CLEARED' });
        blackjackMatch = null;

        if (run.floor < 3) showBossAdvanceModal(run.floor + 1);
        else {
          if (shouldStartWatcher()) startWatcherEncounter();
          else victory();
        }
      } else {
        gameOver("You lost to the boss.", 'BOSS_LOSS');
      }

      return true;
    }

    function handleContinueStandardMatch() {
      // default: return to board
      blackjackMatch = null;
      run.ui.mode = 'BOARD';
      renderAll();
      return true;
    }

    window.blackjackContinue = function() {
      clearDealerTimers();
      if (!blackjackMatch) return;

      // Important: do NOT return here; original behavior continues into reward/gameover checks.
      skipResolutionAnimationsIfActive();

      if (handleContinueRewardPending()) return;
      if (handleContinuePostMatchGameOver()) return;
      if (handleContinueWatcherMatch()) return;
      if (handleContinueBossFightActive()) return;
      if (handleContinueBossSingleMatch()) return;

      handleContinueStandardMatch();
    };
    function triggerGameOver(reason) {
      if (reason === 'CHIPS_NEGATIVE') {
        gameOver('Chips below zero', 'CHIPS_NEGATIVE');
        return;
      }
      gameOver('Run ended.', reason || 'UNKNOWN');
    }

    function gameOver(message, reasonCode = 'UNKNOWN') {
      try { if (window.SFX) SFX.play('gameover'); } catch(e){}
      clearDealerTimers();
      run.ui.mode = 'GAMEOVER';
      run.ui.message = message;
      endCurrentFloorIfOpen({ endReason: reasonCode || 'GAMEOVER' });
      logEvent('GAME_END', { result: 'GAMEOVER', message, reasonCode });
      finalizeRunLog({ outcome: 'loss', message, reasonCode });
      renderAll();
      if (uiSettings.autoOpenLogOnEnd) openLogPanel('stats');
    }

    function victory() {
      try { if (window.SFX) SFX.play('victory'); } catch(e){}
      clearDealerTimers();
      run.ui.mode = 'VICTORY';
      endCurrentFloorIfOpen({ endReason: 'VICTORY' });
      logEvent('GAME_END', { result: 'VICTORY', reasonCode: 'VICTORY' });
      finalizeRunLog({ outcome: 'win', message: null, reasonCode: 'VICTORY' });
      renderAll();
      if (uiSettings.autoOpenLogOnEnd) openLogPanel('stats');
    }

    // =============================================
    // UI RENDERING
    // =============================================
    function getHudTokensValue(){
      if (blackjackMatch && blackjackMatch.phase === 'playing') {
        const total = safeNumber(blackjackMatch.tokensTotal, 0);
        const spent = safeNumber(blackjackMatch.tokensSpent, 0);
        return Math.max(0, total - spent);
      }
      return safeNumber(run && run.bankedTokens, 0);
    }

    function syncHudOffset(){
      const hud = document.getElementById('hud');
      if (!hud) return;
      const h = hud.offsetHeight || 70;
      document.documentElement.style.setProperty('--hud-offset', `${h}px`);
    }

    window.toggleHud = function(){
      if (!run || !run.ui) return;
      run.ui.hudCollapsed = !run.ui.hudCollapsed;
      renderHUD();
      requestAnimationFrame(syncHudOffset);
    };

    window.addEventListener('resize', () => {
      if (run && run.ui && window.innerWidth <= 520) run.ui.hudCollapsed = true;
      syncHudOffset();
    });

    function renderAll() {
      renderHUD();
      renderBoard();
      renderBlackjack();
      renderEndScreen();
    }

    function renderHUD() {
      const hud = document.getElementById('hud');
      let chips = safeNumber(run.chips, 0);
      let karma = safeNumber(run.karma, 0);
      if (blackjackMatch) {
        const es = blackjackMatch.earningsSeq;
        if (es && es.active && blackjackMatch.result) {
          const before = safeNumber(blackjackMatch.result.chipsBefore, chips);
          chips = before + safeNumber(es.accrued, 0);
        }
        const ss = blackjackMatch.scoreSeq;
        if (ss && ss.active) {
          const total = safeNumber(ss.total, 0);
          const accrued = safeNumber(ss.accrued, 0);
          karma = safeNumber(run.karma, 0) - (total - accrued);
        }
      }
      const loanStatus = run.loan.active ? (run.loan.repaid ? 'Repaid' : `Owed: ${LOAN_REPAY}`) : 'None';
      const canRepay = run.loan.active && !run.loan.repaid && chips >= LOAN_REPAY;
      const rankInfo = getCallingRankInfo();
      const pulseClass = (run.ui && safeNumber(run.ui.callingRankPulseUntil, 0) > Date.now()) ? 'calling-rank-pulse' : '';
      const callingText = run.callingCard ? `${run.callingCard.rank}${run.callingCard.suit}` : 'â€”';
      const rankLine = rankInfo
        ? (rankInfo.isMax ? `Rank ${rankInfo.rank} Â· MAX` : `Rank ${rankInfo.current.rank} â†’ ${rankInfo.next.rank}`)
        : 'Rank â€”';
      const toNext = rankInfo ? (rankInfo.isMax ? 'Max rank reached' : `${rankInfo.toNext} karma to next rank`) : '';
      const prog = rankInfo ? Math.round(rankInfo.progress * 100) : 0;
      const collapsed = !!(run && run.ui && run.ui.hudCollapsed);
      const ccVal = run && run.callingCard ? cardToString(run.callingCard) : 'â€”';

      const tokenOrCallingLabel = collapsed ? 'Calling Card' : 'Tokens';
      const tokenOrCallingValue = collapsed ? ccVal : getHudTokensValue();
      const debtWarning = (run.loan.active && !run.loan.repaid)
        ? '<span class="hud-stat-label" style="color:var(--accent-red);">Debt!</span>'
        : '';

      hud.classList.toggle('hud-collapsed', collapsed);

      hud.innerHTML = `
        <div class="hud-primary">
          <div class="hud-primary-left">
            <div class="hud-stat">
              <span class="hud-stat-label">Floor</span>
              <span class="hud-stat-value">${run.floor}/3</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Chips</span>
              <span class="hud-stat-value chips">${chips}</span>
              ${debtWarning}
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Karma</span>
              <span class="hud-stat-value karma">${karma}</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">${tokenOrCallingLabel}</span>
              <span class="hud-stat-value tokens">${tokenOrCallingValue}</span>
            </div>
          </div>

          <div class="hud-primary-right">
            <button class="hud-icon-btn" title="Home" onclick="showStartScreen()">ðŸ </button>
            <button class="hud-icon-btn" title="Deck Viewer" onclick="openDeckViewer()">ðŸƒ</button>
            <button class="hud-icon-btn" title="Rules" onclick="openRulesPanel()">ðŸ“–</button>
            <button class="hud-icon-btn" title="${collapsed ? 'Expand HUD' : 'Collapse HUD'}" onclick="toggleHud()">${collapsed ? 'â–¾' : 'â–´'}</button>
          </div>
        </div>

        <div class="hud-secondary">
          <div class="hud-left">
            <div class="hud-stat">
              <span class="hud-stat-label">Player</span>
              <span class="hud-stat-value">${escapeHtml(run.playerName || 'â€”')}</span>
            </div>
            <div class="hud-bank">
              <div class="hud-stat-label">Bank</div>
              <div class="hud-bank-main">Chips ${chips}</div>
              <div class="hud-bank-sub">Rake ${Math.round(getHouseRakeRate(run.floor) * 100)}% Â· Debt ${escapeHtml(loanStatus)}</div>
            </div>
            <div class="hud-calling ${pulseClass}">
              <div class="hud-calling-row">
                <span class="hud-stat-label">Calling Card</span>
                <span class="hud-calling-main">${callingText}</span>
              </div>
              <div class="hud-calling-row">
                <span class="hud-calling-sub">Karma ${karma}</span>
                <span class="hud-calling-sub">${rankLine}</span>
              </div>
              <div class="xpbar"><div class="xpbar-fill" style="width:${prog}%"></div></div>
              <div class="xpbar-text">${escapeHtml(toNext)}</div>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Deck</span>
              <span class="hud-stat-value">${run.playerDeck.length}</span>
            </div>
            <div class="hud-stat">
              <span class="hud-stat-label">Bench</span>
              <span class="hud-stat-value">${getBenchCapacity()}</span>
            </div>
          </div>

          <div class="hud-center">
            <button class="hud-icon-btn" title="Run Log" onclick="openLogPanel('stats')">ðŸ“‹</button>
            <button class="hud-icon-btn" title="Settings" onclick="openSettingsPanel()">âš™ï¸</button>
            <button class="hud-icon-btn" title="Feedback" onclick="openFeedbackModal()">ðŸ“</button>
          </div>

          <div class="hud-right">
            ${run.loan.active && !run.loan.repaid ? `
              <button class="hud-btn success" ${canRepay ? '' : 'disabled'} onclick="repayLoan()">Repay ${LOAN_REPAY}</button>
            ` : ''}
            <button class="hud-btn danger" onclick="confirmReset()">Reset Run</button>
          </div>
        </div>
      `;

      requestAnimationFrame(syncHudOffset);
    }

    window.repayLoan = function() {
      const chips = safeNumber(run.chips);
      if (!run.loan.active || run.loan.repaid || chips < LOAN_REPAY) return;
      run.chips = chips - LOAN_REPAY;
      run.loan.repaid = true;
      logEvent('LOAN_REPAID', { amount: LOAN_REPAY });
      renderAll();
      showToast('Debt repaid!');
    };

    window.confirmReset = function() {
      showConfirmDialog('Are you sure you want to reset your run?', () => {
        clearPlayerName();
        initRun();
        showToast('New run started!');
      });
    };

    function renderBoard() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'BOARD' && run.ui.mode !== 'INTRO') {
        boardView.classList.add('hidden');
        return;
      }

      boardView.classList.remove('hidden');
      blackjackView.classList.add('hidden');
      endScreen.classList.add('hidden');

      if (run.ui.mode === 'INTRO') {
        showIntroPlasma();
        renderIntro();
        return;
      }

      if (!introPlasmaFading) hideIntroPlasmaImmediate();

      const available = getAvailableMoves();
      const isStarting = run.board.currentTileId === null;

      const instructions = isStarting
        ? 'Choose a starting tile from the bottom row'
        : 'Move to an available tile (gold outline)';

      let svg = `<svg id="boardSvg" viewBox="0 0 400 460" width="400" height="460">`;

      // Subtle connection graph (helps route-reading at a glance)
      for (const tile of run.board.tiles) {
        for (const toId of (tile.connections || [])) {
          const to = run.board.tiles[toId];
          if (!to) continue;
          svg += `<line class="board-edge base" x1="${tile.center[0]}" y1="${tile.center[1]}" x2="${to.center[0]}" y2="${to.center[1]}"/>`;
        }
      }

      // Highlight exits from current tile
      if (!isStarting) {
        const cur = run.board.tiles[run.board.currentTileId];
        for (const toId of available) {
          const to = run.board.tiles[toId];
          if (!to) continue;
          svg += `<line class="board-edge available-edge" x1="${cur.center[0]}" y1="${cur.center[1]}" x2="${to.center[0]}" y2="${to.center[1]}"/>`;
        }
      }

      // Player path so far
      if (run.board.path.length > 1) {
        const pathPoints = run.board.path.map(id => run.board.tiles[id].center.join(',')).join(' ');
        svg += `<polyline class="path-line" points="${pathPoints}"/>`;
      }

      for (const tile of run.board.tiles) {
        const isVisited = run.board.visited.has(tile.id);
        const isCurrent = run.board.currentTileId === tile.id;
        const isAvailable = available.includes(tile.id);

        let tileClass = 'hex-tile';
        if (isVisited) tileClass += ' visited';
        if (isCurrent) tileClass += ' current';
        if (isAvailable) tileClass += ' available';
        if (run.secret && run.secret.keys && run.secret.keys.highStakes.hinted
          && !run.secret.keys.highStakes.obtained
          && tile.id === run.secret.keys.highStakes.tileId) tileClass += ' key-roller';

        const clickHandler = isAvailable ? `onclick="onTileClick(${tile.id})"` : '';

        // Tooltip lines
        const meta = TILE_META[tile.type] || { name: tile.label, desc: '' };
        const tip = HELP_TILES[tile.type];
        const ttTitle = tip?.title || (meta.name || tile.type);
        const ttLines = tip && Array.isArray(tip.lines) ? [...tip.lines] : (meta.desc ? [meta.desc] : []);

        let subLabel = '';
        if (tile.npc && tile.npc.callingCard) {
          const calling = `${tile.npc.callingCard.rank}${tile.npc.callingCard.suit}`;
          const affinity = run.callingCard ? getAffinity(run.callingCard.suit, tile.npc.callingCard.suit) : null;
          const affIcon = affinity ? ` ${affinityIcon(affinity)}` : '';
          subLabel = `<text class="hex-sub" x="${tile.center[0]}" y="${tile.center[1] + 12}">${calling}${affIcon}</text>`;

          ttLines.push(`Opponent: ${tile.npc.name} (${calling}${affIcon})`);
        }

        if (isCurrent) ttLines.push('Current position.');
        if (isStarting && [18,19,20].includes(tile.id)) ttLines.push('Start here.');
        if (isAvailable) ttLines.push('Click to enter.');
        if (isVisited && !isCurrent) ttLines.push('Visited.');

        const ttAttrs = `data-tt-title="${escapeHtml(ttTitle)}" data-tt-lines="${escapeHtml(ttLines.join('|'))}"`;

        svg += `
          <g class="${tileClass}" ${clickHandler} ${ttAttrs}>
            <path class="hex-bg" d="${tile.svgPath}" fill="${tile.color}" stroke="#1a2436" stroke-width="2"/>
            <text class="hex-label" x="${tile.center[0]}" y="${tile.center[1]}">${tile.label}</text>
            ${subLabel}
          </g>
        `;
      }

      svg += '</svg>';

      const legendBtnLabel = (run.ui && run.ui.boardLegendOpen) ? 'Hide' : 'Legend';
      const legendHtml = (run.ui && run.ui.boardLegendOpen) ? renderBoardLegend() : '';

      boardView.innerHTML = `
        <div class="board-shell">
          <div class="board-toprow">
            <div class="board-instructions">${instructions}</div>
            <button class="hud-btn legend-toggle" onclick="toggleBoardLegend()">${legendBtnLabel}</button>
          </div>
          ${legendHtml}
          ${svg}
        </div>
      `;
    }

    window.toggleBoardLegend = function() {
      if (!run || !run.ui) return;
      run.ui.boardLegendOpen = !run.ui.boardLegendOpen;
      renderBoard();
    };

    function renderBoardLegend() {
      const order = ['STANDARD','HIGH_STAKES','REST_STOP','BARTENDER','MERCHANT','MODIFY','COLLECTOR','LOAN_SHARK','MINIGAME','BOSS'];
      return `
        <div class="board-legend">
          <div class="legend-title">
            <span>Legend</span>
            <span style="color:var(--text-secondary); font-size:12px; text-transform:none; letter-spacing:0;">Hover tiles for details</span>
          </div>

          <div class="legend-grid">
            ${order.map(type => {
              const m = TILE_META[type] || { name: type, desc: '' };
              const sw = TILE_COLORS[type] || '#64748b';
              const code = TILE_LABELS[type] || type;
              return `
                <div class="legend-item">
                  <span class="legend-swatch" style="background:${sw};"></span>
                  <div>
                    <div class="k">${code} â€” ${escapeHtml(m.name)}</div>
                    <div class="v">${escapeHtml(m.desc || '')}</div>
                  </div>
                </div>
              `;
            }).join('')}
          </div>

          <div class="legend-note">
            <div><code>+</code> / <code>-</code> / <code>â€¢</code> = affinity with your Calling Card suit.</div>
            <div>Gold outline = available move. Blue outline = current tile. Dim = visited.</div>
          </div>
        </div>
      `;
    }


    function getCallingCardEffectText(card){
      const suit = card?.suit || 'â™ ';
      const map = {
        'â™¥': {
          name: 'Calling Card â€” Hearts',
          title: 'Triage',
          summary: 'Has a chance to prevent busts when playing a Hearts card.',
          details: [
            { k:'Trigger', v:'On Card Play' },
            { k:'Effect',  v:'Discard the played card to avoid a busted hand.' }
          ]
        },
        'â™ ': {
          name: 'Calling Card â€” Spades',
          title: 'Spyglass',
          summary: 'Has a chance to reveal the score of the opposing lane.',
          details: [
            { k:'Trigger', v:'On Card Play' },
            { k:'Effect',  v:'Reveal opposing lane total until match ends.' }
          ]
        },
        'â™¦': {
          name: 'Calling Card â€” Diamonds',
          title: 'Dividend',
          summary: 'Has a chance to award chips equal to the played card rank.',
          details: [
            { k:'Trigger', v:'On Card Play' },
            { k:'Effect',  v:'Gain chips equal to card rank.' }
          ]
        },
        'â™£': {
          name: 'Calling Card â€” Clubs',
          title: 'Pressure',
          summary: 'Has a chance to attack the opposing lane.',
          details: [
            { k:'Trigger', v:'On Card Play' },
            { k:'Effect',  v:'Choose to apply +1 or -1 to the opposing lane (only if open).' }
          ]
        }
      };
      return map[suit] || map['â™ '];
    }

    function renderCallingCardReveal(card){
      const effect = getCallingCardEffectText(card);
      const rank = card?.rank || '2';
      const suit = card?.suit || 'â™ ';
      const flipped = !!(run?.intro && run.intro.revealFlipped);

      return `
        <div class="cc-reveal-root">
                    <div class="cc-reveal-meta">
            <div class="cc-name">${escapeHtml(effect.name)}</div>
            <div class="cc-summary">${escapeHtml(effect.summary)}</div>

            <div class="cc-reveal-actions">
              <button class="modal-btn" id="ccDetailsBtn">${flipped ? 'Hide details' : 'View details'}</button>
              <button class="modal-btn success" onclick="introEnterTower()">Enter Floor 1</button>
            </div>
          </div>

          <div class="cc-card-stage">
            <div class="cc-bounce" id="ccBounce">
              <div class="cc-float" id="ccFloat">
                <div class="cc-scale">
                  <div class="cc-tilt" id="ccTilt">
                    <div class="cc-flip ${flipped ? 'is-flipped' : ''}" id="ccFlip" role="button" tabindex="0" aria-label="Calling card. Click to flip for details.">
                    <div class="cc-face cc-neon cc-front">
                      <div class="cc-corner">${escapeHtml(rank)}</div>
                      <div class="cc-suit">${escapeHtml(suit)}</div>
                      <div class="cc-corner bottom">${escapeHtml(rank)}</div>
                    </div>

                    <div class="cc-face cc-neon cc-back">
                      <div>
                        <div class="cc-back-title">${escapeHtml(effect.title)}</div>
                        <div class="cc-back-lines">
                          ${effect.details.map(d => `<div><span class="k">${escapeHtml(d.k)}:</span> ${escapeHtml(d.v)}</div>`).join('')}
                        </div>
                      </div>
                      <div class="cc-back-lines" style="opacity:0.85;">Tap / click to flip back</div>
                    </div>

                  </div>
                  </div>
                </div>
              </div>
            </div>
          </div>


        </div>
      `;
    }

    let __ccReveal = { active:false, raf:0, cleanup:null };

    function setupCallingCardRevealInteractions(){
      const tiltEl = document.getElementById('ccTilt');
      const flipEl = document.getElementById('ccFlip');
      const detailsBtn = document.getElementById('ccDetailsBtn');
      const bounceEl = document.getElementById('ccBounce');

      if (!tiltEl || !flipEl) return;

      if (__ccReveal.cleanup) __ccReveal.cleanup();

      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      let targetX = 0, targetY = 0;
      let curX = 0, curY = 0;
      let hovering = false;

      const setVars = (mxPct, myPct) => {
        flipEl.style.setProperty('--mx', mxPct);
        flipEl.style.setProperty('--my', myPct);
      };

      const tick = () => {
        curX = curX + (targetX - curX) * 0.14;
        curY = curY + (targetY - curY) * 0.14;
        tiltEl.style.transform = `rotateX(${curX}deg) rotateY(${curY}deg)`;
        __ccReveal.raf = requestAnimationFrame(tick);
      };

      const startRAF = () => {
        if (__ccReveal.active) return;
        __ccReveal.active = true;
        __ccReveal.raf = requestAnimationFrame(tick);
      };

      const stopRAF = () => {
        if (!__ccReveal.active) return;
        cancelAnimationFrame(__ccReveal.raf);
        __ccReveal.active = false;
      };

      const onMove = (e) => {
        if (reduceMotion) return;
        if (e.pointerType && e.pointerType !== 'mouse') return;

        const rect = tiltEl.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);
        const cx = rect.width / 2;
        const cy = rect.height / 2;

        const rotateX = (y - cy) / 10;
        const rotateY = (cx - x) / 10;

        targetX = -rotateX;
        targetY = rotateY;

        const mxPct = Math.max(0, Math.min(100, (x / rect.width) * 100));
        const myPct = Math.max(0, Math.min(100, (y / rect.height) * 100));
        setVars(mxPct, myPct);
      };

      const onEnter = () => {
        hovering = true;
        if (!reduceMotion) startRAF();
      };

      const onLeave = () => {
        hovering = false;
        targetX = 0; targetY = 0;
        setVars(50, 50);
        if (!reduceMotion) {
          setTimeout(() => { if (!hovering) stopRAF(); }, 220);
        }
      };

      const toggleFlip = () => {
        if (run && run.intro) run.intro.revealFlipped = !run.intro.revealFlipped;
        flipEl.classList.toggle('is-flipped');

        if (detailsBtn) {
          detailsBtn.textContent = flipEl.classList.contains('is-flipped') ? 'Hide details' : 'View details';
        }

        if (bounceEl) {
          bounceEl.classList.add('cc-pop');
          setTimeout(() => bounceEl.classList.remove('cc-pop'), 440);
        }
      };

      const onFlipClick = (e) => {
        e.preventDefault();
        toggleFlip();
      };

      const onFlipKey = (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleFlip();
        }
      };

      const onDetailsClick = (e) => {
        e.preventDefault();
        toggleFlip();
      };

      tiltEl.addEventListener('pointermove', onMove);
      tiltEl.addEventListener('pointerenter', onEnter);
      tiltEl.addEventListener('pointerleave', onLeave);
      flipEl.addEventListener('click', onFlipClick);
      flipEl.addEventListener('keydown', onFlipKey);
      if (detailsBtn) detailsBtn.addEventListener('click', onDetailsClick);

      setVars(50, 50);
      tiltEl.style.transform = 'rotateX(0deg) rotateY(0deg)';

      __ccReveal.cleanup = () => {
        stopRAF();
        tiltEl.removeEventListener('pointermove', onMove);
        tiltEl.removeEventListener('pointerenter', onEnter);
        tiltEl.removeEventListener('pointerleave', onLeave);
        flipEl.removeEventListener('click', onFlipClick);
        flipEl.removeEventListener('keydown', onFlipKey);
        if (detailsBtn) detailsBtn.removeEventListener('click', onDetailsClick);
      };
    }

    function renderIntro() {
      const boardView = document.getElementById('boardView');
      const step = run.intro?.step || 'name';
      const name = run.intro?.name || '';

      const suitDescriptions = {
        'â™¥': 'Hearts â€” Triage: Has a chance to prevent busts when playing a Hearts card.',
        'â™ ': 'Spades â€” Spyglass: Has a chance to reveal the score of the opposing lane.',
        'â™¦': 'Diamonds â€” Dividend: Has a chance to award chips equal to the played card rank.',
        'â™£': 'Clubs â€” Pressure: Has a chance to attack the opposing lane.'
      };

      let body = '';
      if (step === 'name') {
        body = `
          <div class="intro-panel">
            <div class="intro-title">Project 63: The Pit</div>
            <div class="intro-text">
              A casino with no address. An indecipherable ledger.
            </div>
            <div class="intro-text">Declare your name, choose your Calling Card, and step inside.</div>
            <input class="intro-input" id="introNameInput" placeholder="Enter your name" value="${escapeHtml(name)}"/>
            <div class="intro-actions">
              <button class="modal-btn" onclick="introRandomName()">Random Name</button>
              <button class="modal-btn success" onclick="introSetName()">Continue</button>
            </div>
          </div>
        `;
      } else if (step === 'suit') {
        body = `
          <div class="intro-panel">
            <div class="intro-title">What Suits You?</div>
            <div class="intro-text">Each suit posseses a unique trait that may trigger when played.</div>
            <div class="intro-suits">
              ${['â™¥','â™ ','â™¦','â™£'].map(suit => `
                <button class="modal-btn intro-suit-btn" onclick="introChooseSuit('${suit}')">
                  <div style="font-weight:800; font-size:16px;">${suit}</div>
                  <div style="color:var(--text-secondary); font-size:12px; margin-top:4px;">${suitDescriptions[suit]}</div>
                </button>
              `).join('')}
            </div>
          </div>
        `;
      } else if (step === 'reveal') {
        const card = run.callingCard || run.intro?.callingCard;
        body = card ? renderCallingCardReveal(card) : `
          <div class="intro-panel">
            <div class="intro-title">Your Calling Card</div>
            <div class="intro-text">Missing calling card data.</div>
            <div class="intro-actions">
              <button class="modal-btn" onclick="run.intro.step='suit'; renderAll();">Back</button>
            </div>
          </div>
        `;
      }

      boardView.innerHTML = `<div class="intro-screen-wrap">${body}</div>`;

      if (step === 'reveal') {
        requestAnimationFrame(() => setupCallingCardRevealInteractions());
      } else {
        if (__ccReveal && __ccReveal.cleanup) __ccReveal.cleanup();
      }
    }

    window.introSetName = function() {
      const input = document.getElementById('introNameInput');
      const raw = input ? input.value : '';
      const cleaned = raw.trim();
      const name = cleaned || `Player ${Math.floor(Math.random() * 900 + 100)}`;
      run.playerName = name;
      run.intro.name = name;
      run.intro.step = 'suit';
      savePlayerName(name);
      if (gameLog && gameLog.player) gameLog.player.name = name;
      renderAll();
    };

    window.introRandomName = function() {
      const names = ['Nova', 'Jinx', 'Rook', 'Mara', 'Vega', 'Ash', 'Cy', 'Quinn', 'Sable', 'Riven'];
      const pick = names[Math.floor(Math.random() * names.length)];
      const input = document.getElementById('introNameInput');
      if (input) input.value = pick;
    };

    window.introChooseSuit = function(suit) {
      run.callingCard = { rank: '2', suit };
      run.callingCardChosenSuit = suit;
      run.intro.suit = suit;
      run.intro.callingCard = { ...run.callingCard };
      run.intro.step = 'reveal';
      renderAll();
    };

    window.introEnterTower = function() {
      if (__ccReveal && __ccReveal.cleanup) __ccReveal.cleanup();
      fadeOutIntroPlasmaAndStop();
      logEvent('CALLING_CARD_SET', { callingCard: run.callingCard });
      logEvent('GAME_START', {
        startingChips: STARTING_CHIPS,
        deckSize: run.playerDeck.length,
        deckSnapshot: deckSnapshot(),
        settings: getSettingsSnapshot(),
        playerName: run.playerName || ''
      });
      if (gameLog) {
        gameLog.initialState = {
          chips: run.chips,
          karma: run.karma,
          floor: run.floor,
          callingCard: { ...run.callingCard },
          deckSnapshot: deckSnapshot()
        };
        if (gameLog.player) gameLog.player.name = run.playerName || '';
      }
      recordDeckSnapshot('GAME_START');
      run.ui.mode = 'BOARD';
      run.intro = null;
      initFloor(1);
    };

    window.onTileClick = function(tileId) {
      const available = getAvailableMoves();
      if (available.includes(tileId)) enterTile(tileId);
    };

    function renderCard(card, faceDown=false, extraClass='') {
      const cls = ['playing-card', extraClass, faceDown ? 'face-down' : cardCssClass(card)].filter(Boolean).join(' ');
      const text = faceDown ? '' : cardToString(card);
      const stampId = !faceDown ? getCardStampId(card) : null;
      const stampDef = stampId ? getStampDef(stampId) : null;
      const sleeveId = !faceDown && card ? card.sleeveId : null;
      const dataAttrs = [
        `data-card-label="${text}"`,
        `data-card-type="${isModifier(card) ? 'MOD' : (isFused(card) ? 'FUSE' : (isKeyCard(card) ? 'KEY' : 'STANDARD'))}"`,
        card && card.rank ? `data-card-rank="${card.rank}"` : '',
        card && card.suit ? `data-card-suit="${card.suit}"` : '',
        stampId ? `data-card-stamp="${stampId}"` : '',
        sleeveId ? `data-card-sleeve="${sleeveId}"` : '',
        card && card.uid !== undefined && card.uid !== null ? `data-card-uid="${card.uid}"` : ''
      ].filter(Boolean).join(' ');
      const sleeveDef = sleeveId ? getSleeveDef(sleeveId) : null;
      const stampIcon = (stampDef && stampDef.icon) ? `<div class="stamp-icon">${stampDef.icon}</div>` : '';
      const sleeveIcon = (sleeveDef && sleeveDef.icon) ? `<div class="sleeve-icon">${sleeveDef.icon}</div>` : '';
      return `<div class="${cls}" ${dataAttrs}>${text}${stampIcon}${sleeveIcon}</div>`;
    }

    function setupCardTooltip() {
      const tooltip = document.getElementById('cardTooltip');
      if (!tooltip) return;

      let activeCard = null;
      let longPressTimer = null;

      const buildTooltipHtml = (cardEl) => {
        const ds = cardEl.dataset || {};
        const label = ds.cardLabel || 'Card';
        const type = ds.cardType || '';
        const stamp = ds.cardStamp ? getStampDef(ds.cardStamp) : null;
        const sleeve = ds.cardSleeve ? getSleeveDef(ds.cardSleeve) : null;
        const lines = [];

        if (type && type !== 'STANDARD') lines.push(`${type} card`);
        if (stamp) lines.push(`Stamp: ${stamp.name} â€” ${stamp.desc}`);
        if (sleeve) lines.push(`Sleeve: ${sleeve.name} â€” ${sleeve.desc}`);

        return `
          <div class="tooltip-title">${label}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const showTooltip = (cardEl, x, y) => {
        if (!cardEl || !cardEl.dataset || !cardEl.dataset.cardLabel) return;
        tooltip.innerHTML = buildTooltipHtml(cardEl);
        tooltip.classList.remove('hidden');
        tooltip.style.left = `${x + 12}px`;
        tooltip.style.top = `${y + 12}px`;
        activeCard = cardEl;
      };

      const hideTooltip = () => {
        tooltip.classList.add('hidden');
        activeCard = null;
      };

      document.addEventListener('mouseover', (e) => {
        const cardEl = e.target.closest('.playing-card');
        if (!cardEl || cardEl.classList.contains('face-down')) return;
        showTooltip(cardEl, e.clientX, e.clientY);
      });

      document.addEventListener('mouseout', (e) => {
        if (!tooltipsOn()) return;
        if (activeCard && !e.relatedTarget?.closest('.playing-card')) {
          hideTooltip();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!tooltipsOn()) return;
        if (!activeCard) return;
        tooltip.style.left = `${e.clientX + 12}px`;
        tooltip.style.top = `${e.clientY + 12}px`;
      });

      document.addEventListener('pointerdown', (e) => {
        const cardEl = e.target.closest('.playing-card');
        if (!cardEl || cardEl.classList.contains('face-down')) return;
        longPressTimer = setTimeout(() => showTooltip(cardEl, e.clientX, e.clientY), 450);
      });

      document.addEventListener('pointerup', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('pointercancel', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.playing-card')) hideTooltip();
      });
    }

    function setupActionTooltip() {
      const tooltip = document.getElementById('actionTooltip');
      if (!tooltip) return;

      let activeChip = null;
      let longPressTimer = null;

      const buildTooltipHtml = (chipEl) => {
        const ds = chipEl.dataset || {};
        const title = ds.ttTitle || 'Action';
        const rawLines = ds.ttLines || '';
        const lines = rawLines ? rawLines.split('|').map(line => line.trim()).filter(Boolean) : [];
        return `
          <div class="tooltip-title">${title}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const showTooltip = (chipEl, x, y) => {
        if (!chipEl) return;
        tooltip.innerHTML = buildTooltipHtml(chipEl);
        tooltip.classList.remove('hidden');
        tooltip.style.left = `${x + 12}px`;
        tooltip.style.top = `${y + 12}px`;
        activeChip = chipEl;
      };

      const hideTooltip = () => {
        tooltip.classList.add('hidden');
        activeChip = null;
      };

      document.addEventListener('mouseover', (e) => {
        const chipEl = e.target.closest('.action-chip');
        if (!chipEl) return;
        showTooltip(chipEl, e.clientX, e.clientY);
      });

      document.addEventListener('mouseout', (e) => {
        if (!tooltipsOn()) return;
        if (activeChip && !e.relatedTarget?.closest('.action-chip')) {
          hideTooltip();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!tooltipsOn()) return;
        if (!activeChip) return;
        tooltip.style.left = `${e.clientX + 12}px`;
        tooltip.style.top = `${e.clientY + 12}px`;
      });

      document.addEventListener('pointerdown', (e) => {
        const chipEl = e.target.closest('.action-chip');
        if (!chipEl) return;
        longPressTimer = setTimeout(() => showTooltip(chipEl, e.clientX, e.clientY), 450);
      });

      document.addEventListener('pointerup', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('pointercancel', () => {
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest('.action-chip')) hideTooltip();
      });
    }

    function setupTileTooltip() {
      const tooltip = document.getElementById('tileTooltip');
      if (!tooltip) return;

      let activeTile = null;
      let longPressTimer = null;

      const tooltipsOn = () => (uiSettings.tooltipsEnabled !== false);

      const buildTooltipHtml = (tileEl) => {
        const ds = tileEl.dataset || {};
        const title = ds.ttTitle || 'Tile';
        const rawLines = ds.ttLines || '';
        const lines = rawLines ? rawLines.split('|').map(line => line.trim()).filter(Boolean) : [];
        return `
          <div class="tooltip-title">${title}</div>
          ${lines.map(line => `<div class="tooltip-line">${line}</div>`).join('')}
        `;
      };

      const showTooltip = (tileEl, x, y) => {
        if (!tileEl || !tooltipsOn()) return;
        // Only show when board view is visible
        const boardView = document.getElementById('boardView');
        if (boardView && boardView.classList.contains('hidden')) return;
        tooltip.innerHTML = buildTooltipHtml(tileEl);
        tooltip.classList.remove('hidden');
        tooltip.style.left = `${x + 12}px`;
        tooltip.style.top = `${y + 12}px`;
        activeTile = tileEl;
      };

      const hideTooltip = () => {
        tooltip.classList.add('hidden');
        activeTile = null;
      };

      document.addEventListener('mouseover', (e) => {
        if (!tooltipsOn()) return;
        const tileEl = e.target.closest && e.target.closest('.hex-tile');
        if (!tileEl) return;
        showTooltip(tileEl, e.clientX, e.clientY);
      });

      document.addEventListener('mouseout', (e) => {
        if (!tooltipsOn()) return;
        if (activeTile && !e.relatedTarget?.closest?.('.hex-tile')) {
          hideTooltip();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!tooltipsOn()) return;
        if (!activeTile) return;
        tooltip.style.left = `${e.clientX + 12}px`;
        tooltip.style.top = `${e.clientY + 12}px`;
      });

      document.addEventListener('pointerdown', (e) => {
        if (!tooltipsOn()) return;
        const tileEl = e.target.closest && e.target.closest('.hex-tile');
        if (!tileEl) return;
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = setTimeout(() => showTooltip(tileEl, e.clientX, e.clientY), 450);
      });

      ['pointerup','pointercancel','pointerleave'].forEach((evt) => {
        document.addEventListener(evt, () => {
          if (longPressTimer) clearTimeout(longPressTimer);
          longPressTimer = null;
          hideTooltip();
        });
      });

      document.addEventListener('click', (e) => {
        if (!e.target.closest?.('.hex-tile')) hideTooltip();
      });
    }

    function posState(pos) {
      if (!pos.isOpen) return 'closed';
      if (pos.isComplete) return pos.isBust ? 'bust' : 'stand';
      return 'open';
    }

    function stateBadge(state) {
      return `<div class="bj-state ${state}">${state}</div>`;
    }

    function renderLaneSummary(side, idx, isResolved){
      if (!blackjackMatch || !isResolved) return '';
      if (side !== 'player') return '';
      const r = blackjackMatch.result || {};
      const laneChip = r.laneChip || null;
      const kb = r.karmaBreakdown || null;
      const es = blackjackMatch.earningsSeq;
      const ss = blackjackMatch.scoreSeq;
      let chipsNow = 0;
      if (es && es.active && Array.isArray(es.laneAccrued)) chipsNow = safeNumber(es.laneAccrued[idx], 0);
      else if (laneChip && Array.isArray(laneChip.totalByLane)) chipsNow = safeNumber(laneChip.totalByLane[idx], 0);
      let karmaNow = 0;
      if (ss && ss.active && Array.isArray(ss.laneAccrued)) karmaNow = safeNumber(ss.laneAccrued[idx], 0);
      else if (kb && Array.isArray(kb.lanes) && kb.lanes[idx]) karmaNow = safeNumber(kb.lanes[idx].laneTotal, 0);
      return `<div class="lane-summary"><span>Chips <b>${chipsNow >= 0 ? '+' : ''}${chipsNow}</b></span><span>Karma <b>${karmaNow >= 0 ? '+' : ''}${karmaNow}</b></span></div>`;
    }

    function renderResolutionLogEarnings(){
      const es = blackjackMatch && blackjackMatch.earningsSeq;
      const steps = (es && es.steps) ? es.steps : [];
      if (!steps.length) return '';
      const idx = es.active ? Math.max(0, es.idx - 1) : steps.length - 1;
      return `<div style="flex:1 1 320px; border:1px solid var(--border-color); border-radius:12px; padding:10px; background:rgba(0,0,0,0.18);"><div style="font-family:'Cinzel',serif; color:var(--accent-gold); letter-spacing:1px; font-size:12px; margin-bottom:8px;">Earnings Log</div><div style="max-height:160px; overflow:auto; font-size:12px; color:var(--text-secondary);">${steps.map((st,i)=>`<div style="display:flex; justify-content:space-between; gap:10px; padding:3px 0; ${i===idx?'color:var(--text-primary); font-weight:800;':''}"><span>${escapeHtml(st.name)}</span><span>${st.delta>=0?'+':''}${st.delta}</span></div>`).join('')}</div></div>`;
    }

    function renderResolutionLogKarma(){
      const ss = blackjackMatch && blackjackMatch.scoreSeq;
      const steps = (ss && ss.steps) ? ss.steps : [];
      if (!steps.length) return '';
      const idx = ss.active ? Math.max(0, ss.stepIndex - 1) : steps.length - 1;
      return `<div style="flex:2 1 420px; border:1px solid var(--border-color); border-radius:12px; padding:10px; background:rgba(0,0,0,0.18);"><div style="font-family:'Cinzel',serif; color:var(--accent-gold); letter-spacing:1px; font-size:12px; margin-bottom:8px;">Karma Log</div><div style="max-height:160px; overflow:auto; font-size:12px; color:var(--text-secondary);">${steps.map((st,i)=>`<div style="display:flex; justify-content:space-between; gap:10px; padding:3px 0; ${i===idx?'color:var(--text-primary); font-weight:800;':''}"><span>${escapeHtml(st.message || '')}</span><span>${st.delta>0?`+${st.delta}`:''}</span></div>`).join('')}</div></div>`;
    }

    function renderPosition(pos, idx, side, isResolved, laneWinner) {
      const state = posState(pos);
      const total = getPositionTotal(pos);
      const spy = (side === 'dealer') && blackjackMatch && blackjackMatch.spyReveals && blackjackMatch.spyReveals.has(idx);
      const spadeReveal = (side === 'dealer') && blackjackMatch && blackjackMatch.spadePeekLanes && blackjackMatch.spadePeekLanes.has(idx);
      const revealTotalsOnClose = (uiSettings && uiSettings.revealTotalsOnClose) !== false;
      const showDealerTotal = spy || spadeReveal || isResolved || (revealTotalsOnClose && pos.isComplete);
      const showTotal = (side === 'player') ? true : showDealerTotal;
      const canReveal = (side === 'player') ? true : showDealerTotal;
      const totalText = showTotal ? `${total}` : '??';
      const totalBustVisual = ((side === 'player') || isResolved) && canReveal && total > 21 ? 'bust' : '';
      const revealHole = (side === 'dealer') ? showDealerTotal : true;
      const displayState = (state === 'bust' && !canReveal) ? 'stand' : state;
      let cls = `bj-position ${displayState}`;
      if (blackjackMatch && blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active && blackjackMatch.scoreSeq.focusLane === idx && blackjackMatch.scoreSeq.focusSide === side) cls += ' score-flash';
      if (side === 'player' && run && run.bossFight && run.bossFight.active && run.bossFight.phase === 2 && run.bossFight.targetLaneIdx === idx) cls += ' boss-target';
      if (side === 'player' && blackjackMatch && blackjackMatch.type === 'WATCHER' && blackjackMatch.watcherTargetLaneIdx === idx) cls += ' watcher-target';
      if (displayState === 'open') cls += ' open';
      if (displayState === 'stand') cls += ' stand';
      if (displayState === 'bust' && (side === 'player' || isResolved)) cls += ' bust';
      if (displayState === 'closed') cls += ' closed';
      if (isResolved && laneWinner === side) cls += ' winner';
      const focusedUids = new Set((blackjackMatch && blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active && blackjackMatch.scoreSeq.focusLane === idx && blackjackMatch.scoreSeq.focusSide === side) ? (blackjackMatch.scoreSeq.focusCardUids || []) : []);
      const cardsHtml = (pos.cards || []).map((c, j) => {
        if (side === 'dealer') return renderCard(c, (j === 0) && !revealHole);
        const popClass = focusedUids.has(c && c.uid) ? 'karma-pop' : '';
        return renderCard(c, false, popClass);
      }).join('');
      const mods = (pos.mods || []);
      const trapDelta = (!pos.isOpen && blackjackMatch && blackjackMatch.traps) ? blackjackMatch.traps[side][idx] : 0;
      const displayMods = mods.length ? mods : (trapDelta ? [trapDelta] : []);
      const modsText = displayMods.length ? displayMods.map(m => (m > 0 ? `+${m}` : `${m}`)).join(' ') : '';
      const modsLine = displayMods.length ? `<div class="bj-position-num" style="color: var(--accent-blue); font-weight:800;">MOD: ${modsText}</div>` : `<div class="bj-position-num">MOD: â€”</div>`;
      const f = blackjackMatch && blackjackMatch.scoreSeq ? blackjackMatch.scoreSeq.float : null;
      const floatHtml = (f && f.side === side && f.laneIdx === idx) ? `<div class="karma-float" data-float-id="${f.id}">${escapeHtml(f.text || '')}</div>` : '';
      return `<div class="${cls}" id="${side}_lane_${idx}"><div class="bj-position-num">${side.toUpperCase()} #${idx+1}</div><div class="bj-cards">${cardsHtml}</div><div class="bj-total ${totalBustVisual}">${totalText}</div>${stateBadge(displayState)}${modsLine}${renderLaneSummary(side, idx, isResolved)}${floatHtml}<div id="${side}_lane_actions_${idx}" style="display:flex; gap:6px; flex-wrap:wrap; justify-content:center;"></div></div>`;
    }

    function renderBlackjack() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'BLACKJACK' || !blackjackMatch) {
        blackjackView.classList.add('hidden');
        return;
      }

      boardView.classList.add('hidden');
      blackjackView.classList.remove('hidden');
      endScreen.classList.add('hidden');

      const isResolved = blackjackMatch.phase === 'resolved';
      const result = blackjackMatch.result;
      const transferMultiplier = blackjackMatch.transferMultiplier || 1;
      const npc = blackjackMatch.npc;
      const affinity = blackjackMatch.affinity || 'neutral';
      const edgeDelta = blackjackMatch.edgeDelta || 0;
      const procPct = Math.round((blackjackMatch.callingProcChance || CALLING_PROC_CHANCE) * 100);
      const npcLine = npc
        ? `${npc.name} Â· ${cardToString(npc.callingCard)} Â· ${affinityIcon(affinity)} Â· Edge ${edgeDelta >= 0 ? '+' : ''}${edgeDelta} Â· Proc ${procPct}%`
        : `Dealer Â· Proc ${procPct}%`;
      const prof = blackjackMatch.aiProfile;
      const styleLine = (npc && prof && prof.verb) ? `${npc.name} ${prof.verb}.` : '';
      const houseRuleLine = (blackjackMatch.type === 'HIGH_STAKES')
        ? `High Stakes rule: Karma x${HIGH_STAKES_KARMA_MULT}`
        : '';

      const typeLabel = blackjackMatch.type === 'WATCHER' ? 'THE WATCHER' :
                        blackjackMatch.type === 'BOSS' ? 'BOSS BATTLE' :
                        blackjackMatch.type === 'HIGH_STAKES' ? 'HIGH STAKES' : 'STANDARD TABLE';

      const bossFight = run && run.bossFight;
      const isBossFight = blackjackMatch.type === 'BOSS' && bossFight && bossFight.active;
      const bossHpPct = isBossFight ? Math.max(0, Math.min(100, Math.round((bossFight.hp / bossFight.maxHp) * 100))) : 0;
      const bossPhaseClass = isBossFight && bossFight.phase === 2 ? 'boss-phase2' : '';
      const bossMeta = isBossFight ? `
        <div class="bj-status ${bossPhaseClass}">
          Round ${bossFight.round} / ${bossFight.maxRounds} Â· Time ${bossFight.roundsRemaining || 0} Â· HP ${bossFight.hp} / ${bossFight.maxHp}
          <div class="boss-hp ${bossPhaseClass}">
            <div class="boss-hp-fill" style="width:${bossHpPct}%"></div>
          </div>
        </div>
      ` : '';

      const watcherClass = blackjackMatch.type === 'WATCHER' ? ' watcher' : '';
      let html = `
        <div class="bj-header${watcherClass}">
          <div class="bj-title">${typeLabel}</div>
          <div class="bj-status">Buy-in: ${blackjackMatch.buyIn} chips Â· Side Bet x${transferMultiplier}</div>
          <div class="bj-status">${npcLine}</div>
          ${houseRuleLine ? `<div class="bj-house-rule">${escapeHtml(houseRuleLine)}</div>` : ''}
          ${styleLine ? `<div class="bj-style-line">${escapeHtml(styleLine)}</div>` : ''}
          ${bossMeta}
        </div>
      `;
      if (blackjackMatch.procBanner) {
        html += `<div class="proc-banner"><div class="proc-banner-title">${escapeHtml(blackjackMatch.procBanner.suit || '')} ${escapeHtml(blackjackMatch.procBanner.title || 'Calling Proc')}</div><div class="proc-banner-desc">${escapeHtml(blackjackMatch.procBanner.desc || '')}</div></div>`;
      }

      // Dealer + Player positions
      const laneWinners = (isResolved && result) ? result.positionResults : ['push','push','push','push','push'];

      html += `
        <div class="bj-board ${(blackjackMatch.scoreSeq && blackjackMatch.scoreSeq.active) ? 'scoring-mode' : ''}">
          <div class="bj-side">
            <div class="bj-side-label">${npc ? `${npc.name} Â· ${cardToString(npc.callingCard)}` : 'Dealer'}</div>
            <div class="bj-positions">
              ${blackjackMatch.dealerPositions.map((p, i) => renderPosition(p, i, 'dealer', isResolved, laneWinners[i])).join('')}
            </div>
          </div>

          <div class="bj-side">
            <div class="bj-side-label">Player</div>
            <div class="bj-positions">
              ${blackjackMatch.playerPositions.map((p, i) => renderPosition(p, i, 'player', isResolved, laneWinners[i])).join('')}
            </div>
          </div>
        </div>
      `;

      // Controls / Result section
      if (isResolved && result) {
        const outcome = result.outcome;
        const titleCls = outcome === 'WIN' ? 'win' : (outcome === 'LOSS' ? 'lose' : 'tie');
        const playerWins = safeNumber(result.playerWins, 0);
        const dealerWins = safeNumber(result.dealerWins, 0);
        const outcomeLine = `${outcome} (${playerWins}-${dealerWins})`;

        const transfer = blackjackMatch.transferChipsNet || 0;
        const bonus = blackjackMatch.bonusChipsEarned || 0;
        const payout = result.payout || 0;
        const rake = (result && result.rake) ? result.rake : 0;
        const rakeRate = (result && result.rakeRate) ? result.rakeRate : 0;

        const netFromEnd = payout + transfer - rake + bonus; // buy-in already paid earlier
        const netCls = netFromEnd > 0 ? 'positive' : (netFromEnd < 0 ? 'negative' : 'neutral');

        const rakeLine = rake > 0 ? ` Â· Rake: -${rake} (${Math.round(rakeRate * 100)}%)` : '';

        const rewardNote = blackjackMatch.rewardPending
          ? `<div class="bj-result-score" style="color:var(--accent-gold); font-weight:800;">Winner reward pendingâ€¦</div>`
          : '';
        const exhaustionNote = result.exhaustion
          ? `<div class="bj-result-score" style="color:var(--accent-red); font-weight:800;">Deck exhaustion (${result.exhaustion.side})</div>`
          : '';
        const scoreSeq = blackjackMatch.scoreSeq;
        const earningsSeq = blackjackMatch.earningsSeq;
        const earningsNow = earningsSeq && earningsSeq.active ? earningsSeq.accrued : netFromEnd;
        const karmaNow = scoreSeq && scoreSeq.active ? Math.max(0, scoreSeq.accrued) : Math.max(0, (result.karmaGained || 0));
        const rankText = run.callingCard ? `${run.callingCard.rank}${run.callingCard.suit}` : 'â€”';

        html += `
          <div class="bj-result">
            <div class="bj-result-row">
              <div><b>Outcome:</b> <span class="${titleCls}">${outcomeLine}</span></div>
              <div><b>Match Earnings:</b> <span class="${netCls}">${earningsNow >= 0 ? '+' : ''}${earningsNow}</span> <span style="color:var(--text-muted)">(Payout ${payout}, SideBet ${transfer >= 0 ? '+' : ''}${transfer}, Rake -${rake}, Bonus ${bonus})</span></div>
            </div>
            <div class="bj-result-row">
              <div><b>Karma:</b> +${karmaNow} <span style="color:var(--text-muted)">(Rank ${rankText})</span></div>
              <div style="display:flex; gap:10px; justify-content:flex-end;">${isResolutionAnimationActive() ? '<button class="bj-btn" onclick="skipResolutionAnimations()">Skip</button>' : ''}<button class="bj-btn" onclick="blackjackContinue()" ${isResolutionAnimationActive() || blackjackMatch.rewardPending ? 'disabled' : ''}>Complete</button></div>
            </div>
            ${rewardNote}
            ${exhaustionNote}
            <div style="display:flex; gap:12px; flex-wrap:wrap; margin-top:10px;">${renderResolutionLogEarnings()}${renderResolutionLogKarma()}</div>
          </div>
        `;
      } else {
        if (blackjackMatch.phase === 'betting') {
          const stage = blackjackMatch.transferMultiplierStage;
          const min = blackjackMatch.transferMultiplierMin || 1;
          const max = blackjackMatch.transferMultiplierMax || 1;
          const options = Array.from({ length: max - min + 1 }, (_, i) => min + i);

          let betButtons = '';
          let betHint = '';

          if (stage === 'player') {
            betButtons = options.map(val => (
              `<button class="bj-btn" onclick="setTransferMultiplier(${val})">x${val}</button>`
            )).join('');
            betHint = 'Choose your side bet multiplier. Dealer can call or raise by +1.';
          } else if (stage === 'response' && blackjackMatch.transferRaiseOffer) {
            betButtons = `
              <button class="bj-btn success" onclick="acceptTransferRaise()">Accept x${blackjackMatch.transferRaiseOffer}</button>
              <button class="bj-btn danger" onclick="declineTransferRaise()">Decline</button>
            `;
            betHint = `Dealer raised side bet to x${blackjackMatch.transferRaiseOffer}. Accept or decline.`;
          } else {
            betButtons = `<button class="bj-btn" disabled>Waitingâ€¦</button>`;
            betHint = 'Dealer is decidingâ€¦';
          }

          html += `
            <div class="bj-controls">
              <div class="bj-turn-info">Side Bet Multiplier</div>
              <div class="bj-drawn-card" style="border-color: rgba(42,58,84,0.9); background: rgba(26,36,54,0.35);">
                <div class="bj-drawn-label">${betHint}</div>
              </div>
              <div class="bj-action-btns">
                ${betButtons}
              </div>
            </div>
          `;
        } else {
          const isPlayerTurn = blackjackMatch.turn === 'player';

          const drawn = blackjackMatch.drawnCard;
          const drawnHtml = drawn ? `
            <div class="bj-drawn-card">
              <div class="bj-drawn-label">Drawn:</div>
              ${renderCard(drawn, false)}
              <div class="bj-drawn-label" style="opacity:.9;">Place it into an open lane.</div>
            </div>
          ` : `
            <div class="bj-drawn-card" style="border-color: rgba(42,58,84,0.9); background: rgba(26,36,54,0.35);">
              <div class="bj-drawn-label">${isPlayerTurn ? 'No drawn card. Draw or use a bench card.' : 'Dealer is actingâ€¦'}</div>
            </div>
          `;

          // Action tokens UI
          const tokenTotal = blackjackMatch.tokensTotal || 0;
          const tokenSpent = blackjackMatch.tokensSpent || 0;
          const clickable = canClickToken();
          const owned = run.ownedActions || [];
          const canSpend = isPlayerTurn
            && blackjackMatch.phase === 'playing'
            && !blackjackMatch.actionUsedThisTurn
            && !blackjackMatch.actionSelectionInProgress
            && tokensRemaining() > 0;

          const tokensHtml = Array.from({ length: tokenTotal }, (_, i) => {
            const spent = i < tokenSpent;
            const locked = !spent && !clickable;
            const disabled = spent || (!clickable && !locked);
            const cls = spent ? 'token-icon spent' : (locked ? 'token-icon locked' : (disabled ? 'token-icon disabled' : 'token-icon'));
            const handler = (!spent && clickable) ? `onclick="onActionTokenClick()"` : '';
            return `<div class="${cls}" ${handler} title="${spent ? 'Spent' : (locked ? 'Locked' : (clickable ? 'Click to use an action token' : 'Unavailable'))}">${i+1}</div>`;
          }).join('');

          const actionsHtml = owned.length
            ? owned.map(id => {
              const def = ACTIONS[id];
              if (!def) return '';
              const already = blackjackMatch.usedActions && blackjackMatch.usedActions[id];
              const usable = !already && canSpend && (!def.isUsable || def.isUsable(blackjackMatch));
              const cls = already ? 'action-chip used' : (usable ? 'action-chip ready' : 'action-chip locked');
              const ttTitle = def.name;
              const ttLines = `${def.desc}|Costs 1 token Â· Once per match`;

              return `<button class="${cls}" ${usable ? `onclick="useActionFromBar('${id}')"` : 'disabled'}
                data-tt-title="${escapeHtml(ttTitle)}"
                data-tt-lines="${escapeHtml(ttLines)}">
                ${escapeHtml(def.name)} <span class="pill">1âš¡</span>
              </button>`;
            }).join('')
            : `<div class="action-hint" style="padding:6px 2px;">No cocktails owned yet. Visit the Bartender.</div>`;

          // Bench UI
          const bench = blackjackMatch.bench || [];
          const armedIdx = blackjackMatch.armedBenchIdx;
          const armedCard = (armedIdx !== null && armedIdx !== undefined) ? bench[armedIdx] : null;
          const armedLabel = armedCard ? `Armed: ${cardToString(armedCard)}` : 'Arm a bench card';

          const benchHtml = `
            <div class="action-bar bench-bar">
              <div class="action-bar-title">Bench (${bench.length}/${getBenchCapacity()}) Â· ${armedLabel}</div>
              <div class="bench-cards">
                ${bench.length ? bench.map((c, i) => {
                  const ring = (armedIdx === i) ? 'bench-armed-ring' : '';
                  return `
                    <button class="bench-card-btn ${ring}" onclick="armBench(${i})" ${!isPlayerTurn ? 'disabled' : ''} title="Arm">
                      ${renderCard(c, false, 'bench')}
                    </button>
                  `;
                }).join('') : `<div class="action-hint" style="padding: 6px 2px;">Bench is empty.</div>`}
              </div>
              <div class="action-hint">
                ${armedCard
                  ? (isModifier(armedCard)
                    ? 'Armed modifier: apply to any open lane (player or dealer). Costs 1 token.'
                    : 'Armed card: place into any open player lane (ends your turn). Costs 1 token.')
                  : 'Use Bench before drawing. Costs 1 token.'}
              </div>
            </div>
          `;

          html += `
            <div class="bj-controls">
              <div class="bj-turn-info">${isPlayerTurn ? 'Your Turn' : 'Dealer Turn'}</div>

              ${drawnHtml}

              <div class="bj-action-btns">
                <button class="bj-btn" onclick="playerDrawCard()" ${(!isPlayerTurn || !!drawn || countOpenPositions(blackjackMatch.playerPositions) === 0) ? 'disabled' : ''}>Draw</button>
                ${(isPlayerTurn && countOpenPositions(blackjackMatch.playerPositions) > 0) ? `<button class="bj-btn danger" ${(!isPlayerTurn || !!drawn) ? 'disabled' : ''} onclick="playerEndTurn()">Stand All &amp; End Turn</button>` : ''}
                ${(isPlayerTurn && countOpenPositions(blackjackMatch.playerPositions) === 0 && !allPositionsComplete(blackjackMatch.dealerPositions)) ? `<button class="bj-btn" ${(!isPlayerTurn || !!drawn) ? 'disabled' : ''} onclick="playerEndTurn()">End Turn</button><button class="bj-btn primary" ${(!isPlayerTurn || !!drawn) ? 'disabled' : ''} onclick="passTillMatchEnd()">Pass Till Match End</button>` : ''}
              </div>

              <div class="controls-row">
                <div class="action-bar">
                  <div class="action-bar-title">Tokens</div>
                  <div class="action-tokens">${tokensHtml || '<div class="action-hint">No tokens</div>'}</div>
                  <div class="action-hint">
                    Tokens power Bench plays and Cocktails.
                  </div>
                </div>
                <div class="action-bar">
                  <div class="action-bar-title">Actions</div>
                  <div class="action-chips">${actionsHtml}</div>
                  <div class="action-hint">Hover / long-press an action for details.</div>
                </div>
                ${benchHtml}
              </div>

              <div class="action-hint" style="max-width: 720px;">
                Tip: You can stand to close a lane immediately. Over-21 totals only bust at end of turn unless you close that lane.
              </div>
            </div>
          `;
        }
      }

      blackjackView.innerHTML = html;

      // After DOM is in, inject lane action buttons (keeps markup clean)
      injectLaneActionButtons();
    }

    function injectLaneActionButtons() {
      if (!blackjackMatch || blackjackMatch.phase !== 'playing') return;

      const isPlayerTurn = blackjackMatch.turn === 'player';
      const drawn = blackjackMatch.drawnCard;
      const benchTokenBlocked = !isPlayerTurn || blackjackMatch.actionUsedThisTurn || tokensRemaining() <= 0 || !!drawn;

      const bench = blackjackMatch.bench || [];
      const bi = blackjackMatch.armedBenchIdx;
      const armed = (bi !== null && bi !== undefined) ? bench[bi] : null;

      for (let i = 0; i < blackjackMatch.playerPositions.length; i++) {
        const p = blackjackMatch.playerPositions[i];
        const d = blackjackMatch.dealerPositions[i];

        const pEl = document.getElementById(`player_lane_actions_${i}`);
        const dEl = document.getElementById(`dealer_lane_actions_${i}`);
        if (!pEl || !dEl) continue;

        // reset
        pEl.innerHTML = '';
        dEl.innerHTML = '';

        // PLAYER lane buttons
        if (isPlayerTurn && p.isOpen && !p.isComplete) {
          // place drawn card
          if (drawn) {
            const btn = document.createElement('button');
            btn.className = 'bj-btn place';
            btn.textContent = 'Place';
            btn.onclick = () => playerPlaceCard(i);
            pEl.appendChild(btn);
          } else {
            // stand
            const stand = document.createElement('button');
            stand.className = 'bj-btn stand-pos';
            stand.textContent = 'Stand';
            stand.onclick = () => playerStand(i);
            pEl.appendChild(stand);

            // bench placement/apply
            if (armed) {
              if (isModifier(armed)) {
                const apply = document.createElement('button');
                apply.className = 'bj-btn apply-mod';
                apply.textContent = 'Apply Mod';
                apply.disabled = benchTokenBlocked;
                apply.title = benchTokenBlocked ? 'Requires 1 token' : '';
                apply.onclick = () => applyBenchTo('player', i);
                pEl.appendChild(apply);
              } else {
                const placeB = document.createElement('button');
                placeB.className = 'bj-btn place-bench';
                placeB.textContent = 'Place Bench';
                placeB.disabled = benchTokenBlocked;
                placeB.title = benchTokenBlocked ? 'Requires 1 token' : '';
                placeB.onclick = () => playerPlaceBenchCard(i);
                pEl.appendChild(placeB);
              }
            }
          }
        }

        // DEALER lane buttons (only bench modifier applies here)
        if (isPlayerTurn && !drawn && armed && isModifier(armed) && d.isOpen && !d.isComplete) {
          const apply = document.createElement('button');
          apply.className = 'bj-btn apply-mod';
          apply.textContent = 'Apply Mod';
          apply.disabled = benchTokenBlocked;
          apply.title = benchTokenBlocked ? 'Requires 1 token' : '';
          apply.onclick = () => applyBenchTo('dealer', i);
          dEl.appendChild(apply);
        }
      }
    }

    const PIT_MESSAGES = {
      WIN: "You escaped this time, but the Pit remembers.",
      LOSS: "You fell short. The only way out is back through.",
      UNKNOWN: "The Pit watches. The ledger remains open."
    };

    const ARCHETYPE_EXEMPLARS = {
      "The Surgeon":        { name: "Maria", epithet: "The Surgeon" },
      "The Saboteur":       { name: "Rook",  epithet: "The Saboteur" },
      "The High Roller":    { name: "Vance", epithet: "The High Roller" },
      "Engineer":           { name: "Inez",  epithet: "Engineer" },
      "Politico":           { name: "Sol",   epithet: "Politico" },
      "The Banker":         { name: "Edwin", epithet: "The Banker" }
    };

    function clamp01(v){ return Math.max(0, Math.min(1, safeNumber(v, 0))); }
    function num(v){ return safeNumber(v, 0); }
    function numOrNull(v){ const n = Number(v); return Number.isFinite(n) ? n : null; }
    function avg(list){
      const vals = (list || []).map(v => Number(v)).filter(v => Number.isFinite(v));
      if (!vals.length) return null;
      return vals.reduce((a,b)=>a+b,0) / vals.length;
    }
    function normRange(v, lo, hi){
      if (v === null || v === undefined || Number.isNaN(v)) return 0;
      if (hi === lo) return 0;
      return clamp01((v - lo) / (hi - lo));
    }
    function countEvents(events, matcher){
      if (!events || !events.length) return 0;
      if (typeof matcher === 'function') return events.filter(matcher).length;
      const m = String(matcher || '');
      return events.filter(e => String((e && e.type) || '').toUpperCase().includes(m)).length;
    }
    function herfindahl(obj){
      if (!obj || typeof obj !== 'object') return null;
      const values = Object.values(obj).map(v => Number(v)).filter(v => !Number.isNaN(v));
      const total = values.reduce((a,b)=>a+b,0);
      if (!total) return null;
      return values.reduce((a,v)=> a + Math.pow(v/total, 2), 0);
    }
    function formatArchetypeAttribution(primaryName){
      const ex = ARCHETYPE_EXEMPLARS[primaryName];
      if (!ex) return 'The play pattern most closely matches that of an Unknown hand.';
      return `The play pattern most closely matches that of ${ex.name}, ${ex.epithet}.`;
    }
    function formatCompact(v){
      const n = safeNumber(v, 0);
      const abs = Math.abs(n);
      if (abs >= 1000000) return `${(n/1000000).toFixed(1)}M`;
      if (abs >= 1000) return `${(n/1000).toFixed(1)}k`;
      return String(Math.round(n));
    }
    function setupCanvas(canvas){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(320, Math.round(rect.width || canvas.clientWidth || 900));
      const h = Math.max(220, Math.round(rect.height || canvas.clientHeight || 260));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return ctx;
    }
    function clearChart(ctx, w, h){ ctx.clearRect(0,0,w,h); }
    function drawAxes(ctx, w, h, pad, xLabel, yLabel, yMin, yMax){
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad);
      ctx.lineTo(pad, h-pad);
      ctx.lineTo(w-pad, h-pad);
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.65)';
      ctx.font = '11px ' + getComputedStyle(document.body).fontFamily;
      ctx.fillText(String(xLabel || ''), w - pad - 42, h - pad + 18);
      ctx.fillText(String(yLabel || ''), 8, pad - 8);
      ctx.fillText(formatCompact(yMax), 6, pad + 10);
      ctx.fillText(formatCompact(yMin), 6, h - pad + 2);
      ctx.restore();
    }
    function drawLineScaled(ctx, w, h, pad, xs, ys, yMin, yMax, color){
      if (!xs || !ys || !xs.length || !ys.length) return;
      const span = (yMax - yMin) || 1;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ys.forEach((v, i) => {
        const x = pad + clamp01(xs[i]) * (w - 2*pad);
        const y = pad + (1 - ((safeNumber(v,0) - yMin) / span)) * (h - 2*pad);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.restore();
    }
    function drawPoint(ctx, x, y, r=3){
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    }
    function drawTextBox(ctx, text, x, y){
      ctx.font = '11px ' + getComputedStyle(document.body).fontFamily;
      const pad = 4;
      const w = ctx.measureText(text).width + pad*2;
      const h = 16;
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(x, y-h, w, h);
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillText(text, x+pad, y-4);
    }
    function computePlaystyle(summary, derived){
      const matches = derived.matches || [];
      const events = derived.events || [];
      const lanes = derived.lanes || [];
      const deckTimeline = derived.deckTimeline || [];
      const matchesN = Math.max(1, summary.matches || matches.length || 1);
      const highTables = matches.filter(m=>String(m.tableType||'').toUpperCase()==='HIGH_STAKES').length;
      const bossTables = matches.filter(m=>String(m.tableType||'').toUpperCase()==='BOSS').length;
      const tableIntensity = (0.65*highTables + 1.0*bossTables) / matchesN;
      const avgTransferMult = avg(matches.map(m=>numOrNull(m.transferMultiplier)));
      const tempoApplied = countEvents(events, 'TEMPO_STRIKE_APPLIED');
      const tempoBlocked = countEvents(events, 'TEMPO_STRIKE_BLOCKED');
      const tempoApplyRate = (tempoApplied + tempoBlocked) ? tempoApplied / (tempoApplied + tempoBlocked) : 0;
      const tokensSpent = countEvents(events, 'TOKEN_SPENT');
      const actionsUsed = countEvents(events, 'ACTION_USED');
      const tokensPerMatch = tokensSpent / matchesN;
      const actionsPerMatch = actionsUsed / matchesN;
      const callingProcs = events.filter(e=>String((e && e.type) || '').startsWith('CALLING_PROC_')).length;
      const karmaGainEvents = countEvents(events, 'KARMA_GAIN');
      const callingPerMatch = callingProcs / matchesN;
      const deckEdits = deckTimeline.length ? Math.max(0, deckTimeline.length-1) : 0;
      const deckEditsPerMatch = deckEdits / matchesN;
      const editReasons = deckTimeline.map(d=>String((d && d.reason) || '').toUpperCase());
      const stampCount = editReasons.filter(r=>r==='STAMP_APPLY').length;
      const sleeveCount = editReasons.filter(r=>r==='SLEEVE_APPLY').length;
      const fuseCount = editReasons.filter(r=>r==='REWARD_FUSE').length;
      const duplicateCount = editReasons.filter(r=>r==='REWARD_DUPLICATE').length;
      const sinkAgg = summary.sinkAgg || {};
      const totalSpend = summary.totalSpend || 0;
      const merchantSpend = Math.abs((sinkAgg['Merchant removals']||0) + (sinkAgg['Merchant buys']||0) + (sinkAgg['Merchant rerolls']||0));
      const collectorSpend = Math.abs(sinkAgg['Collector']||0);
      const modifySpend = Math.abs(sinkAgg['Modify']||0);
      const surgerySpendShare = totalSpend ? (merchantSpend + collectorSpend + modifySpend) / totalSpend : 0;
      const bustRate = summary.playerBustRate ?? (lanes.length ? lanes.filter(l=>l.playerBust).length / lanes.length : 0);
      const controlTotals = summary.avgPlayerTotalNoBust ?? summary.avgPlayerTotal ?? null;
      const deckEnd = deckTimeline.length ? deckTimeline[deckTimeline.length-1] : null;
      herfindahl((deckEnd && (deckEnd.bySuit || (deckEnd.summary && deckEnd.summary.bySuit))) || null);
      const modDensity = summary.modDensityEnd ?? null;
      const risk = 100 * (0.45*clamp01(tableIntensity) + 0.35*normRange(avgTransferMult, 1, 5) + 0.20*normRange(summary.profitStdDev, 0, 200));
      const pressure = 100 * (0.55*normRange(tempoApplied / matchesN, 0, 6) + 0.25*normRange(actionsPerMatch, 0, 2) + 0.20*normRange(tempoApplyRate, 0.2, 0.6));
      const control = 100 * (0.5*(1 - normRange(bustRate, 0, 0.35)) + 0.25*normRange(controlTotals, 17, 20) + 0.25*normRange(modDensity, 0, 0.25));
      const surgery = 100 * (0.5*normRange(deckEditsPerMatch, 0, 1.5) + 0.25*normRange(surgerySpendShare, 0, 0.6) + 0.25*normRange(merchantSpend / Math.max(1, totalSpend), 0, 0.6));
      const engine = 100 * (0.45*normRange(stampCount + sleeveCount, 0, 6) + 0.35*normRange(fuseCount + duplicateCount, 0, 6) + 0.20*normRange(summary.player21Rate, 0.15, 0.65));
      const karma = 100 * (0.6*normRange(callingPerMatch, 0, 3) + 0.4*normRange(karmaGainEvents / matchesN, 0, 4));
      const actions = 100 * (0.55*normRange(tokensPerMatch, 0, 2) + 0.45*normRange(actionsPerMatch, 0, 1.5));
      const economy = 100 * (0.6*normRange((summary.chipsLow||0) / Math.max(1, summary.startChips||1), 0.2, 0.8) + 0.4*(1 - normRange(totalSpend / Math.max(1, Math.abs(summary.matchProfitTotal)||1), 0.5, 2)));
      const axes = { risk, pressure, control, surgery, engine, karma, actions, economy };
      const axes01 = Object.fromEntries(Object.entries(axes).map(([k,v])=>[k, clamp01(v/100)]));
      const archetypes = [
        {name:'The Surgeon', vec:{surgery:0.85, control:0.65, engine:0.4, economy:0.4}},
        {name:'The Saboteur', vec:{pressure:0.85, actions:0.7, risk:0.5}},
        {name:'The High Roller', vec:{risk:0.9, economy:0.2, control:0.2}},
        {name:'Engineer', vec:{engine:0.9, control:0.45, surgery:0.35}},
        {name:'Politico', vec:{karma:0.9, engine:0.5, control:0.35}},
        {name:'The Banker', vec:{economy:0.9, control:0.7, risk:0.1}}
      ];
      function cosineScore(vec){
        const keys = Object.keys(axes01);
        const a = keys.map(k=>axes01[k] ?? 0);
        const b = keys.map(k=>vec[k] ?? 0);
        const dot = a.reduce((s,v,i)=>s + v*b[i], 0);
        const magA = Math.sqrt(a.reduce((s,v)=>s+v*v, 0)) || 1;
        const magB = Math.sqrt(b.reduce((s,v)=>s+v*v, 0)) || 1;
        return dot / (magA * magB);
      }
      const scored = archetypes.map(a=>({name:a.name, score: cosineScore(a.vec)})).sort((a,b)=>b.score-a.score);
      const primary = scored[0] || {name:'Unknown', score:0};
      const secondary = scored[1] || {name:'None', score:0};
      const confidence = clamp01((primary.score - secondary.score) / 0.2);
      return { axes, primary, secondary, confidence, archetypeScores: scored };
    }
    function buildKarmaCumulative(matches, startKarma){
      let k = (typeof startKarma === 'number') ? startKarma : 0;
      return matches.map(m=>{ const g = (typeof m.karmaGained === 'number') ? m.karmaGained : 0; k += g; return k; });
    }
    function buildFloorEndMarkers(matches){
      const byFloor = new Map();
      matches.forEach((m, i)=>{ const f = (m.floor==null) ? null : Number(m.floor); if (f==null || Number.isNaN(f)) return; byFloor.set(f, i); });
      const floors = [...byFloor.keys()].sort((a,b)=>a-b);
      return floors.map(f=>{ const i = byFloor.get(f); const isBoss = String(matches[i] && matches[i].tableType || '').toUpperCase()==='BOSS'; return { floor:f, matchPos:i, isBoss }; });
    }
    function renderEndChipsChart(summary, derived){
      const canvas = document.getElementById('chartEndChips');
      if (!canvas) return;
      const ctx = setupCanvas(canvas);
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const pad = 42;
      const matches = derived.matches || [];
      if (!matches.length){ clearChart(ctx,w,h); return; }
      const xs = matches.map((_,i)=> i/(Math.max(1, matches.length-1)));
      const chips = matches.map(m=> (typeof m.chipsAfter === 'number') ? m.chipsAfter : 0);
      const yMin = Math.min(0, ...chips);
      const yMax = Math.max(1, ...chips);
      clearChart(ctx,w,h);
      drawAxes(ctx,w,h,pad,'Match','Chips',yMin,yMax);
      drawLineScaled(ctx,w,h,pad,xs,chips,yMin,yMax,'rgba(125,211,252,0.90)');
      const markers = buildFloorEndMarkers(matches);
      markers.forEach((m)=>{
        const xN = xs[m.matchPos];
        const x = pad + xN*(w-2*pad);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, h-pad); ctx.stroke();
        ctx.restore();
      });
      const cap = document.getElementById('endChartCaptionChips');
      if (cap) cap.textContent = 'Chips by match â€¢ floor ends marked';
    }

    function renderEndKarmaChart(summary, derived){
      const canvas = document.getElementById('chartEndKarma');
      if (!canvas) return;
      const ctx = setupCanvas(canvas);
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const pad = 42;
      const matches = derived.matches || [];
      if (!matches.length){ clearChart(ctx,w,h); return; }
      const xs = matches.map((_,i)=> i/(Math.max(1, matches.length-1)));
      const karma = buildKarmaCumulative(matches, summary.startKarma);
      const yMin = Math.min(0, ...karma);
      const yMax = Math.max(1, ...karma);
      clearChart(ctx,w,h);
      drawAxes(ctx,w,h,pad,'Match','Karma',yMin,yMax);
      drawLineScaled(ctx,w,h,pad,xs,karma,yMin,yMax,'rgba(52,211,153,0.90)');
      const markers = buildFloorEndMarkers(matches);
      markers.forEach((m)=>{
        const xN = xs[m.matchPos];
        const x = pad + xN*(w-2*pad);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.22)';
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, h-pad); ctx.stroke();
        ctx.restore();
      });
      const cap = document.getElementById('endChartCaptionKarma');
      if (cap) cap.textContent = 'Karma by match â€¢ floor ends marked';
    }

    function getRunEndAnalysis(){
      const events = (gameLog && gameLog.events) ? gameLog.events : [];
      const matches = events.filter(e => e && e.type === 'MATCH_END').map(e => ({
        floor: safeNumber(e.floor, e.ctx && e.ctx.floor),
        tableType: (e.data && e.data.type) || null,
        chipsAfter: safeNumber(e.chips, 0),
        karmaGained: safeNumber(e.data && e.data.karmaGained, 0),
        transferMultiplier: safeNumber(e.data && e.data.transferMultiplier, 0)
      }));
      const deckTimeline = (gameLog && Array.isArray(gameLog.deckHistory)) ? gameLog.deckHistory.slice() : [];
      const summaryDeck = buildDeckSummary();
      const initial = gameLog && gameLog.initialState ? gameLog.initialState : null;
      const finalState = gameLog && gameLog.finalState ? gameLog.finalState : null;
      const initialDeckSize = initial && initial.deckSnapshot ? safeNumber(initial.deckSnapshot.deckSize, null) : null;
      const finalDeckSize = finalState && finalState.deckSnapshot ? safeNumber(finalState.deckSnapshot.deckSize, null) : summaryDeck.deckSize;
      const finalModCount = finalState && finalState.deckSnapshot ? safeNumber(finalState.deckSnapshot.modCount, null) : summaryDeck.modCount;
      const summary = {
        matches: matches.length,
        runOutcome: { result: ((gameLog && gameLog.runOutcome && gameLog.runOutcome.outcome) || 'unknown').toUpperCase() === 'WIN' ? 'WIN' : (((gameLog && gameLog.runOutcome && gameLog.runOutcome.outcome) || '').toLowerCase() === 'loss' ? 'LOSS' : ((run && run.ui && run.ui.mode==='VICTORY') ? 'WIN' : (run && run.ui && run.ui.mode==='GAMEOVER' ? 'LOSS' : 'UNKNOWN'))) },
        appBuild: (gameLog && gameLog.app && gameLog.app.build) || null,
        appVersion: (gameLog && gameLog.app && gameLog.app.version) || null,
        sessionId: (gameLog && gameLog.sessionId) || null,
        startedAtISO: (gameLog && gameLog.startedAt) || null,
        startKarma: initial ? safeNumber(initial.karma, 0) : 0,
        startChips: initial ? safeNumber(initial.chips, STARTING_CHIPS) : STARTING_CHIPS,
        endChips: finalState ? safeNumber(finalState.chips, safeNumber(run && run.chips, 0)) : safeNumber(run && run.chips, 0),
        chipsLow: gameLog && gameLog.stats ? safeNumber(gameLog.stats.chipsLow, 0) : 0,
        matchProfitTotal: gameLog && gameLog.stats ? safeNumber(gameLog.stats.payoutReceived, 0) + safeNumber(gameLog.stats.transferNet, 0) - safeNumber(gameLog.stats.buyinSpent, 0) : 0,
        totalSpend: gameLog && gameLog.stats ? (
          safeNumber(gameLog.stats.buyinSpent, 0)
          + safeNumber(gameLog.stats.merchantBuyChips, 0)
          + safeNumber(gameLog.stats.merchantRemoveChips, 0)
          + safeNumber(gameLog.stats.merchantRerollChips, 0)
          + safeNumber(gameLog.stats.collectorBuyChips, 0)
          + safeNumber(gameLog.stats.modifySpendChips, 0)
          + safeNumber(gameLog.stats.cocktailSpendChips, 0)
        ) : 0,
        sinkAgg: {
          'Merchant buys': -(gameLog && gameLog.stats ? safeNumber(gameLog.stats.merchantBuyChips, 0) : 0),
          'Merchant removals': -(gameLog && gameLog.stats ? safeNumber(gameLog.stats.merchantRemoveChips, 0) : 0),
          'Merchant rerolls': -(gameLog && gameLog.stats ? safeNumber(gameLog.stats.merchantRerollChips, 0) : 0),
          'Collector': -(gameLog && gameLog.stats ? safeNumber(gameLog.stats.collectorBuyChips, 0) : 0),
          'Modify': -(gameLog && gameLog.stats ? safeNumber(gameLog.stats.modifySpendChips, 0) : 0),
          'Cocktails': -(gameLog && gameLog.stats ? safeNumber(gameLog.stats.cocktailSpendChips, 0) : 0)
        },
        profitStdDev: 0,
        player21Rate: 0,
        playerBustRate: 0,
        avgPlayerTotalNoBust: null,
        avgPlayerTotal: null,
        deckSizeStart: Number.isFinite(initialDeckSize) ? initialDeckSize : 'â€”',
        deckSizeEnd: Number.isFinite(finalDeckSize) ? finalDeckSize : 'â€”',
        modCountEnd: Number.isFinite(finalModCount) ? finalModCount : 'â€”',
        modDensityEnd: (Number.isFinite(finalDeckSize) && finalDeckSize > 0 && Number.isFinite(finalModCount)) ? (finalModCount / finalDeckSize) : null
      };
      const derived = { matches, events, lanes: [], deckTimeline };
      summary.playstyle = computePlaystyle(summary, derived);
      return { summary, derived };
    }
    function renderRunEndPanel(analysis){
      const s = analysis.summary;
      const d = analysis.derived;
      const result = (((s.runOutcome && s.runOutcome.result) || 'UNKNOWN') + '').toUpperCase();
      const endLore = document.getElementById('endLore');
      if (endLore) endLore.textContent = PIT_MESSAGES[result] || PIT_MESSAGES.UNKNOWN;
      const play = s.playstyle || computePlaystyle(s, d);
      const archetypeLine = formatArchetypeAttribution(play.primary && play.primary.name);
      const resonancePct = Math.round((play.confidence || 0) * 100);
      const lineEl = document.getElementById('endArchetypeLine');
      if (lineEl) lineEl.textContent = archetypeLine;
      const resEl = document.getElementById('endResonance');
      if (resEl) resEl.textContent = `${resonancePct}% Resonance`;
      const build = s.appBuild ?? 'â€”';
      const deckStart = s.deckSizeStart ?? 'â€”';
      const deckEnd = s.deckSizeEnd ?? 'â€”';
      const modsEnd = s.modCountEnd ?? 'â€”';
      const modDens = (s.modDensityEnd != null) ? `${Math.round(s.modDensityEnd * 100)}%` : 'â€”';
      const sid = s.sessionId || 'â€”';
      const sidShort = (typeof sid === 'string' && sid.length > 10) ? sid.slice(0,10) + 'â€¦' : sid;
      const stampCount = run.playerDeck.filter(c => !!getCardStampId(c)).length;
      const sleeveCount = run.playerDeck.filter(c => isFused(c) || (isStandardCard(c) && !!c.sleeveId)).length;
      const fusedCount  = run.playerDeck.filter(c => isFused(c)).length;
      const statsEl = document.getElementById('endBuildDeckStats');
      if (statsEl) {
        statsEl.innerHTML = `
          <div class="run-end-block run-end-tiny">
            <div><b>Build:</b> ${escapeHtml(String(build))}</div>
            <div><b>Config:</b> â€”</div>
            <div><b>Session:</b> ${escapeHtml(String(sidShort))}</div>
            <div><b>Start:</b> ${escapeHtml(String(s.startedAtISO || 'â€”'))}</div>
          </div>
          <div class="run-end-block run-end-tiny">
            <div><b>Deck:</b> ${escapeHtml(String(deckStart))} â†’ ${escapeHtml(String(deckEnd))}</div>
            <div><b>Mods:</b> ${escapeHtml(String(modsEnd))}</div>
            <div><b>Mod density:</b> ${escapeHtml(String(modDens))}</div>
            <div><b>Chips:</b> ${escapeHtml(String(formatCompact(s.startChips)))} â†’ ${escapeHtml(String(formatCompact(s.endChips)))}</div>
            <div><b>Stamps:</b> ${stampCount} Â· <b>Sleeves:</b> ${sleeveCount} Â· <b>Fused:</b> ${fusedCount}</div>
          </div>
        `;
      }
      renderEndChipsChart(s, d);
      renderEndKarmaChart(s, d);
    }
    function renderEndScreen() {
      const boardView = document.getElementById('boardView');
      const blackjackView = document.getElementById('blackjackView');
      const endScreen = document.getElementById('endScreen');

      if (run.ui.mode !== 'GAMEOVER' && run.ui.mode !== 'VICTORY') {
        endScreen.classList.add('hidden');
        return;
      }

      boardView.classList.add('hidden');
      blackjackView.classList.add('hidden');
      endScreen.classList.remove('hidden');

      const isVictory = run.ui.mode === 'VICTORY';
      const title = isVictory ? 'Victory' : 'Game Over';
      const titleCls = isVictory ? 'victory' : 'gameover';
      const msg = isVictory ? 'You cleared The Pit.' : (run.ui.message || 'Your run has ended.');

      endScreen.innerHTML = `
        <div class="end-screen">
          <div class="end-title ${titleCls}">${title}</div>
          <div class="end-message">${msg}</div>

          <div class="run-end-card" id="runEndCard">
            <div class="run-end-head">
              <div>
                <div class="run-end-title">Run End</div>
                <div class="run-end-sub" id="runEndSub">A compact summary for players.</div>
              </div>
            </div>
            <div class="run-end-lore" id="endLore"></div>
            <div class="run-end-tiny" id="endArchetypeLine"></div>
            <div class="run-end-tiny run-end-muted" id="endResonance" style="margin-bottom:10px;"></div>
            <div class="run-end-cols" id="endBuildDeckStats"></div>
            <canvas id="chartEndChips"></canvas>
            <div class="run-end-tiny run-end-muted" id="endChartCaptionChips" style="margin-top:8px;"></div>
            <canvas id="chartEndKarma" style="margin-top:10px;"></canvas>
            <div class="run-end-tiny run-end-muted" id="endChartCaptionKarma" style="margin-top:8px;"></div>
          </div>

          <div style="display:flex; gap:12px; flex-wrap:wrap; justify-content:center;">
            <button class="bj-btn" onclick="openLogPanel('stats')">Open Run Log</button>
            <button class="bj-btn" onclick="openFeedbackModal()">Feedback</button>
            <button class="bj-btn" onclick="initRun()">New Run</button>
          </div>
        </div>
      `;

      const analysis = getRunEndAnalysis();
      renderRunEndPanel(analysis);
    }

    // =============================================
    // BOOT
    // =============================================
    (function boot() {
      // Try to keep last log available after refresh (doesn't overwrite current run)
      try {
        const saved = localStorage.getItem(LOG_STORAGE_KEY);
        if (saved) {
          const parsed = JSON.parse(saved);
          if (parsed && parsed.sessionId && !gameLog) gameLog = parsed;
        }
      } catch (e) {}

      loadSfxPrefs();
      loadHelpPrefs();
      applyReduceMotion();
      installGlobalClickSfx();
      setupCardTooltip();
      setupActionTooltip();
      setupTileTooltip();
      initStartPlasma();
      initIntroPlasma();
      initRun();
      const c=document.getElementById('btnContinue'); if (c) c.onclick = () => { hideStartScreen(); renderAll(); };
      const n=document.getElementById('btnNewRun'); if (n) n.onclick = () => { initRun(); hideStartScreen(); };
      const r=document.getElementById('btnRules'); if (r) r.onclick = () => openRulesPanel();
      const tg=document.getElementById('btnTestGames'); if (tg) tg.onclick = () => openTestGamesModal();
      const se=document.getElementById('btnSettings'); if (se) se.onclick = () => openSettingsPanel();
      const fb=document.getElementById('btnFeedback'); if (fb) fb.onclick = () => openFeedbackModal();
      updateStartRunCard();
      showStartScreen();
      renderAll();
    })();
  </script>
</body>
</html>
