<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project 63 ‚Äî Infiltration Run (Scoundrel Variant)</title>

  <!-- Match MVP typography -->
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ------------------------------------------------------------
      P63 MVP THEME (kept compatible with p63_0.47.html)
      ------------------------------------------------------------ */
    :root {
      /* Film Noir ‚Äî Default Theme */
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-card: #262626;
      --bg-hover: #2c2c2c;

      --text-primary: #f5f5f5;
      --text-secondary: #b8b8b8;
      --text-muted: #737373;

      --accent-gold: #d4af37;
      --accent-gold-dim: #8a6f1f;
      --accent-red: #a83232;
      --accent-green: #5e8c61;
      --accent-blue: #5f7d95;
      --accent-purple: #7d6a82;

      --border-color: #404040;

      /* Playing card ink (used on white cards) */
      --card-red: #b13b3b;
      --card-black: #111111;

      /* Typography */
      --font-display: 'Bebas Neue', sans-serif;
      --font-mono: 'Space Mono', monospace;
      --font-body: 'Inter', sans-serif;

      /* Derived wash colors */
      --wash-gold: rgba(212, 175, 55, 0.14);
      --wash-red: rgba(168, 50, 50, 0.18);
      --wash-green: rgba(94, 140, 97, 0.18);
      --wash-blue: rgba(95, 125, 149, 0.16);
      --wash-purple: rgba(125, 106, 130, 0.16);

      /* Noir polish */
      --noir-bg-primary: #0f1119;
      --noir-bg-secondary: #141820;
      --noir-shadow-gold: #261d0d;
      --noir-muted-gold: #6c5b21;
      --noir-soft-gold: #d4af37;
      --noir-text-primary: #e4e4e7;
      --noir-text-secondary: #a1a1aa;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: var(--font-body);
      background:
        radial-gradient(ellipse at 50% -10%, rgba(212,175,55,0.18), rgba(15,17,25,0.0) 55%),
        radial-gradient(ellipse at 40% 115%, rgba(95,125,149,0.18), rgba(15,17,25,0.0) 55%),
        linear-gradient(180deg, var(--noir-bg-primary), var(--bg-primary));
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 16px 40px;
      -webkit-tap-highlight-color: transparent;
    }

    h1 {
      font-family: var(--font-display);
      font-size: 2.6em;
      letter-spacing: 6px;
      color: var(--accent-gold);
      text-shadow: 0 0 18px rgba(212,175,55,0.22);
      margin: 10px 0 4px;
      text-transform: uppercase;
    }
    .subtitle {
      color: var(--text-muted);
      font-size: 0.82em;
      letter-spacing: 2px;
      margin-bottom: 16px;
      text-transform: uppercase;
    }

    #game-container { width: 100%; max-width: 760px; }

    /* ‚îÄ‚îÄ RUN LENGTH SELECTOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .length-bar {
      display: flex;
      margin-bottom: 14px;
      border: 1px solid rgba(212,175,55,0.25);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,0.02);
    }
    .length-opt {
      flex: 1;
      padding: 9px 8px 8px;
      cursor: pointer;
      background: transparent;
      border: none;
      border-right: 1px solid rgba(212,175,55,0.14);
      color: var(--text-muted);
      font-family: var(--font-body);
      font-size: 0.82em;
      text-align: center;
      transition: all 0.18s;
      line-height: 1.35;
    }
    .length-opt:last-child { border-right: none; }
    .length-opt:hover  { background: rgba(212,175,55,0.06); color: var(--text-secondary); }
    .length-opt.active { background: rgba(212,175,55,0.10); color: var(--text-primary); }
    .length-opt .lo-name   { font-family: var(--font-display); font-size: 1.05em; letter-spacing: 2px; display: block; text-transform: uppercase; }
    .length-opt .lo-detail { font-size: 0.82em; opacity: 0.85; display: block; }

    /* ‚îÄ‚îÄ STATS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .stats {
      display: flex;
      gap: 14px;
      align-items: stretch;
      margin-bottom: 14px;
      padding: 12px 14px;
      background:
        linear-gradient(90deg, rgba(212,175,55,0.65), rgba(95,125,149,0.45)) top/100% 3px no-repeat,
        rgba(255,255,255,0.03);
      border: 1px solid rgba(148, 163, 184, 0.20);
      border-radius: 14px;
    }
    .meter-section { flex: 1; display: flex; flex-direction: column; justify-content: center; }
    .stat-label { font-size: 0.68em; color: var(--text-muted); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; }
    .meter-bg  { height: 13px; background: rgba(0,0,0,0.35); border-radius: 10px; border: 1px solid rgba(148,163,184,0.25); overflow: hidden; }
    .meter-bar { height: 100%; border-radius: 10px; transition: width 0.35s ease, background 0.35s; }
    .meter-text { font-family: var(--font-mono); font-size: 0.78em; margin-top: 5px; text-align: right; color: var(--text-secondary); }

    .stat-box {
      text-align: center;
      display: flex; flex-direction: column; justify-content: center;
      padding: 0 12px;
      border-left: 1px solid rgba(148,163,184,0.18);
      min-width: 120px;
    }
    .tool-val { font-family: var(--font-mono); font-size: 1.02em; color: var(--text-primary); white-space: nowrap; }
    .tool-val.none { color: rgba(255,255,255,0.25); font-style: italic; }
    .tool-cap { font-family: var(--font-body); font-size: 0.70em; color: var(--text-muted); margin-top: 3px; white-space: nowrap; }
    .deck-num { font-family: var(--font-display); font-size: 1.9em; color: var(--accent-gold); line-height: 1; letter-spacing: 2px; }

    /* ‚îÄ‚îÄ COVER USED BANNER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .cover-banner {
      text-align: center;
      font-size: 0.76em;
      color: rgba(212,175,55,0.85);
      letter-spacing: 1px;
      margin: 0 0 10px;
      padding: 6px 10px;
      background: rgba(212,175,55,0.08);
      border: 1px solid rgba(212,175,55,0.18);
      border-radius: 10px;
      display: none;
    }
    .cover-banner.visible { display: block; }

    /* ‚îÄ‚îÄ NODE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .node-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      gap: 10px;
    }
    .node-label {
      font-size: 0.72em;
      color: var(--text-muted);
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .progress-label {
      font-family: var(--font-mono);
      font-size: 0.78em;
      color: var(--text-secondary);
    }

    .node {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 12px;
      min-height: 184px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* ‚îÄ‚îÄ CARDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .card {
      width: 118px;
      height: 178px;
      background: white;
      border-radius: 12px;
      border: 2px solid rgba(221,221,221,0.9);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      transition: transform 0.16s, box-shadow 0.16s, opacity 0.25s;
      box-shadow: 0 6px 18px rgba(0,0,0,0.55);
      user-select: none;
      isolation: isolate;
    }

    .card::before{
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 12px;
      opacity: 0.0;
      pointer-events: none;
      transition: opacity 0.16s;
      background: radial-gradient(ellipse at 50% 20%, rgba(212,175,55,0.25), rgba(212,175,55,0.0) 55%);
    }

    .card:hover:not(.played):not(.no-interact) {
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 18px 36px rgba(0,0,0,0.75);
      z-index: 5;
    }
    .card:hover:not(.played):not(.no-interact)::before{ opacity: 1; }

    .card.played {
      opacity: 0.16;
      cursor: default;
      pointer-events: none;
      transform: scale(0.96);
    }
    .card.no-interact { cursor: not-allowed; }

    /* Type borders (use MVP accents) */
    .card.detection { border-color: rgba(168, 50, 50, 0.85); }
    .card.cover     { border-color: rgba(94, 140, 97, 0.85); }
    .card.tool      { border-color: rgba(95, 125, 149, 0.85); }
    .card.tool-locked { border-color: rgba(212,175,55,0.75); }
    .card.cover-spent { opacity: 0.80; border-color: rgba(94, 140, 97, 0.45); }

    .card.red-suit   .cv, .card.red-suit   .cs { color: var(--card-red); }
    .card.black-suit .cv, .card.black-suit .cs { color: var(--card-black); }

    .corner { position: absolute; display: flex; flex-direction: column; align-items: center; line-height: 1; font-family: var(--font-mono); }
    .corner.tl { top: 8px; left: 10px; }
    .corner.br { bottom: 8px; right: 10px; transform: rotate(180deg); }
    .cv { font-size: 1.02em; font-weight: 800; }
    .cs { font-size: 0.86em; }

    .card-center { display: flex; flex-direction: column; align-items: center; gap: 1px; }
    .big-suit { font-size: 2.6em; line-height: 1; }
    .big-val  { font-family: var(--font-mono); font-size: 1.28em; font-weight: 800; line-height: 1; }
    .card-type-tag {
      font-family: var(--font-body);
      font-size: 0.60em;
      letter-spacing: 1.3px;
      text-transform: uppercase;
      color: rgba(0,0,0,0.55);
      margin-top: 4px;
      font-weight: 700;
      text-align: center;
    }
    .card-sub {
      font-family: var(--font-mono);
      font-size: 0.62em;
      font-weight: 700;
      margin-top: 4px;
      text-align: center;
    }
    .card-sub.exposure-reduced { color: #2f6b3a; }
    .card-sub.exposure-locked  { color: #8a6f1f; }
    .card-sub.exposure-full    { color: #8a2010; }
    .card-sub.no-cover         { color: #6b5b20; font-style: italic; }

    .card.detection.danger { border-width: 3px; border-color: rgba(168, 50, 50, 1.0); }
    .card.detection.danger::after{
      content: "!";
      position: absolute; top: -10px; right: -10px;
      font-family: var(--font-display);
      font-size: 0.95em;
      color: rgba(168, 50, 50, 1.0);
      width: 22px; height: 22px;
      display: flex; align-items: center; justify-content: center;
      border-radius: 999px;
      background: rgba(0,0,0,0.75);
      border: 1px solid rgba(168, 50, 50, 0.7);
      box-shadow: 0 0 14px rgba(168, 50, 50, 0.25);
    }

    /* ‚îÄ‚îÄ ACTIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .actions {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .btn {
      font-family: var(--font-display);
      font-size: 0.90em;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.18s;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-primary);
    }
    .btn:hover:not(:disabled) { background: var(--bg-hover); border-color: var(--accent-gold); }
    .btn:disabled { opacity: 0.40; cursor: not-allowed; }

    .btn-secondary { background: rgba(255,255,255,0.03); color: var(--text-secondary); }
    .btn-secondary:hover:not(:disabled) { border-color: rgba(148,163,184,0.6); }
    .btn-primary {
      background: rgba(95,125,149,0.22);
      border-color: rgba(95,125,149,0.70);
      color: var(--text-primary);
    }
    .btn-primary:hover:not(:disabled) { border-color: var(--accent-gold); background: rgba(95,125,149,0.30); }

    .btn-branch {
      background: rgba(212,175,55,0.12);
      border-color: rgba(212,175,55,0.55);
    }
    .btn-branch:hover:not(:disabled) { background: rgba(212,175,55,0.18); }

    /* ‚îÄ‚îÄ LOG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .log {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 14px;
      padding: 10px 14px;
      max-height: 120px;
      overflow-y: auto;
      font-size: 0.86em;
      line-height: 1.55;
      color: var(--text-secondary);
    }
    .log::-webkit-scrollbar { width: 4px; }
    .log::-webkit-scrollbar-thumb { background: rgba(148,163,184,0.35); border-radius: 2px; }

    .log-entry { color: var(--text-secondary); }
    .log-entry.info   { color: rgba(245,245,245,0.75); }
    .log-entry.system { color: var(--accent-gold); font-style: italic; }
    .log-entry.exposure { color: rgba(168, 50, 50, 0.95); }
    .log-entry.cover  { color: rgba(94, 140, 97, 0.95); }
    .log-entry.tool   { color: rgba(95, 125, 149, 1.0); }
    .log-entry.branch { color: rgba(212,175,55,0.95); }

    /* ‚îÄ‚îÄ RULES PANEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .rules-panel {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 14px;
      padding: 14px 16px;
      margin-bottom: 14px;
      font-size: 0.86em;
      line-height: 1.55;
      color: var(--text-secondary);
      display: none;
    }
    .rules-panel.open { display: block; }
    .rules-panel h3 {
      font-family: var(--font-display);
      color: var(--accent-gold);
      margin-bottom: 10px;
      font-size: 1.2em;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .rules-panel b { color: rgba(245,245,245,0.82); }
    .rr { margin-bottom: 8px; }

    /* ‚îÄ‚îÄ CHALLENGE MODAL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .modal-overlay {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex; align-items: center; justify-content: center;
      z-index: 100;
      backdrop-filter: blur(3px);
    }
    .modal {
      background: linear-gradient(180deg, rgba(20,24,32,0.95), rgba(15,15,15,0.95));
      border: 1px solid rgba(148,163,184,0.26);
      border-radius: 16px;
      padding: 22px 20px;
      text-align: center;
      max-width: 380px;
      width: 92%;
      box-shadow: 0 0 60px rgba(0,0,0,0.55);
      position: relative;
      overflow: hidden;
    }
    .modal::before{
      content:"";
      position:absolute;
      left:0; top:0; right:0;
      height:3px;
      background: linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55));
    }
    .modal h3 {
      font-family: var(--font-display);
      color: var(--accent-gold);
      margin-bottom: 10px;
      font-size: 1.25em;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    .modal .modal-body {
      color: var(--text-secondary);
      margin-bottom: 16px;
      font-size: 0.92em;
      line-height: 1.6;
    }
    .modal .modal-body strong { color: rgba(245,245,245,0.9); }
    .modal .degrade-note {
      display: block;
      margin-top: 10px;
      padding: 8px 10px;
      background: rgba(212,175,55,0.10);
      border: 1px solid rgba(212,175,55,0.18);
      border-radius: 10px;
      color: rgba(212,175,55,0.95);
      font-size: 0.92em;
    }
    .modal-btns { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .btn-use-tool {
      background: rgba(95,125,149,0.26);
      border-color: rgba(95,125,149,0.70);
    }
    .btn-use-tool:hover:not(:disabled){ border-color: var(--accent-gold); }
    .btn-manual {
      background: rgba(168,50,50,0.10);
      border-color: rgba(168,50,50,0.55);
    }
    .btn-manual:hover:not(:disabled){ border-color: rgba(168,50,50,0.85); }

    /* ‚îÄ‚îÄ ENDGAME ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .endgame {
      position: fixed; inset: 0;
      background: rgba(0,0,0,0.92);
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      z-index: 200;
      text-align: center;
      padding: 20px;
    }
    .endgame h2 {
      font-family: var(--font-display);
      font-size: 3em;
      letter-spacing: 6px;
      margin-bottom: 14px;
      text-transform: uppercase;
      animation: pulse 2s ease-in-out infinite;
    }
    .endgame.dead h2 { color: rgba(168,50,50,1.0); text-shadow: 0 0 34px rgba(168,50,50,0.55); }
    .endgame.win  h2 { color: var(--accent-gold); text-shadow: 0 0 34px rgba(212,175,55,0.35); }

    .endgame p {
      color: var(--text-secondary);
      margin-bottom: 18px;
      font-size: 1.02em;
      line-height: 1.55;
      max-width: 420px;
    }
    .endgame p strong { color: rgba(245,245,245,0.9); }

    .loot {
      width: 100%;
      max-width: 420px;
      margin: 0 auto 18px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(148,163,184,0.18);
      border-radius: 14px;
      padding: 12px 14px;
      text-align: left;
    }
    .loot-title{
      font-family: var(--font-display);
      font-size: 1.05em;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--accent-gold);
      margin-bottom: 8px;
    }
    .loot-item{
      font-family: var(--font-mono);
      font-size: 0.90em;
      color: var(--text-primary);
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.18);
      background: rgba(0,0,0,0.22);
      margin-bottom: 6px;
    }
    .loot-item:last-child{ margin-bottom: 0; }

    /* Reward card placeholders (winner screen) */
    .loot-sub{
      margin-top: 6px;
      font-size: 13px;
      color: rgba(255,255,255,0.55);
    }
    .loot-items{
      display: flex;
      justify-content: center;
      gap: 14px;
      margin-top: 14px;
      flex-wrap: wrap;
    }
    .reward-card{
      width: 112px;
      height: 172px;
      border-radius: 14px;
      border: 1px solid rgba(148,163,184,0.22);
      background: linear-gradient(160deg, rgba(255,255,255,0.05) 0%, rgba(0,0,0,0.12) 100%);
      box-shadow: 0 10px 26px rgba(0,0,0,0.55), inset 0 1px 0 rgba(255,255,255,0.08);
      cursor: pointer;
      position: relative;
      transition: transform 0.18s, box-shadow 0.18s, border-color 0.18s;
      user-select: none;
    }
    .reward-card::after{
      content: '';
      position: absolute;
      inset: 12px;
      border-radius: 12px;
      border: 1px dashed rgba(148,163,184,0.18);
      opacity: 0.9;
    }
    .reward-card:hover{
      transform: translateY(-8px) scale(1.02);
      border-color: rgba(var(--gold-rgb),0.60);
      box-shadow: 0 16px 34px rgba(0,0,0,0.70), 0 0 24px rgba(var(--gold-rgb),0.18), inset 0 1px 0 rgba(255,255,255,0.10);
    }
    .reward-card.selected{
      border-color: rgba(var(--gold-rgb),0.95);
      box-shadow: 0 18px 40px rgba(0,0,0,0.75), 0 0 34px rgba(var(--gold-rgb),0.22), inset 0 1px 0 rgba(255,255,255,0.12);
    }

    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.72; } }
    .hidden { display: none !important; }
  </style>
</head>

<body>
  <h1>Infiltration Run</h1>
  <p class="subtitle">Project 63 ‚Äî Solo Node Crawler</p>

  <div id="game-container">

    <!-- Run Length -->
    <div class="length-bar">
      <button class="length-opt" data-len="short" onclick="setLength('short')">
        <span class="lo-name">Quick</span>
        <span class="lo-detail">20 cards ¬∑ ~5 nodes</span>
      </button>
      <button class="length-opt" data-len="medium" onclick="setLength('medium')">
        <span class="lo-name">Standard</span>
        <span class="lo-detail">32 cards ¬∑ ~8 nodes</span>
      </button>
      <button class="length-opt active" data-len="full" onclick="setLength('full')">
        <span class="lo-name">Full</span>
        <span class="lo-detail">44 cards ¬∑ ~11 nodes</span>
      </button>
    </div>

    <!-- Stats -->
    <div class="stats">
      <div class="meter-section">
        <div class="stat-label">Exposure</div>
        <div class="meter-bg"><div class="meter-bar" id="exp-bar"></div></div>
        <div class="meter-text" id="exp-text">0 / 20</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Tool</div>
        <div class="tool-val none" id="tool-val">None</div>
        <div class="tool-cap" id="tool-cap"></div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Deck</div>
        <div class="deck-num" id="deck-count">--</div>
      </div>
    </div>

    <!-- Buttons -->
    <div class="actions" style="margin-bottom:10px">
      <button class="btn btn-secondary" onclick="toggleRules()">Rules</button>
      <button class="btn btn-primary" onclick="initGame()">‚ü≤ New Run</button>
    </div>

    <!-- Rules Panel -->
    <div class="rules-panel" id="rules-panel">
      <h3>How to Play</h3>
      <div class="rr">
        <b>Card types ‚Äî</b>
        <b>‚ô† ‚ô£ (black) 2‚ÄìA</b> = <b>Detection</b> (rank = exposure gained; A=14, K=13, Q=12, J=11).
        <b>‚ô• 2‚Äì10</b> = <b>Cover</b> (reduces exposure by that amount, min 0).
        <b>‚ô¶ 2‚Äì10</b> = <b>Tool</b> (equips mitigation vs detection).
        Red J, Q, K, A are not in the deck.
      </div>
      <div class="rr">
        <b>Each node ‚Äî</b> 4 cards dealt face-up. Play exactly 3; the 4th is <b>carried forward</b>.
        When the deck is empty after dealing, it is the <b>final node</b>: play all cards, none carried.
      </div>
      <div class="rr">
        <b>Cover ‚Äî</b> only the <i>first</i> cover card played in a node applies. Extra cover is discarded with no effect.
        Dimmed cover cards (with ‚Äúno effect‚Äù) won‚Äôt reduce exposure.
      </div>
      <div class="rr">
        <b>Mitigation with a tool ‚Äî</b> exposure gained = max(0, detection rank ‚àí tool rank).
        <i>Tool signature:</i> after mitigating a detection of rank N, the tool can only mitigate future detections ranked strictly less than N.
        Manual bypass never increases the tool signature.
        Locked detections cannot be targeted by your current tool.
      </div>
      <div class="rr">
        <b>Change Branch ‚Äî</b> all node cards go to the <i>bottom</i> of the deck in current order (no shuffle).
        Cannot change branch two nodes in a row.
      </div>
      <div class="rr">
        <b>Shorter decks</b> use balanced subsets: equal proportions of detection, cover, and tools with ranks spread across the full range.
      </div>
    </div>

    <!-- Cover banner -->
    <div class="cover-banner" id="cover-banner">
      Cover already applied this node ‚Äî additional cover will be discarded
    </div>

    <!-- Node -->
    <div class="node-header">
      <div class="node-label">Current Node</div>
      <div class="progress-label" id="progress-label"></div>
    </div>
    <div class="node" id="node"></div>

    <!-- Change Branch -->
    <div class="actions">
      <button class="btn btn-branch" id="branch-btn" onclick="changeBranch()">‚ö° Change Branch</button>
    </div>

    <!-- Log -->
    <div class="log" id="log"></div>
  </div>

  <!-- Challenge Modal -->
  <div class="modal-overlay hidden" id="challenge-modal">
    <div class="modal">
      <h3 id="modal-title"></h3>
      <div class="modal-body" id="modal-desc"></div>
      <div class="modal-btns">
        <button class="btn btn-use-tool" id="modal-tool-btn" onclick="resolveWithTool()">Use Tool</button>
        <button class="btn btn-manual" onclick="resolveManual()">Manual Bypass</button>
      </div>
    </div>
  </div>

  <!-- Endgame -->
  <div class="endgame hidden" id="endgame">
    <h2 id="eg-title"></h2>
    <p id="eg-msg"></p>

    <div class="loot hidden" id="loot-box">
      <div class="loot-title" id="loot-title">Choose 1 Reward</div>
      <div class="loot-sub" id="loot-sub">Select a modified card to carry forward.</div>
      <div class="loot-items" id="loot-items"></div>
    </div>

    <button class="btn btn-primary" id="eg-action-btn" onclick="endgameAction()">New Run</button>
  </div>

<script>

  // ================================================================
  //  HELPERS
  // ================================================================
  function valStr(v) {
    return ({11:'J', 12:'Q', 13:'K', 14:'A'})[v] || String(v);
  }

  function cardType(suit, val) {
    if (suit === '\u2660' || suit === '\u2663') return 'detection'; // spade, club
    if (suit === '\u2665') return 'cover'; // heart
    return 'tool'; // diamond
  }

  function cardDesc(c) { return valStr(c.value) + c.suit; }

  function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // ================================================================
  //  DECK CONFIGS (mechanics unchanged; just reskinned terminology)
  // ================================================================
  const DECK_CONFIGS = {
    short:  { lowRanks: [2, 5, 8, 10],          highRanks: [12, 13] },
    medium: { lowRanks: [2, 3, 5, 6, 8, 9, 10], highRanks: [11, 13] },
    full:   null
  };

  function buildDeck(lengthKey) {
    const deck = [];
    const SUITS = ['\u2660', '\u2663', '\u2665', '\u2666']; // spade club heart diamond

    if (lengthKey === 'full') {
      // 44-card standard deck
      for (const suit of ['\u2660', '\u2663'])
        for (let v = 2; v <= 14; v++)
          deck.push({ suit, value: v, type: 'detection' });
      for (let v = 2; v <= 10; v++)
        deck.push({ suit: '\u2665', value: v, type: 'cover' });
      for (let v = 2; v <= 10; v++)
        deck.push({ suit: '\u2666', value: v, type: 'tool' });
    } else {
      const cfg = DECK_CONFIGS[lengthKey];
      // Low ranks across all 4 suits
      for (const suit of SUITS)
        for (const v of cfg.lowRanks)
          deck.push({ suit, value: v, type: cardType(suit, v) });
      // High ranks (detection only) -- spade and club
      for (const suit of ['\u2660', '\u2663'])
        for (const v of cfg.highRanks)
          deck.push({ suit, value: v, type: 'detection' });
    }
    return deck;
  }

  // ================================================================
  //  GAME STATE
  // ================================================================
  let deck = [];
  let node = [];
  let carryCard = null;

  let runner = { exposure: 0, maxExposure: 20 };
  let tool = null; // {suit, value, maxDetectionValue}
  let canBranch = true;
  let coverUsedThisNode = false;
  let finalNode = false;

  let pendingDetection = null;
  let pendingDetectionIdx = null;

  let selectedLength = 'full';

    // Reward placeholders (victory screen)
  let endgameMode = null;          // 'win' | 'dead'
  let rewardChoices = [];
  let selectedRewardIdx = null;

  function buildPlaceholderRewards() {
    // Placeholder pool. In the full game, these will map to real stamped/sleeved cards and modifiers.
    const pool  = Array.from({ length: 24 }, (_, i) => i);
    const picks = shuffle(pool).slice(0, 3);
    return picks.map(id => ({ id }));
  }

  function renderRewardChoices() {
    const lootBox   = document.getElementById('loot-box');
    const items     = document.getElementById('loot-items');
    const actionBtn = document.getElementById('eg-action-btn');

    items.innerHTML = '';
    selectedRewardIdx = null;

    rewardChoices.forEach((r, idx) => {
      const d = document.createElement('div');
      d.className = 'reward-card';
      d.title = 'Select reward';
      d.onclick = () => selectReward(idx);
      items.appendChild(d);
    });

    lootBox.classList.remove('hidden');
    actionBtn.disabled = true;
  }

  function selectReward(idx) {
    selectedRewardIdx = idx;
    const nodes = Array.from(document.querySelectorAll('#loot-items .reward-card'));
    nodes.forEach((n, i) => n.classList.toggle('selected', i === idx));
    document.getElementById('eg-action-btn').disabled = false;
  }

  function endgameAction() {
    if (endgameMode === 'win') {
      if (selectedRewardIdx === null) return;
      // Placeholder: in the full game, we'd add rewardChoices[selectedRewardIdx] to the run.
      initGame();
    } else {
      initGame();
    }
  }


  // ================================================================
  //  SETUP
  // ================================================================
  function setLength(len) {
    selectedLength = len;
    document.querySelectorAll('.length-opt').forEach(el =>
      el.classList.toggle('active', el.dataset.len === len)
    );
  }

  function initGame() {
    deck = shuffle(buildDeck(selectedLength));
    runner = { exposure: 0, maxExposure: 20 };
    tool = null;
    canBranch = true;
    carryCard = null;
    coverUsedThisNode = false;
    finalNode = false;
    pendingDetection = pendingDetectionIdx = null;
    node = [];

    document.getElementById('endgame').classList.add('hidden');
    document.getElementById('challenge-modal').classList.add('hidden');
    document.getElementById('loot-box').classList.add('hidden');
    document.getElementById('loot-items').innerHTML = '';
    document.getElementById('log').innerHTML = '';

    const labels = { short: 'Quick (20 cards)', medium: 'Standard (32 cards)', full: 'Full (44 cards)' };
    addLog('New infiltration run ‚Äî ' + labels[selectedLength] + '.', 'system');
    dealNode(false);
  }

  // ================================================================
  //  NODE LOGIC
  // ================================================================
  function dealNode(afterBranch) {
    coverUsedThisNode = false;
    node = [];
    let toDraw = 4;

    if (carryCard) {
      node.push({ ...carryCard, played: false });
      carryCard = null;
      toDraw = 3;
    }

    for (let i = 0; i < Math.min(toDraw, deck.length); i++)
      node.push({ ...deck.pop(), played: false });

    finalNode = (deck.length === 0);

    if (!afterBranch) canBranch = true;
    updateUI();
  }

  // Final node: play everything. Normal: play all but 1 (carry the last).
  function neededCount() {
    if (finalNode || node.length <= 1) return node.length;
    return node.length - 1;
  }
  function playedCount() { return node.filter(c => c.played).length; }

  function afterCardPlayed() {
    const played = playedCount();
    const needed = neededCount();
    const remaining = node.filter(c => !c.played);

    if (played < needed) { updateUI(); return; }

    // Node complete
    if (!finalNode && remaining.length === 1) {
      carryCard = { ...remaining[0] };
      addLog('Carry forward: ' + cardDesc(carryCard) + '.', 'info');
    }

    updateUI();

    if (finalNode) {
      setTimeout(() => showEndgame(true), 650);
    } else {
      setTimeout(() => dealNode(false), 420);
    }
  }

  // ================================================================
  //  CARD INTERACTIONS
  // ================================================================
  function clickCard(idx) {
    const c = node[idx];
    if (!c || c.played) return;

    if (c.type === 'cover') applyCover(idx);
    else if (c.type === 'tool') equipTool(idx);
    else engageDetection(idx);
  }

  function applyCover(idx) {
    const c = node[idx];
    c.played = true;

    if (coverUsedThisNode) {
      addLog('Cover ignored: ' + cardDesc(c) + ' (already applied cover this node).', 'info');
    } else {
      coverUsedThisNode = true;
      const before = runner.exposure;
      runner.exposure = Math.max(0, runner.exposure - c.value);
      const reduced = before - runner.exposure;
      addLog('Applied cover ' + cardDesc(c) + ': -' + reduced + ' exposure. (' + runner.exposure + '/' + runner.maxExposure + ')', 'cover');
    }

    afterCardPlayed();
  }

  function equipTool(idx) {
    const c = node[idx];
    if (tool) {
      addLog('Swapped tool ' + valStr(tool.value) + tool.suit + ' ‚Üí ' + cardDesc(c) + '.', 'tool');
    } else {
      addLog('Equipped tool ' + cardDesc(c) + '.', 'tool');
    }
    tool = { suit: c.suit, value: c.value, maxDetectionValue: Infinity };
    c.played = true;
    afterCardPlayed();
  }

  function toolCanMitigate(detectionVal) {
    return tool !== null && detectionVal < tool.maxDetectionValue;
  }

  function engageDetection(idx) {
    const c = node[idx];
    pendingDetection = c;
    pendingDetectionIdx = idx;

    addLog('Engaged ' + cardDesc(c) + ' detection.', 'info');

    const canUse = toolCanMitigate(c.value);
    const toolExp = canUse ? Math.max(0, c.value - tool.value) : null;

    if (canUse) {
      const afterCap = c.value;
      const expStr = toolExp === 0
        ? '<strong>+0 exposure</strong> (fully mitigated)'
        : '<strong>+' + toolExp + ' exposure</strong>';

      const signatureStr = afterCap <= 2
        ? 'After this, the tool is effectively burned (no detections ranked &lt; ' + afterCap + ').'
        : 'After use: tool signature rises ‚Äî mitigates rank &lt; ' + afterCap + ' only.';

      document.getElementById('modal-title').textContent =
        'Detection ‚Äî ' + cardDesc(c) + ' (rank ' + c.value + ')';

      document.getElementById('modal-desc').innerHTML =
        'Manual bypass: <strong>+' + c.value + ' exposure</strong> <em style="font-size:0.9em;color:rgba(184,184,184,0.8)">(tool preserved)</em><br>' +
        valStr(tool.value) + tool.suit + ': ' + expStr +
        '<span class="degrade-note">' + signatureStr + '</span>';

      document.getElementById('challenge-modal').classList.remove('hidden');
    } else {
      if (tool) {
        const cap = tool.maxDetectionValue === Infinity ? 'any rank' : 'rank < ' + tool.maxDetectionValue;
        addLog('Tool ' + valStr(tool.value) + tool.suit + ' cannot mitigate rank ' + c.value + ' (' + cap + '). Manual bypass.', 'info');
      }
      resolveEngagement(false);
    }
  }

  function resolveWithTool() {
    document.getElementById('challenge-modal').classList.add('hidden');
    resolveEngagement(true);
  }
  function resolveManual() {
    document.getElementById('challenge-modal').classList.add('hidden');
    resolveEngagement(false);
  }

  function resolveEngagement(useTool) {
    const c = pendingDetection;
    const idx = pendingDetectionIdx;

    let inc = c.value; // manual bypass = full exposure

    if (useTool && tool) {
      inc = Math.max(0, c.value - tool.value);
      const oldCap = tool.maxDetectionValue === Infinity ? 'any' : '< ' + tool.maxDetectionValue;
      tool.maxDetectionValue = c.value;

      runner.exposure += inc;

      addLog(
        'Mitigated ' + cardDesc(c) + ' with ' + valStr(tool.value) + tool.suit + ': +' + inc + ' exposure. ' +
        '(tool was ' + oldCap + ', now < ' + c.value + ') ' +
        '(' + runner.exposure + '/' + runner.maxExposure + ')',
        'exposure'
      );
    } else {
      runner.exposure += inc;
      addLog(
        'Bypassed ' + cardDesc(c) + ' manually: +' + inc + ' exposure. (' + runner.exposure + '/' + runner.maxExposure + ')',
        'exposure'
      );
    }

    node[idx].played = true;

    if (runner.exposure >= runner.maxExposure) {
      runner.exposure = runner.maxExposure;
      updateUI();
      setTimeout(() => showEndgame(false), 650);
      return;
    }

    afterCardPlayed();
  }

  // ================================================================
  //  CHANGE BRANCH (FLEE)
  // ================================================================
  function changeBranch() {
    if (!canBranch) { addLog('Cannot change branch two nodes in a row.', 'info'); return; }

    const allCards = node.map(c => { const { played, ...bare } = c; return bare; });
    deck.unshift(...allCards);

    addLog('Changed branch ‚Äî ' + allCards.length + ' card(s) moved to bottom of deck. (' + deck.length + ' remain)', 'branch');

    canBranch = false;
    carryCard = null;
    node = [];
    dealNode(true);
  }

  // ================================================================
  //  UI
  // ================================================================
  function updateUI() {
    // Exposure bar (fills up as exposure rises)
    const pct = Math.max(0, Math.min(1, runner.exposure / runner.maxExposure)) * 100;
    const bar = document.getElementById('exp-bar');
    bar.style.width = pct + '%';
    bar.style.background = pct < 35
      ? 'linear-gradient(90deg, rgba(94,140,97,0.95), rgba(94,140,97,0.65))'
      : pct < 70
      ? 'linear-gradient(90deg, rgba(212,175,55,0.95), rgba(212,175,55,0.65))'
      : 'linear-gradient(90deg, rgba(168,50,50,0.95), rgba(168,50,50,0.65))';

    document.getElementById('exp-text').textContent = runner.exposure + ' / ' + runner.maxExposure;

    // Tool
    const tv = document.getElementById('tool-val');
    const tc = document.getElementById('tool-cap');

    if (tool) {
      tv.className = 'tool-val';
      tv.textContent = valStr(tool.value) + tool.suit;

      if (tool.maxDetectionValue === Infinity) {
        tc.textContent = 'mitigates any rank';
        tc.style.color = '';
      } else if (tool.maxDetectionValue <= 2) {
        tc.textContent = 'burned (fully flagged)';
        tc.style.color = 'rgba(168,50,50,0.95)';
      } else {
        tc.textContent = 'mitigates rank < ' + tool.maxDetectionValue;
        tc.style.color = '';
      }
    } else {
      tv.className = 'tool-val none';
      tv.textContent = 'None';
      tc.textContent = '';
      tc.style.color = '';
    }

    // Deck count
    document.getElementById('deck-count').textContent = deck.length;

    // Change branch button
    document.getElementById('branch-btn').disabled = !canBranch;

    // Cover banner: show if cover used AND unused cover remains
    const unusedCover = node.filter(c => !c.played && c.type === 'cover').length;
    document.getElementById('cover-banner')
      .classList.toggle('visible', coverUsedThisNode && unusedCover > 0);

    // Progress label
    const played = playedCount();
    const needed = neededCount();
    document.getElementById('progress-label').textContent =
      played + ' / ' + needed + ' played' + (finalNode ? ' (final node)' : '');

    renderNode();
  }

  function renderNode() {
    const el = document.getElementById('node');
    el.innerHTML = '';

    const played = playedCount();
    const needed = neededCount();

    node.forEach((c, idx) => {
      const isRed = (c.suit === '\u2665' || c.suit === '\u2666');
      const v = valStr(c.value);
      const isDanger = !c.played && c.type === 'detection' && c.value >= 10;
      const isLocked = !c.played && c.type === 'detection' && tool && !toolCanMitigate(c.value);
      const isSpent = !c.played && c.type === 'cover' && coverUsedThisNode;

      let subText = '', subClass = '';

      if (!c.played) {
        if (c.type === 'detection') {
          if (tool && toolCanMitigate(c.value)) {
            const inc = Math.max(0, c.value - tool.value);
            if (inc === 0) { subText = '+0 EXP'; subClass = 'exposure-reduced'; }
            else { subText = '+' + inc + ' EXP'; subClass = 'exposure-reduced'; }
          } else if (isLocked) {
            subText = '+' + c.value + ' EXP'; subClass = 'exposure-locked';
          } else {
            subText = '+' + c.value + ' EXP'; subClass = 'exposure-full';
          }
        } else if (isSpent) {
          subText = 'no effect'; subClass = 'no-cover';
        }
      }

      if (isLocked && subText) subText = 'üîí ' + subText;

      const typeLabel = { detection: 'Detection', cover: 'Cover', tool: 'Tool' }[c.type];

      const cls = [
        'card',
        c.type,
        isLocked ? 'tool-locked' : '',
        isSpent ? 'cover-spent' : '',
        isRed ? 'red-suit' : 'black-suit',
        (isDanger && !c.played) ? 'danger' : '',
        c.played ? 'played' : '',
        (!c.played && played >= needed) ? 'no-interact' : ''
      ].filter(Boolean).join(' ');

      const div = document.createElement('div');
      div.className = cls;

      div.innerHTML =
        '<div class="corner tl"><span class="cv">' + v + '</span><span class="cs">' + c.suit + '</span></div>' +
        '<div class="card-center">' +
          '<div class="big-suit">' + c.suit + '</div>' +
          '<div class="big-val">' + v + '</div>' +
          '<div class="card-type-tag">' + typeLabel + '</div>' +
          (subText ? '<div class="card-sub ' + subClass + '">' + subText + '</div>' : '') +
        '</div>' +
        '<div class="corner br"><span class="cv">' + v + '</span><span class="cs">' + c.suit + '</span></div>';

      if (!c.played && played < needed) {
        div.onclick = () => clickCard(idx);
        div.title =
          c.type === 'detection' ? 'Engage detection'
          : c.type === 'cover' ? (isSpent ? 'Discard cover (no effect)' : 'Apply cover')
          : 'Equip tool';
      }

      el.appendChild(div);
    });
  }

  function addLog(msg, cls) {
    const log = document.getElementById('log');
    const d = document.createElement('div');
    d.className = 'log-entry' + (cls ? ' ' + cls : '');
    d.textContent = msg;
    log.appendChild(d);
    log.scrollTop = log.scrollHeight;
  }

  function showEndgame(win) {
    endgameMode = win ? 'win' : 'dead';

    const el        = document.getElementById('endgame');
    const titleEl   = document.getElementById('eg-title');
    const msgEl     = document.getElementById('eg-msg');
    const actionBtn = document.getElementById('eg-action-btn');
    const lootBox   = document.getElementById('loot-box');
    const lootItems = document.getElementById('loot-items');

    el.className = 'endgame ' + (win ? 'win' : 'dead');

    if (win) {
      titleEl.textContent = 'SUCCESS';
      msgEl.innerHTML = 'Trace cleared.<br><strong>The Pit holds no record.</strong>';

      rewardChoices = buildPlaceholderRewards();
      lootItems.innerHTML = '';
      lootBox.classList.remove('hidden');
      renderRewardChoices();

      actionBtn.textContent = 'Claim Reward';
      actionBtn.disabled = true;
    } else {
      titleEl.textContent = 'TRACE BREACHED';
      msgEl.innerHTML =
        'Exposure hit <strong>' + runner.maxExposure + '</strong>.<br>' +
        'The node chain is sealed ‚Äî start a new run.';

      lootBox.classList.add('hidden');
      lootItems.innerHTML = '';

      actionBtn.textContent = 'New Run';
      actionBtn.disabled = false;
    }

    el.classList.remove('hidden');
  }

  function toggleRules() {
    document.getElementById('rules-panel').classList.toggle('open');
  }

  // ================================================================
  //  START
  // ================================================================
  initGame();
</script>
</body>
</html>
