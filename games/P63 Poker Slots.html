<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Project 63 — Poker Slot (Player Screen)</title>

  <!-- Match MVP typography -->
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    /* ------------------------------------------------------------
      P63 MVP THEME (aligned with p63_0.47.html)
      ------------------------------------------------------------ */
    :root {
      --bg-primary: #0f0f0f;
      --bg-secondary: #1a1a1a;
      --bg-card: #262626;
      --bg-hover: #2c2c2c;

      --text-primary: #f5f5f5;
      --text-secondary: #b8b8b8;
      --text-muted: #737373;

      --accent-gold: #d4af37;
      --accent-gold-dim: #8a6f1f;
      --accent-red: #a83232;
      --accent-green: #5e8c61;
      --accent-blue: #5f7d95;
      --accent-purple: #7d6a82;

      --border-color: #404040;

      --card-red: #b13b3b;
      --card-black: #111111;

      --font-display: 'Bebas Neue', sans-serif;
      --font-mono: 'Space Mono', monospace;
      --font-body: 'Inter', sans-serif;

      --wash-gold: rgba(212, 175, 55, 0.14);
      --wash-red: rgba(168, 50, 50, 0.18);
      --wash-green: rgba(94, 140, 97, 0.18);
      --wash-blue: rgba(95, 125, 149, 0.16);
      --wash-purple: rgba(125, 106, 130, 0.16);

      --noir-bg-primary: #0f1119;
      --noir-bg-secondary: #141820;

      --panel: rgba(255,255,255,0.03);
      --panel-border: rgba(148,163,184,0.18);
      --panel-border-strong: rgba(148,163,184,0.26);

      --shadow: 0 18px 40px rgba(0,0,0,0.60);
      --radius: 16px;
    }

    *{ box-sizing: border-box; margin: 0; padding: 0; }

    body{
      font-family: var(--font-body);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 18px 14px 28px;
      background:
        radial-gradient(ellipse at 50% -10%, rgba(212,175,55,0.18), rgba(15,17,25,0.0) 55%),
        radial-gradient(ellipse at 40% 115%, rgba(95,125,149,0.18), rgba(15,17,25,0.0) 55%),
        linear-gradient(180deg, var(--noir-bg-primary), var(--bg-primary));
      -webkit-tap-highlight-color: transparent;
      overflow-x: hidden;
    }

    /* Vignette + faint texture (MVP-like) */
    body::after{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(ellipse at center, transparent 45%, rgba(0,0,0,0.55) 100%),
        repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 2px, transparent 6px);
      opacity: 0.35;
      mix-blend-mode: overlay;
    }

    .shell{
      width: min(980px, 100%);
      border: 1px solid var(--panel-border-strong);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
      background: linear-gradient(180deg, rgba(20,24,32,0.95), rgba(15,15,15,0.92));
      position: relative;
    }
    .shell::before{
      content:"";
      position:absolute;
      left:0; top:0; right:0;
      height:3px;
      background: linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55));
      opacity: 0.9;
    }

    /* Header */
    .top{
      padding: 18px 18px 14px;
      border-bottom: 1px solid var(--panel-border);
      background:
        radial-gradient(700px 260px at 12% 0%, rgba(212,175,55,0.14), transparent 70%),
        radial-gradient(700px 260px at 88% 0%, rgba(95,125,149,0.14), transparent 70%),
        rgba(255,255,255,0.02);
    }
    .row{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .titleWrap{ display:flex; flex-direction:column; gap:6px; }
    h1{
      margin: 0;
      font-family: var(--font-display);
      font-size: 2.2em;
      letter-spacing: 6px;
      color: var(--accent-gold);
      text-transform: uppercase;
      text-shadow: 0 0 18px rgba(212,175,55,0.22);
      line-height: 1;
    }
    .sub{
      margin: 0;
      color: var(--text-muted);
      font-size: 0.82em;
      letter-spacing: 2px;
      text-transform: uppercase;
      line-height: 1.45;
      max-width: 72ch;
    }

    /* Tabs */
    .tabs{ display:flex; gap:8px; align-items:center; }
    .tab{
      font-family: var(--font-display);
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 0.90em;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: rgba(255,255,255,0.03);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.18s;
      user-select: none;
    }
    .tab:hover{ background: rgba(212,175,55,0.06); border-color: rgba(212,175,55,0.35); }
    .tab.active{
      background: rgba(212,175,55,0.10);
      border-color: rgba(212,175,55,0.55);
      color: var(--text-primary);
      box-shadow: 0 0 0 2px rgba(212,175,55,0.08);
    }

    /* HUD */
    .hud{
      margin-top: 12px;
      display:grid;
      grid-template-columns: 1.1fr 0.9fr 1.4fr;
      gap: 10px;
    }
    @media (max-width: 820px){
      .hud{ grid-template-columns: 1fr 1fr; }
      .hud .box:nth-child(3){ grid-column: 1 / -1; }
    }

    .box{
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 10px 12px;
      background: rgba(255,255,255,0.02);
      min-height: 62px;
      display:flex;
      flex-direction: column;
      justify-content: center;
    }
    .lbl{ font-size: 0.68em; color: var(--text-muted); letter-spacing: 2px; text-transform: uppercase; margin-bottom: 6px; }
    .val{ font-family: var(--font-mono); font-size: 1.05em; color: var(--text-primary); }
    .val small{ font-size: 0.78em; color: var(--text-secondary); margin-left: 6px; }

    .heatRow{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .meter{
      flex: 1 1 auto;
      height: 13px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(0,0,0,0.35);
      overflow:hidden;
      min-width: 150px;
    }
    .fill{
      height: 100%;
      width: 0%;
      border-radius: 10px;
      transition: width 0.35s ease;
      background: linear-gradient(90deg, rgba(94,140,97,0.95), rgba(212,175,55,0.90), rgba(168,50,50,0.95));
    }

    /* Mid */
    .mid{ padding: 14px 18px 12px; }

    .status{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding: 10px 12px;
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      background: rgba(255,255,255,0.02);
    }
    .state{ font-family: var(--font-mono); font-size: 0.88em; color: var(--text-secondary); }

    .pills{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill{
      font-family: var(--font-mono);
      font-size: 0.78em;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.22);
      color: var(--text-secondary);
      white-space: nowrap;
    }

    /* Reels */
    .reels{
      margin-top: 12px;
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
    }
    @media (max-width: 780px){
      .reels{ grid-template-columns: repeat(2, 1fr); }
      /* Keep all cards the same size in portrait: center the last card but cap it to one-column width */
      .reels .reel:nth-child(5){
        grid-column: 1 / -1;
        justify-self: center;
        width: calc((100% - 10px) / 2); /* (grid width - gap) / 2 */
      }
    }

    .reel{
      position: relative;
      border-radius: 16px;
      padding: 10px;
      border: 1px solid var(--panel-border);
      background:
        radial-gradient(420px 160px at 20% 0%, rgba(212,175,55,0.10), transparent 65%),
        radial-gradient(420px 160px at 80% 100%, rgba(95,125,149,0.10), transparent 65%),
        rgba(255,255,255,0.02);
      user-select: none;
      cursor: pointer;
      transition: transform 0.16s, box-shadow 0.16s, border-color 0.16s, opacity 0.16s;
      min-height: 176px;
      display:flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 10px;
    }
    .reel:hover{ transform: translateY(-6px); box-shadow: 0 18px 36px rgba(0,0,0,0.55); border-color: rgba(212,175,55,0.35); }
    .reel.locked{ opacity: 0.82; cursor: default; transform: none; box-shadow: none; }
    .reel.held{
      border-color: rgba(212,175,55,0.70);
      box-shadow: 0 0 0 2px rgba(212,175,55,0.14), 0 18px 36px rgba(0,0,0,0.60);
    }

    .holdTag{
      font-family: var(--font-mono);
      font-size: 0.78em;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.22);
      color: var(--text-secondary);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      width: max-content;
    }
    .dot{
      width: 8px; height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,0.22);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.12);
    }
    .reel.held .dot{ background: var(--accent-gold); box-shadow: 0 0 0 1px rgba(212,175,55,0.35), 0 0 14px rgba(212,175,55,0.25); }
    .reel.held .holdTag{ color: rgba(212,175,55,0.95); border-color: rgba(212,175,55,0.30); }

    .cardFace{ flex: 1; display:flex; align-items:center; justify-content:center; }

    /* Card itself (white) */
    .card{
      width: 100%;
      aspect-ratio: 2.5 / 3.5;
      border-radius: 14px;
      background: linear-gradient(180deg, #ffffff, #f3f3f5);
      color: var(--card-black);
      box-shadow: 0 10px 18px rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.10);
      isolation: isolate;
    }

    .corner{
      position:absolute;
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      gap: 4px;
      font-weight: 800;
      font-family: var(--font-mono);
      font-size: 1.02em;
      line-height: 1;
      padding: 10px;
    }
    .corner.br{ right: 0; bottom: 0; transform: rotate(180deg); }

    .pip{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: 3.2em;
      opacity: 0.92;
      text-shadow: 0 1px 0 rgba(0,0,0,0.08);
    }

    .shine{
      position:absolute;
      inset:-40% -60%;
      background: linear-gradient(110deg, transparent 0%, rgba(255,255,255,0.55) 35%, transparent 70%);
      transform: rotate(12deg) translateX(-40%);
      opacity: 0.32;
      pointer-events:none;
      mix-blend-mode: screen;
    }

    .spin .shine{ animation: shine 700ms linear infinite; }
    @keyframes shine{ 0%{ transform: rotate(12deg) translateX(-40%); } 100%{ transform: rotate(12deg) translateX(40%); } }

    .red{ color: var(--card-red) !important; }
    .blk{ color: var(--card-black) !important; }

    /* END GAME button row (below cards) */
    .endRow{
      margin-top: 12px;
      display:flex;
      justify-content:center;
      align-items:center;
    }

    /* Bottom controls */
    .bottom{
      padding: 12px 18px 16px;
      border-top: 1px solid var(--panel-border);
      background: rgba(0,0,0,0.12);
    }

    .btnRow{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .btnGroup{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    .btn{
      font-family: var(--font-display);
      font-size: 0.92em;
      letter-spacing: 2px;
      text-transform: uppercase;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.18s;
      border: 1px solid var(--border-color);
      background: rgba(255,255,255,0.03);
      color: var(--text-primary);
    }
    .btn:hover:not(:disabled){ background: rgba(212,175,55,0.06); border-color: rgba(212,175,55,0.55); }
    .btn:disabled{ opacity: 0.40; cursor: not-allowed; }

    .btn-primary{
      background: rgba(95,125,149,0.22);
      border-color: rgba(95,125,149,0.70);
    }
    .btn-primary:hover:not(:disabled){ background: rgba(95,125,149,0.30); border-color: rgba(212,175,55,0.70); }

    .btn-warn{
      background: rgba(212,175,55,0.12);
      border-color: rgba(212,175,55,0.55);
    }
    .btn-warn:hover:not(:disabled){ background: rgba(212,175,55,0.18); }

    .btn-danger{
      background: rgba(168,50,50,0.10);
      border-color: rgba(168,50,50,0.55);
    }
    .btn-danger:hover:not(:disabled){ border-color: rgba(168,50,50,0.85); background: rgba(168,50,50,0.14); }

    .btn-ghost{ background: rgba(0,0,0,0.18); color: var(--text-secondary); }
    .btn-ghost:hover:not(:disabled){ border-color: rgba(148,163,184,0.55); background: rgba(255,255,255,0.03); }

    .help{
      margin-top: 10px;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
      color: var(--text-secondary);
      font-size: 0.86em;
      line-height: 1.35;
      align-items:center;
    }

    /* Modal */
    .modalBack{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 22px;
      z-index: 50;
      backdrop-filter: blur(3px);
    }
    .modal{
      width: min(560px, 100%);
      border-radius: 16px;
      border: 1px solid var(--panel-border-strong);
      background: linear-gradient(180deg, rgba(20,24,32,0.96), rgba(15,15,15,0.96));
      box-shadow: 0 0 60px rgba(0,0,0,0.60);
      overflow: hidden;
      position: relative;
    }
    .modal::before{
      content:"";
      position:absolute;
      left:0; top:0; right:0;
      height:3px;
      background: linear-gradient(90deg, rgba(212,175,55,0.75), rgba(95,125,149,0.55));
    }
    .modalHead{
      padding: 14px 14px 10px;
      border-bottom: 1px solid var(--panel-border);
      display:flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    .modalHead h2{
      margin: 0;
      font-family: var(--font-display);
      color: var(--accent-gold);
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 1.25em;
    }
    .modalBody{ padding: 12px 14px 14px; }

    table{
      width: 100%;
      border-collapse: collapse;
      font-family: var(--font-mono);
      font-size: 0.86em;
      color: var(--text-secondary);
    }
    th, td{ border-bottom: 1px solid rgba(148,163,184,0.18); padding: 8px 8px; text-align: left; }
    th{ color: var(--text-muted); text-transform: uppercase; letter-spacing: 2px; font-size: 0.78em; }
    .right{ text-align:right; }

    /* Tune tab */
    .tuneWrap{ display:none; padding: 14px 18px 18px; }
    .tGrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 820px){ .tGrid{ grid-template-columns: 1fr; } }

    .tCard{
      border: 1px solid var(--panel-border);
      border-radius: 14px;
      padding: 12px;
      background: rgba(255,255,255,0.02);
    }
    .tTitle{
      font-family: var(--font-display);
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--accent-gold);
      font-size: 1.05em;
      margin-bottom: 10px;
    }

    label{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      align-items:center;
      font-family: var(--font-mono);
      font-size: 0.86em;
      color: var(--text-secondary);
      margin: 8px 0;
    }
    input{
      width: 140px;
      padding: 8px 9px;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.25);
      background: rgba(0,0,0,0.25);
      color: var(--text-primary);
      font-family: var(--font-mono);
      outline: none;
    }
    .tActions{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .hint{ color: var(--text-secondary); font-size: 0.86em; line-height: 1.45; margin-top: 8px; }

  </style>
</head>
<body>

  <div class="shell">
    <div class="top">
      <div class="row">
        <div class="titleWrap">
          <h1>Poker Slot</h1>
          <p class="sub">Hold cards. Spin for free rerolls. Bank, or overclock once the freebies run out.</p>
        </div>
        <div class="tabs">
          <div class="tab active" id="tabPlay">Play</div>
          <div class="tab" id="tabTune">Tune</div>
        </div>
      </div>

      <!-- PLAYER HUD (only what player sees) -->
      <div class="hud" id="playHud">
        <div class="box">
          <div class="lbl">Chips</div>
          <div class="val"><span id="credits">100</span> <small>in machine</small></div>
        </div>
        <div class="box">
          <div class="lbl">Spins</div>
          <div class="val"><span id="spinsLeft">—</span> <small>free</small></div>
        </div>
        <div class="box">
          <div class="lbl">Heat</div>
          <div class="heatRow">
            <div class="val"><span id="heatPct">0</span><small>%</small></div>
            <div class="meter" title="Burn chance increases with heat. Burnout resets heat to 0.">
              <div class="fill" id="heatFill"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- PLAY TAB -->
    <div id="playTab">
      <div class="mid">
        <div class="status">
          <div class="state" id="stateText">Ready.</div>
          <div class="pills">
            <span class="pill" id="handPill">Hand: —</span>
            <span class="pill" id="payoutPill">Payout: —</span>
            <span class="pill" id="burnPill">Burn: —</span>
          </div>
        </div>

        <div class="reels" id="reels"></div>

        <!-- Exit action requested: button below cards -->
        <div class="endRow">
          <button class="btn btn-ghost" id="btnEndGame">End Game</button>
        </div>
      </div>

      <div class="bottom">
        <div class="btnRow">
          <div class="btnGroup" id="leftButtons"></div>
          <div class="btnGroup" id="rightButtons">
            <button class="btn btn-ghost" id="btnPaytable">Paytable</button>
          </div>
        </div>

        <div class="help">
          <div>
            <span class="pill" id="pillAnte">Next hand: −25</span>
            <span class="pill" id="pillHeatRule">Heat +10% on safe overclock</span>
          </div>
        </div>
      </div>
    </div>

    <!-- TUNE TAB (dev only) -->
    <div class="tuneWrap" id="tuneTab">
      <div class="tGrid">
        <div class="tCard">
          <div class="tTitle">Session</div>
          <label>Start chips <input id="inStartChips" type="number" min="0" step="1" value="100"></label>
          <label>Ante <input id="inAnte" type="number" min="1" step="1" value="25"></label>
          <label>Free spins <input id="inFreeSpins" type="number" min="0" step="1" value="2"></label>
          <div class="tActions">
            <button class="btn btn-primary" id="btnApply">Apply</button>
            <button class="btn btn-ghost" id="btnReset">Reset Run</button>
          </div>
          <div class="hint">
            This tab is for tuning only. The Play tab shows the player-facing screen.
          </div>
        </div>

        <div class="tCard">
          <div class="tTitle">Overclock</div>
          <label>Base burn (%) <input id="inBaseBurn" type="number" min="0" max="95" step="1" value="15"></label>
          <label>Heat step (%) <input id="inHeatStep" type="number" min="0" max="95" step="1" value="10"></label>
          <div class="hint">
            Overclock burn <b>only wipes the current hand’s winnings</b>. Your existing chips remain safe.
          </div>
        </div>

        <div class="tCard" style="grid-column:1/-1">
          <div class="tTitle">Paytable (mult × ante)</div>
          <div class="hint" style="margin-top:0">
            Royal 20×, Straight Flush 10×, 4K 8×, FH 6×, Flush 5×, Straight 4×, Trips 3×, 2P 2×, Pair 1×.
          </div>
          <div class="hint">
            (Hands are fully evaluated: Royal / Straight Flush / Four / Full House / Flush / Straight / Trips / Two Pair / Pair / High.)
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Paytable modal -->
  <div class="modalBack" id="modalBack">
    <div class="modal" role="dialog" aria-modal="true" aria-label="Paytable">
      <div class="modalHead">
        <h2>Paytable</h2>
        <button class="btn btn-ghost" id="btnCloseModal">Close</button>
      </div>
      <div class="modalBody">
        <table>
          <thead>
            <tr><th>Hand</th><th class="right">Mult</th><th class="right">Pays</th></tr>
          </thead>
          <tbody id="paytableBody"></tbody>
        </table>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------------- Runtime settings (tunable in TUNE tab) ----------------
  let CFG = {
    startChips: 100,
    ante: 25,
    freeSpins: 2,
    baseBurn: 15,   // %
    heatStep: 10,   // %
  };

  // Updated payout table (as provided)
  const PAYTABLE = [
    {key:"Royal Flush", mult:20},
    {key:"Straight Flush", mult:10},
    {key:"Four of a Kind", mult:8},
    {key:"Full House", mult:6},
    {key:"Flush", mult:5},
    {key:"Straight", mult:4},
    {key:"Three of a Kind", mult:3},
    {key:"Two Pair", mult:2},
    {key:"One Pair", mult:1},
    {key:"No Win", mult:0},
  ];

  // ---------------- RNG ----------------
  const rng = () => Math.random();
  const rint = (n) => Math.floor(rng() * n);
  const clamp = (n,a,b)=>Math.max(a, Math.min(b,n));

  // ---------------- Cards / Deck ----------------
  const SUITS = [
    {k:'S', sym:'\u2660', color:'blk'},
    {k:'H', sym:'\u2665', color:'red'},
    {k:'D', sym:'\u2666', color:'red'},
    {k:'C', sym:'\u2663', color:'blk'},
  ];
  const RANKS = [
    {k:'2', v:2},{k:'3', v:3},{k:'4', v:4},{k:'5', v:5},{k:'6', v:6},{k:'7', v:7},
    {k:'8', v:8},{k:'9', v:9},{k:'10', v:10},{k:'J', v:11},{k:'Q', v:12},{k:'K', v:13},{k:'A', v:14}
  ];

  function buildDeck(){
    const deck = [];
    for (const s of SUITS){
      for (const r of RANKS){
        deck.push({ id: r.k + s.k, rank:r.k, rv:r.v, suit:s.k, sym:s.sym, color:s.color });
      }
    }
    return deck;
  }
  function shuffle(arr){
    for (let i=arr.length-1;i>0;i--){
      const j = rint(i+1);
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
    return arr;
  }

  // ---------------- Hand evaluation (all standard hands) ----------------
  function isStraight(uniq){
    if (uniq.length !== 5) return {ok:false, high:0};
    // wheel A-2-3-4-5
    const wheel = [2,3,4,5,14];
    const isWheel = wheel.every(v=>uniq.includes(v));
    if (isWheel) return {ok:true, high:5};
    const min = uniq[0], max = uniq[4];
    if (max - min === 4) return {ok:true, high:max};
    return {ok:false, high:0};
  }
  function rankToLabel(rv){
    const map = {14:'A',13:'K',12:'Q',11:'J',10:'10',9:'9',8:'8',7:'7',6:'6',5:'5',4:'4',3:'3',2:'2'};
    return map[String(rv)] || String(rv);
  }

  function evaluate(cards){
    const ranks = cards.map(c=>c.rv).sort((a,b)=>a-b);
    const suits = cards.map(c=>c.suit);
    const flush = suits.every(s=>s===suits[0]);

    const uniq = Array.from(new Set(ranks)).sort((a,b)=>a-b);
    const straight = isStraight(uniq);

    const countMap = new Map();
    for (const rv of ranks) countMap.set(rv, (countMap.get(rv)||0)+1);
    const counts = Array.from(countMap.entries())
      .map(([rv,ct])=>({rv,ct}))
      .sort((a,b)=> b.ct - a.ct || b.rv - a.rv);

    const highStraight = straight.high;
    const isRoyal = flush && straight.ok && highStraight===14 && ranks.includes(10);

    let category = "High Card";
    let detail = `High ${rankToLabel(ranks[4])}`;

    if (isRoyal){
      category = "Royal Flush"; detail = "A high";
    } else if (flush && straight.ok){
      category = "Straight Flush"; detail = `${rankToLabel(highStraight)} high`;
    } else if (counts[0].ct === 4){
      category = "Four of a Kind"; detail = `${rankToLabel(counts[0].rv)}s`;
    } else if (counts[0].ct === 3 && counts[1].ct === 2){
      category = "Full House"; detail = `${rankToLabel(counts[0].rv)}s full of ${rankToLabel(counts[1].rv)}s`;
    } else if (flush){
      category = "Flush"; detail = `${rankToLabel(ranks[4])} high`;
    } else if (straight.ok){
      category = "Straight"; detail = `${rankToLabel(highStraight)} high`;
    } else if (counts[0].ct === 3){
      category = "Three of a Kind"; detail = `${rankToLabel(counts[0].rv)}s`;
    } else if (counts[0].ct === 2 && counts[1].ct === 2){
      category = "Two Pair";
      const hi = Math.max(counts[0].rv, counts[1].rv);
      const lo = Math.min(counts[0].rv, counts[1].rv);
      detail = `${rankToLabel(hi)}s and ${rankToLabel(lo)}s`;
    } else if (counts[0].ct === 2){
      category = "One Pair"; detail = `${rankToLabel(counts[0].rv)}s`;
    }

    // Map to payout row
    let payoutKey = "No Win";
    if (category === "Royal Flush") payoutKey = "Royal Flush";
    else if (category === "Straight Flush") payoutKey = "Straight Flush";
    else if (category === "Four of a Kind") payoutKey = "Four of a Kind";
    else if (category === "Full House") payoutKey = "Full House";
    else if (category === "Flush") payoutKey = "Flush";
    else if (category === "Straight") payoutKey = "Straight";
    else if (category === "Three of a Kind") payoutKey = "Three of a Kind";
    else if (category === "Two Pair") payoutKey = "Two Pair";
    else if (category === "One Pair") payoutKey = "One Pair";

    const row = PAYTABLE.find(x=>x.key===payoutKey) || {mult:0};
    const mult = row.mult || 0;
    const payout = Math.round(mult * CFG.ante);

    return {category, detail, payoutKey, mult, payout};
  }

  // ---------------- UI refs ----------------
  const $ = (id)=>document.getElementById(id);
  const els = {
    tabPlay: $("tabPlay"),
    tabTune: $("tabTune"),
    playTab: $("playTab"),
    tuneTab: $("tuneTab"),

    credits: $("credits"),
    spinsLeft: $("spinsLeft"),
    heatPct: $("heatPct"),
    heatFill: $("heatFill"),

    stateText: $("stateText"),
    handPill: $("handPill"),
    payoutPill: $("payoutPill"),
    burnPill: $("burnPill"),

    reels: $("reels"),

    leftButtons: $("leftButtons"),
    rightButtons: $("rightButtons"),

    pillAnte: $("pillAnte"),
    pillHeatRule: $("pillHeatRule"),

    btnEndGame: $("btnEndGame"),

    btnPaytable: $("btnPaytable"),
    modalBack: $("modalBack"),
    btnCloseModal: $("btnCloseModal"),
    paytableBody: $("paytableBody"),

    // Tune inputs
    inStartChips: $("inStartChips"),
    inAnte: $("inAnte"),
    inFreeSpins: $("inFreeSpins"),
    inBaseBurn: $("inBaseBurn"),
    inHeatStep: $("inHeatStep"),
    btnApply: $("btnApply"),
    btnReset: $("btnReset"),
  };

  // ---------------- State ----------------
  const SESSION = { chips: CFG.startChips, heat: 0 };

  const HAND = {
    phase: "READY",   // READY | HOLDING | RESOLVED | BURNED | SPINNING
    cards: [null,null,null,null,null],
    held: [false,false,false,false,false],
    spinsLeft: 0,
    deck: [],
    eval: null,
    lastWinnings: 0,   // winnings from THIS hand only (used for double)
    doubleAvailable: false,
    doubleUsed: false,
  };

  function burnChance(){
    return clamp(CFG.baseBurn + SESSION.heat, 0, 95);
  }

  // ---------------- Rendering ----------------
  function cardHTML(card, spinning){
    const rank = card ? card.rank : "\u2014";
    const sym = card ? card.sym : "\u2022";
    const color = card ? card.color : "blk";
    return `
      <div class="card ${spinning ? 'spin':''}">
        <div class="shine"></div>
        <div class="corner ${color}">
          <div>${rank}</div>
          <div style="font-size:1.05em">${sym}</div>
        </div>
        <div class="corner br ${color}">
          <div>${rank}</div>
          <div style="font-size:1.05em">${sym}</div>
        </div>
        <div class="pip ${color}">${sym}</div>
      </div>
    `;
  }

  function canToggleHold(){ return HAND.phase === "HOLDING"; }

  function renderReels(spinningMask){
    els.reels.innerHTML = "";
    for (let i=0;i<5;i++){
      const reel = document.createElement("div");
      const held = HAND.held[i];
      const locked = !canToggleHold();
      reel.className = "reel" + (held ? " held":"") + (locked ? " locked":"");
      reel.setAttribute("role","button");
      reel.setAttribute("tabindex","0");

      const tag = held ? "HOLD" : (locked ? "\u2014" : "TAP TO HOLD");
      reel.innerHTML = `
        <div class="holdTag"><span class="dot"></span><span>${tag}</span></div>
        <div class="cardFace">${cardHTML(HAND.cards[i], !!(spinningMask && spinningMask[i]))}</div>
      `;

      reel.addEventListener("click", ()=>toggleHold(i));
      reel.addEventListener("keydown", (e)=>{
        if (e.key==="Enter" || e.key===" "){ e.preventDefault(); toggleHold(i); }
      });

      els.reels.appendChild(reel);
    }
  }

  function setStateText(t){ els.stateText.textContent = t; }

  function updateHUD(){
    els.credits.textContent = String(SESSION.chips);
    els.spinsLeft.textContent = (HAND.phase==="HOLDING") ? String(HAND.spinsLeft) : "\u2014";

    els.heatPct.textContent = String(Math.round(SESSION.heat));
    els.heatFill.style.width = `${clamp(SESSION.heat,0,95)}%`;

    els.pillAnte.textContent = `Next hand: \u2212${CFG.ante}`;
    els.pillHeatRule.textContent = `Heat +${CFG.heatStep}% on safe overclock`;
    els.burnPill.textContent = `Burn: ${burnChance()}%`;

    // Disable global buttons during spin
    const disabledGlobal = (HAND.phase === "SPINNING");
    els.btnPaytable.disabled = disabledGlobal;
    els.btnEndGame.disabled = disabledGlobal;

    if (HAND.eval){
      els.handPill.textContent = `Hand: ${HAND.eval.category} (${HAND.eval.detail})`;
      const p = HAND.eval.payout;
      if (HAND.phase==="HOLDING"){
        els.payoutPill.textContent = `Payout: ${p>0 ? "+"+p : "0"}`;
      } else if (HAND.phase==="RESOLVED"){
        els.payoutPill.textContent = `Won: ${HAND.lastWinnings>0 ? "+"+HAND.lastWinnings : "0"}`;
      } else if (HAND.phase==="BURNED"){
        els.payoutPill.textContent = "Won: 0";
      } else {
        els.payoutPill.textContent = `Payout: ${p>0 ? "+"+p : "0"}`;
      }
    } else {
      els.handPill.textContent = "Hand: \u2014";
      els.payoutPill.textContent = "Payout: \u2014";
    }

    rebuildButtons();
  }

  function rebuildButtons(){
    els.leftButtons.innerHTML = "";

    const mk = (label, kind, onClick, disabled=false) => {
      const b = document.createElement("button");
      b.textContent = label;
      b.className = `btn ${kind}`;
      b.disabled = disabled;
      b.addEventListener("click", onClick);
      return b;
    };

    if (HAND.phase === "READY"){
      const disabled = SESSION.chips < CFG.ante;
      els.leftButtons.appendChild(mk(`Next Hand (\u2212${CFG.ante})`, "btn-primary", startHand, disabled));
      return;
    }

    if (HAND.phase === "HOLDING"){
      // Only show what is necessary:
      // - if spins left: SPIN + BANK
      // - if no spins left: BANK + OVERCLOCK
      if (HAND.spinsLeft > 0){
        els.leftButtons.appendChild(mk("Spin", "btn-primary", spinFree));
        els.leftButtons.appendChild(mk("Bank", "btn-warn", bank));
      } else {
        els.leftButtons.appendChild(mk("Bank", "btn-warn", bank));
        els.leftButtons.appendChild(mk("Overclock", "btn-danger", overclock));
      }
      return;
    }

    if (HAND.phase === "RESOLVED"){
      els.leftButtons.appendChild(mk(`Next Hand (\u2212${CFG.ante})`, "btn-primary", startHand, SESSION.chips < CFG.ante));
      if (HAND.doubleAvailable && !HAND.doubleUsed){
        els.leftButtons.appendChild(mk("Double or Nothing", "btn-warn", doubleOrNothing));
      }
      return;
    }

    if (HAND.phase === "BURNED"){
      els.leftButtons.appendChild(mk(`Next Hand (\u2212${CFG.ante})`, "btn-primary", startHand, SESSION.chips < CFG.ante));
      return;
    }
    // SPINNING: no buttons
  }

  function renderPaytable(){
    els.paytableBody.innerHTML = "";
    for (const row of PAYTABLE){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${row.key}</td><td class="right">${row.mult}\u00d7</td><td class="right">${Math.round(row.mult*CFG.ante)}</td>`;
      els.paytableBody.appendChild(tr);
    }
  }

  // ---------------- Logic ----------------
  function resetToReady(msg="Ready."){
    HAND.phase = "READY";
    HAND.cards = [null,null,null,null,null];
    HAND.held = [false,false,false,false,false];
    HAND.spinsLeft = 0;
    HAND.deck = [];
    HAND.eval = null;
    HAND.lastWinnings = 0;
    HAND.doubleAvailable = false;
    HAND.doubleUsed = false;

    renderReels([false,false,false,false,false]);
    setStateText(msg);
    updateHUD();
  }

  function toggleHold(i){
    if (!canToggleHold()) return;
    HAND.held[i] = !HAND.held[i];
    renderReels([false,false,false,false,false]);
    updateHUD();
  }

  function dealFromDeck(){ return HAND.deck.pop(); }

  function setEvaluation(){
    if (HAND.cards.some(c=>!c)){ HAND.eval = null; return; }
    HAND.eval = evaluate(HAND.cards);
  }

  function randomCardFace(){
    const s = SUITS[rint(SUITS.length)];
    const r = RANKS[rint(RANKS.length)];
    return { id: r.k + s.k, rank:r.k, rv:r.v, suit:s.k, sym:s.sym, color:s.color };
  }

  function animateSpin(spinningMask, onDone){
    HAND.phase = "SPINNING";
    setStateText("Spinning\u2026");
    renderReels(spinningMask);
    updateHUD();

    const base = 520, stagger = 110;
    let finished = 0;

    for (let i=0;i<5;i++){
      if (!spinningMask[i]){ finished++; continue; }
      const stopAt = base + i*stagger + rint(140);
      const start = performance.now();

      const t = setInterval(()=>{
        const elapsed = performance.now() - start;
        const fake = randomCardFace();
        const reels = els.reels.children;
        if (reels[i]){
          const face = reels[i].querySelector(".cardFace");
          if (face) face.innerHTML = cardHTML(fake, true);
        }
        if (elapsed >= stopAt){
          clearInterval(t);
          const reels2 = els.reels.children;
          if (reels2[i]){
            const face = reels2[i].querySelector(".cardFace");
            if (face) face.innerHTML = cardHTML(HAND.cards[i], false);
          }
          finished++;
          if (finished >= 5) setTimeout(onDone, 120);
        }
      }, 55);
    }
    if (finished >= 5) setTimeout(onDone, 80);
  }

  function startHand(){
    if (HAND.phase !== "READY" && HAND.phase !== "RESOLVED" && HAND.phase !== "BURNED") return;
    if (SESSION.chips < CFG.ante) return;

    SESSION.chips -= CFG.ante;

    HAND.deck = shuffle(buildDeck());
    HAND.held = [false,false,false,false,false];
    HAND.spinsLeft = CFG.freeSpins;
    HAND.lastWinnings = 0;
    HAND.doubleAvailable = false;
    HAND.doubleUsed = false;

    for (let i=0;i<5;i++) HAND.cards[i] = dealFromDeck();

    animateSpin([true,true,true,true,true], ()=>{
      setEvaluation();
      HAND.phase = "HOLDING";
      setStateText("Tap to hold. Spin for free rerolls, or bank your payout.");
      updateHUD();
    });
  }

  function spinFree(){
    if (HAND.phase !== "HOLDING") return;
    if (HAND.spinsLeft <= 0) return;

    const mask = [false,false,false,false,false];
    for (let i=0;i<5;i++){
      if (!HAND.held[i]){
        HAND.cards[i] = dealFromDeck();
        mask[i] = true;
      }
    }
    HAND.spinsLeft -= 1;

    animateSpin(mask, ()=>{
      setEvaluation();
      HAND.phase = "HOLDING";
      setStateText(HAND.spinsLeft > 0
        ? "Adjust holds. Spin again, or bank."
        : "No spins left. Bank now\u2026 or overclock."
      );
      updateHUD();
    });
  }

  function bank(){
    if (HAND.phase !== "HOLDING") return;
    const pay = HAND.eval ? HAND.eval.payout : 0;

    SESSION.chips += pay;
    HAND.lastWinnings = pay;
    HAND.doubleAvailable = pay > 0;
    HAND.doubleUsed = false;

    HAND.phase = "RESOLVED";
    HAND.held = [false,false,false,false,false];

    setStateText(pay > 0 ? `Banked +${pay}.` : "No win.");
    updateHUD();
  }

  function overclock(){
    if (HAND.phase !== "HOLDING") return;
    if (HAND.spinsLeft !== 0) return;

    const p = burnChance() / 100;
    const roll = rng();

    if (roll < p){
      // Burnout: Overclock must always sting.
      // If you currently have a payout showing, wipe it. Otherwise, charge a flat penalty (defaults to 25 via ante).
      const shownPay = (HAND.eval ? HAND.eval.payout : 0);
      const penalty = CFG.ante;

      SESSION.heat = 0;

      if (shownPay > 0){
        HAND.lastWinnings = 0;
        HAND.doubleAvailable = false;
        HAND.doubleUsed = true;
        HAND.phase = "BURNED";
        HAND.held = [false,false,false,false,false];
        setStateText("Burnout. Payout wiped. Heat reset.");
      } else {
        SESSION.chips = Math.max(0, SESSION.chips - penalty);
        HAND.lastWinnings = 0;
        HAND.doubleAvailable = false;
        HAND.doubleUsed = true;
        HAND.phase = "BURNED";
        HAND.held = [false,false,false,false,false];
        setStateText(`Burnout. Lost ${penalty} chips. Heat reset.`);
      }

      updateHUD();
      return;
    }

    // Safe: heat increases; one final reroll of unheld; auto-bank.
    SESSION.heat = clamp(SESSION.heat + CFG.heatStep, 0, 95);

    const mask = [false,false,false,false,false];
    for (let i=0;i<5;i++){
      if (!HAND.held[i]){
        HAND.cards[i] = dealFromDeck();
        mask[i] = true;
      }
    }

    animateSpin(mask, ()=>{
      setEvaluation();
      const pay = HAND.eval ? HAND.eval.payout : 0;
      SESSION.chips += pay;

      HAND.lastWinnings = pay;
      HAND.doubleAvailable = pay > 0;
      HAND.doubleUsed = false;

      HAND.phase = "RESOLVED";
      HAND.held = [false,false,false,false,false];

      setStateText(pay > 0 ? `Overclock banked +${pay}. Heat rose.` : "Overclock banked 0. Heat rose.");
      updateHUD();
    });
  }

  function doubleOrNothing(){
    if (HAND.phase !== "RESOLVED") return;
    if (!HAND.doubleAvailable || HAND.doubleUsed) return;

    const stake = HAND.lastWinnings;
    if (stake <= 0) return;

    HAND.doubleUsed = true;

    const win = rng() >= 0.5;
    if (win){
      SESSION.chips += stake;
      HAND.lastWinnings = stake * 2;
      setStateText(`Double win. +${HAND.lastWinnings}.`);
    } else {
      // only pulls back THIS hand\u2019s winnings
      SESSION.chips = Math.max(0, SESSION.chips - stake);
      HAND.lastWinnings = 0;
      HAND.doubleAvailable = false;
      setStateText("Double loss. Winnings erased.");
    }
    updateHUD();
  }

  // ---------------- Tabs ----------------
  function showPlay(){
    els.tabPlay.classList.add("active");
    els.tabTune.classList.remove("active");
    els.playTab.style.display = "";
    els.tuneTab.style.display = "none";
  }
  function showTune(){
    els.tabTune.classList.add("active");
    els.tabPlay.classList.remove("active");
    els.playTab.style.display = "none";
    els.tuneTab.style.display = "";
  }

  els.tabPlay.addEventListener("click", showPlay);
  els.tabTune.addEventListener("click", showTune);

  // ---------------- Modal ----------------
  function openPaytable(){ els.modalBack.style.display = "flex"; renderPaytable(); }
  function closePaytable(){ els.modalBack.style.display = "none"; }

  els.btnPaytable.addEventListener("click", openPaytable);
  els.btnCloseModal.addEventListener("click", closePaytable);
  els.modalBack.addEventListener("click", (e)=>{ if (e.target === els.modalBack) closePaytable(); });
  document.addEventListener("keydown", (e)=>{ if (e.key==="Escape") closePaytable(); });

  // ---------------- End Game (stub) ----------------
  els.btnEndGame.addEventListener("click", ()=>{
    // In the real game, this returns you to the floor with your current machine chips.
    const cashOut = SESSION.chips;
    SESSION.chips = CFG.startChips;
    SESSION.heat = 0;
    resetToReady(`Ended game. Cashed out ${cashOut}.`);
  });

  // ---------------- Tune actions ----------------
  function applyTune(){
    const startChips = Math.max(0, parseInt(els.inStartChips.value||"0",10));
    const ante = Math.max(1, parseInt(els.inAnte.value||"25",10));
    const freeSpins = Math.max(0, parseInt(els.inFreeSpins.value||"2",10));
    const baseBurn = clamp(parseInt(els.inBaseBurn.value||"15",10), 0, 95);
    const heatStep = clamp(parseInt(els.inHeatStep.value||"10",10), 0, 95);

    CFG = {
      startChips,
      ante,
      freeSpins,
      baseBurn,
      heatStep,
    };

    SESSION.chips = startChips;
    SESSION.heat = 0;

    resetToReady("Settings applied. Ready.");
    showPlay();
  }

  els.btnApply.addEventListener("click", applyTune);
  els.btnReset.addEventListener("click", ()=>{
    SESSION.chips = CFG.startChips;
    SESSION.heat = 0;
    resetToReady("Run reset. Ready.");
  });

  // ---------------- Boot ----------------
  renderReels([false,false,false,false,false]);
  setStateText("Ready.");
  updateHUD();
  showPlay();
})();
</script>
</body>
</html>
