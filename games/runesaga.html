<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>RuneSaga â€” Generations</title>
<link rel="icon" href="data:,">
<style>
@import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@400;600;700&family=Orbitron:wght@700;900&display=swap');

:root{
  /* Lithic Arcanum */
  --stone-void:#0c0c10;
  --stone-dark:#1a1a22;
  --stone-edge:#3a3a45;

  --core-glow:#ffffff;
  --arcane-violet:#a600ff;
  --arcane-amber:#ff9900;
  --arcane-cyan:#00e5ff;

  --text-muted:#8a8a9a;
  --health-red:#c92a2a;

  /* Aliases to existing vars used throughout */
  --bg0: var(--stone-void);
  --bg1: color-mix(in oklab, var(--stone-dark) 92%, black);
  --bg2: color-mix(in oklab, var(--stone-dark) 86%, black);
  --bg3: color-mix(in oklab, var(--stone-dark) 78%, black);

  --violet: var(--arcane-violet);
  --violet2: color-mix(in oklab, var(--arcane-violet) 55%, #2a0a44);

  --amber: var(--arcane-amber);
  --amber2: color-mix(in oklab, var(--arcane-amber) 55%, #2a1400);

  --cyan: var(--arcane-cyan);

  /* text */
  --txt: #cfcfe0;
  --txt2: var(--text-muted);
  --txt3: #5a5a6a;

  /* borders */
  --border: color-mix(in oklab, var(--stone-edge) 70%, black);
  --border2: color-mix(in oklab, var(--stone-edge) 55%, black);
  --border3: color-mix(in oklab, var(--stone-edge) 40%, black);

  /* reds */
  --red: var(--health-red);
  --red2: color-mix(in oklab, var(--health-red) 60%, #ff6b6b);

  /* existing aliases retained */
  --green:#40e078;
  --gold:#d4a017;
  --shield:#4878f0;
  --legacy:#d4a017;
  --salvage:#30c0a0;

  /* Responsive chrome sizing (JS keeps these in sync) */
  --header-h:44px;
  --footer-h:44px;
}

*{box-sizing:border-box;margin:0;padding:0;}
html,body{
  background-color: var(--stone-void);
  background-image:
    radial-gradient(circle at 50% 30%, var(--bg1) 0%, var(--stone-void) 72%),
    radial-gradient(circle at 18% 78%, rgba(166,0,255,.08) 0%, transparent 55%),
    radial-gradient(circle at 82% 76%, rgba(255,153,0,.06) 0%, transparent 60%),
    repeating-linear-gradient(45deg, rgba(0,0,0,0.12) 0 2px, transparent 2px 5px);
  color: var(--txt);
  font-family:'Rajdhani',sans-serif;font-size:14px;
}

body::after{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  opacity: var(--embers-opacity, .12);
  background:
    radial-gradient(circle at 10% 30%, rgba(255,153,0,.85) 0 2px, transparent 3px),
    radial-gradient(circle at 18% 70%, rgba(255,153,0,.70) 0 1.5px, transparent 3px),
    radial-gradient(circle at 35% 55%, rgba(255,153,0,.65) 0 1.7px, transparent 3px),
    radial-gradient(circle at 55% 80%, rgba(255,153,0,.70) 0 2px, transparent 3px),
    radial-gradient(circle at 80% 40%, rgba(255,153,0,.65) 0 2px, transparent 3px),
    radial-gradient(circle at 66% 18%, rgba(255,153,0,.60) 0 1.6px, transparent 3px);
  animation: emberDrift 14s linear infinite;
  mix-blend-mode: screen;
  filter: blur(.1px);
}
@keyframes emberDrift{
  from{ transform:translateY(22px) translateX(-10px); }
  to{ transform:translateY(-34px) translateX(22px); }
}
body.embers-off::after{ opacity:0 !important; }

#game{display:grid;grid-template-rows:44px 1fr 44px;height:100dvh;}
#header{
  background:var(--bg1);border-bottom:1px solid var(--border2);
  display:flex;align-items:center;gap:12px;padding:0 14px;
  position:relative;z-index:10;
}
#header::after{
  content:'';position:absolute;bottom:0;left:0;right:0;height:1px;
  background:linear-gradient(90deg,transparent,var(--violet2) 30%,var(--amber2) 70%,transparent);
}
#main{display:grid;grid-template-columns:248px 1fr 260px;overflow:hidden;}
#footer{
  background:var(--bg1);border-top:1px solid var(--border2);
  display:flex;align-items:center;gap:10px;padding:0 14px;
}

.panel{
  position:relative;
  background:
    linear-gradient(to bottom right, rgba(255,255,255,.05), rgba(0,0,0,.16)),
    linear-gradient(to bottom, var(--bg2), var(--stone-dark));
  border: 4px solid var(--stone-void);
  border-radius: 6px;
  padding: 16px;
  box-shadow:
    inset 0 0 24px rgba(0,0,0,.65),
    0 18px 28px rgba(0,0,0,.55);
  overflow:hidden;
  -webkit-overflow-scrolling:touch;
}
.panel::after{
  content:"";
  position:absolute;
  inset:3px;
  border-radius: 4px;
  pointer-events:none;
  box-shadow:
    inset 1px 1px 0 rgba(255,255,255,.05),
    inset -1px -1px 0 rgba(0,0,0,.35);
  opacity:.9;
}
.panel::before{
  content:"";
  position:absolute;
  inset:-10px;
  pointer-events:none;
  opacity:.42;
  background:
    radial-gradient(10px 14px at 12px 18px, rgba(0,0,0,.55) 40%, transparent 42%),
    radial-gradient(14px 10px at calc(100% - 18px) 22px, rgba(0,0,0,.55) 40%, transparent 42%),
    radial-gradient(12px 12px at 18px calc(100% - 16px), rgba(0,0,0,.55) 40%, transparent 42%),
    radial-gradient(10px 14px at calc(100% - 14px) calc(100% - 18px), rgba(0,0,0,.55) 40%, transparent 42%),
    repeating-linear-gradient(45deg, rgba(255,255,255,.06) 0 2px, rgba(0,0,0,.10) 2px 4px);
  mix-blend-mode: overlay;
  filter: blur(.15px);
}
@supports (clip-path: polygon(0 0)){
  body[data-edge="ragged"] .panel{
    clip-path: polygon(
      0% 2%, 6% 0%, 20% 1%, 36% 0%, 55% 1%, 72% 0%, 92% 1%, 100% 4%,
      99% 18%, 100% 35%, 99% 52%, 100% 70%, 98% 86%, 100% 100%,
      80% 99%, 64% 100%, 46% 99%, 28% 100%, 12% 99%, 0% 100%,
      1% 84%, 0% 66%, 1% 48%, 0% 30%, 1% 14%
    );
  }
}
#right-panel{border-right:none;border-left:1px solid var(--border);}
#center-panel{display:flex;flex-direction:column;overflow:hidden;border:none;padding:0;}
#center-content{flex:1;overflow-y:auto;-webkit-overflow-scrolling:touch;}
#log-wrap{
  height:170px;background:var(--bg0);border-top:1px solid var(--border);
  display:flex;flex-direction:column;
}
#log-head{
  display:flex;justify-content:space-between;align-items:center;
  padding:4px 10px;border-bottom:1px solid var(--border);
  background:var(--bg1);flex-shrink:0;
}
#combat-log{
  flex:1;overflow-y:auto;padding:5px 10px;
  font-family:'Share Tech Mono',monospace;font-size:11px;line-height:1.55;
  -webkit-overflow-scrolling:touch;
}
::-webkit-scrollbar{width:5px}
::-webkit-scrollbar-track{background:var(--bg0)}
::-webkit-scrollbar-thumb{background:var(--border2);border-radius:3px}

/* Typography */
.logo{
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:900;
  color:var(--violet);letter-spacing:2px;
}
.rune-glow-violet{
  color: var(--core-glow);
  text-shadow:
    0 0 5px var(--core-glow),
    0 0 15px rgba(166,0,255,.9),
    0 0 32px rgba(166,0,255,.65);
}
.rune-glow-amber{
  color: var(--core-glow);
  text-shadow:
    0 0 5px var(--core-glow),
    0 0 15px rgba(255,153,0,.9),
    0 0 32px rgba(255,153,0,.65);
}
@keyframes runeBreath{
  0%,100%{ opacity:.55; transform:scale(1); }
  50%{ opacity:.9; transform:scale(1.012); }
}
.rune-breath{ animation: runeBreath 8s ease-in-out infinite; }
.sec-title{
  font-size:10px;font-weight:700;letter-spacing:2px;text-transform:uppercase;
  color:var(--txt3);border-bottom:1px solid var(--border);
  padding-bottom:5px;margin:10px 0 7px;
}
.sec-title:first-child{margin-top:2px;}
.wave-num{font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;color:var(--cyan);}

/* Stats */
.srow{display:flex;justify-content:space-between;align-items:center;margin:3px 0;}
.sl{color:var(--txt2);font-size:12px;}
.sv{color:var(--txt);font-weight:700;font-size:12px;}
.sdp{color:var(--green);font-size:11px;}
.sdn{color:var(--red);font-size:11px;}

/* Bars */
.bar-wrap{margin:5px 0 2px;}
.bar{
  position:relative;
  background: var(--stone-void);
  border:2px solid color-mix(in oklab, var(--stone-dark) 90%, black);
  box-shadow: inset 0 2px 6px rgba(0,0,0,.85);
  border-radius: 6px;
  overflow:hidden;
  height:11px;
}
.bar .bar-fill{
  height:100%;
  border-radius:1px;
  transition:width .2s;
  background-image: linear-gradient(to right, rgba(166,0,255,.95), var(--core-glow));
  box-shadow: 0 0 16px rgba(166,0,255,.55);
  filter:saturate(1.2);
}
#hero-hp-bar .bar-fill, .bar-hp .bar-fill{
  background-image: linear-gradient(to right, var(--health-red), #ff6b6b);
  box-shadow: 0 0 16px rgba(201,42,42,.55);
}
.bar-shield-ovl{height:100%;position:absolute;top:0;background:rgba(72,120,240,.6);border-radius:1px;border-right:2px solid var(--shield);transition:all .2s;}
.bar-xp{height:3px;background:var(--bg3);border-radius:1px;margin-top:2px;}
.bar-xp-fill{height:100%;background:linear-gradient(90deg,var(--violet2),var(--violet));border-radius:1px;transition:width .4s;}
.bar-txt{font-size:10px;color:var(--txt3);text-align:center;margin-top:1px;font-family:'Share Tech Mono',monospace;}

@keyframes hpShake{
  0%{transform:translateX(0)}
  20%{transform:translateX(-3px)}
  40%{transform:translateX(3px)}
  60%{transform:translateX(-2px)}
  80%{transform:translateX(2px)}
  100%{transform:translateX(0)}
}
@keyframes critFlash{
  0%{filter:brightness(1)}
  35%{filter:brightness(1.85)}
  100%{filter:brightness(1)}
}
.hp-crit{ animation: hpShake .22s ease-out, critFlash .35s ease-out; }

@keyframes boomRing{
  from{ opacity:.65; transform:scale(.7); }
  to{ opacity:0; transform:scale(1.6); }
}
.bar-boom::after{
  content:"";
  position:absolute; inset:-6px;
  border:2px solid rgba(255,255,255,.30);
  box-shadow:0 0 18px rgba(255,153,0,.35);
  border-radius: 8px;
  animation: boomRing .35s ease-out;
  pointer-events:none;
}

/* Status Badges */
.sbadge{
  display:inline-flex;align-items:center;gap:2px;
  padding:1px 6px;border-radius:2px;font-size:10px;font-weight:700;margin:2px 1px;
  font-family:'Rajdhani',sans-serif;letter-spacing:.5px;cursor:default;
}
.sb-bleed{background:rgba(200,40,40,.2);color:#ff7070;border:1px solid rgba(200,40,40,.4);}
.sb-poison{background:rgba(40,180,40,.15);color:#70d870;border:1px solid rgba(40,180,40,.35);}
.sb-shield{background:rgba(72,120,240,.2);color:#78a8ff;border:1px solid rgba(72,120,240,.4);}
.sb-weak{background:rgba(180,140,30,.2);color:#e8c048;border:1px solid rgba(180,140,30,.4);}
.sb-vulnerable{background:rgba(220,100,30,.2);color:#f08840;border:1px solid rgba(220,100,30,.4);}
.sb-rage{background:rgba(220,60,20,.2);color:#ff7040;border:1px solid rgba(220,60,20,.5);}
.sb-slow{background:rgba(80,80,180,.2);color:#9090d8;border:1px solid rgba(80,80,180,.4);}
.sb-stun{background:rgba(220,200,30,.2);color:#e8d840;border:1px solid rgba(220,200,30,.4);}
.sb-tempo{background:rgba(144,80,232,.2);color:#c080ff;border:1px solid rgba(144,80,232,.4);}
.sb-marked{background:rgba(240,168,40,.18);color:#f5bf5a;border:1px solid rgba(240,168,40,.4);}
.sb-hexed{background:rgba(80,120,220,.18);color:#95b5ff;border:1px solid rgba(80,120,220,.4);}
.sb-momentum{background:rgba(180,80,240,.2);color:#d498ff;border:1px solid rgba(180,80,240,.42);}
.sb-patience{background:rgba(120,120,160,.2);color:#c4c4de;border:1px solid rgba(120,120,160,.42);}
.sb-regen{background:rgba(40,200,80,.15);color:#50e880;border:1px solid rgba(40,200,80,.35);}

/* Tags */
.tag{display:inline-block;padding:1px 7px;border-radius:2px;font-size:9px;font-weight:700;letter-spacing:1px;text-transform:uppercase;margin:1px;}
.t-Bleed{background:rgba(200,40,40,.15);color:#ff8080;border:1px solid rgba(200,40,40,.3);}
.t-Poison{background:rgba(40,180,40,.12);color:#70d870;border:1px solid rgba(40,180,40,.3);}
.t-Shield,.t-Bulwark{background:rgba(72,120,240,.15);color:#80a8ff;border:1px solid rgba(72,120,240,.3);}
.t-Crit{background:rgba(240,168,40,.15);color:var(--amber);border:1px solid rgba(240,168,40,.3);}
.t-Tempo{background:rgba(144,80,232,.15);color:#c080ff;border:1px solid rgba(144,80,232,.3);}
.t-Arcane{background:rgba(60,120,240,.15);color:#80b0ff;border:1px solid rgba(60,120,240,.3);}
.t-Thorns{background:rgba(160,160,40,.15);color:#d0d060;border:1px solid rgba(160,160,40,.3);}
.t-Execute{background:rgba(220,40,40,.15);color:#ff5050;border:1px solid rgba(220,40,40,.3);}
.t-Sustain{background:rgba(40,180,80,.12);color:#60e090;border:1px solid rgba(40,180,80,.3);}
.t-Axiom{background:rgba(200,60,255,.15);color:#e070ff;border:1px solid rgba(200,60,255,.4);}

/* Pattern trait badge */
.gtrait{
  display:inline-flex;align-items:center;gap:3px;padding:2px 8px;border-radius:3px;
  font-size:10px;font-weight:700;margin:2px;
  background:linear-gradient(135deg,rgba(60,20,80,.5),rgba(80,30,120,.4));
  border:1px solid rgba(160,80,220,.5);color:#d090ff;cursor:default;
}

/* Boon Cards */
.boon-card{
  background:linear-gradient(to bottom, var(--bg2), var(--stone-dark));border:1px solid var(--border2);border-radius:5px;padding:10px;
  box-shadow:inset 0 1px 6px rgba(0,0,0,.35);
  cursor:pointer;transition:transform .15s,border-color .15s,box-shadow .15s;position:relative;
}
.boon-card:hover{transform:translateY(-3px);}
.rc-common{border-color:#3a3a5a;}
.rc-common:hover{border-color:#6060a0;box-shadow:0 4px 16px rgba(80,80,160,.25);}
.rc-uncommon{border-color:#2a5a2a;}
.rc-uncommon:hover{border-color:#50a050;box-shadow:0 4px 16px rgba(60,160,60,.25);}
.rc-rare{border-color:#2a2a7a;}
.rc-rare:hover{border-color:#4040d0;box-shadow:0 4px 20px rgba(60,80,200,.3);}
.rc-epic{border-color:#5a2a7a;}
.rc-epic:hover{border-color:#9050c0;box-shadow:0 4px 20px rgba(160,60,220,.35);}
.rc-legendary{border-color:#7a5a00;background:#13110a;}
.rc-legendary:hover{border-color:var(--gold);box-shadow:0 4px 24px rgba(212,160,23,.35);}
.rc-axiom{border-color:#7a20b0;background:#100a1a;box-shadow:0 0 12px rgba(144,40,200,.2);}
.rc-axiom:hover{border-color:#c040ff;box-shadow:0 4px 24px rgba(180,60,255,.4);}
.boon-rar{font-size:9px;font-weight:700;letter-spacing:1.5px;text-transform:uppercase;margin-bottom:4px;}
.rar-common{color:var(--txt3);}
.rar-uncommon{color:#50b050;}
.rar-rare{color:#5060d8;}
.rar-epic{color:#a040c0;}
.rar-legendary{color:var(--gold);}
.rar-axiom{color:#d050ff;}
.boon-name{font-weight:700;font-size:13px;margin-bottom:3px;}
.boon-desc{font-size:11px;color:var(--txt2);line-height:1.45;}

/* Enemy Cards */
.enemy-card{
  background:linear-gradient(to bottom, var(--bg2), var(--stone-dark));border:1px solid var(--border);border-radius:5px;padding:9px 11px;margin:5px 0;
  box-shadow:inset 0 1px 6px rgba(0,0,0,.35);
  display:flex;align-items:flex-start;gap:10px;
}
.enemy-card.ec-elite{border-color:var(--amber2);background:#141008;}
.enemy-card.ec-root-touched {
  border-color: #4a1a6a;
  background: #0e0818;
  box-shadow: 0 0 8px rgba(100, 20, 140, 0.3);
}
.eicon{width:38px;height:38px;border-radius:4px;display:flex;align-items:center;justify-content:center;font-size:22px;flex-shrink:0;}
.einfo{flex:1;min-width:0;}
/* Enemy HP bars use molten channel bars, but slightly slimmer */
.enemy-card .bar{
  height: 8px;
  border-radius: 6px;
  margin-top: 6px;
}
.enemy-card .bar-boom::after{
  inset: -5px;
  border-radius: 7px;
}
.ename{font-weight:700;font-size:13px;}
.etrait{font-size:10.5px;color:var(--txt3);margin-top:2px;font-style:italic;}
.estats{font-size:10.5px;color:var(--txt3);margin-top:1px;font-family:'Share Tech Mono',monospace;}

/* Wave trait cards */
.trait-card{
  background:linear-gradient(to bottom, var(--bg2), var(--stone-dark));border:1px solid #1a2a3a;border-left:3px solid var(--cyan);
  border-radius:4px;padding:7px 10px;margin:4px 0;display:flex;gap:8px;
}
.ticon{font-size:18px;flex-shrink:0;line-height:1;}
.tname{font-weight:700;font-size:12px;color:var(--cyan);}
.tdesc{font-size:11px;color:var(--txt2);margin-top:1px;}

/* Shop */
.shop-btn{
  background:linear-gradient(to bottom, var(--bg2), var(--stone-dark));border:1px solid var(--border2);border-radius:4px;padding:7px 8px;cursor:pointer;text-align:center;
  transition:all .12s;display:flex;flex-direction:column;gap:2px;
}
.shop-btn:hover:not(.sb-disabled){border-color:var(--amber);background:#1a1508;}
.sb-disabled{opacity:.4;cursor:not-allowed;}
.sb-name{font-weight:700;font-size:12px;}
.sb-cost{font-size:11px;color:var(--gold);font-family:'Share Tech Mono',monospace;}
.sb-desc{font-size:9.5px;color:var(--txt3);}

/* Buttons */
.btn{
  appearance:none;
  border:2px solid var(--stone-edge);
  background: linear-gradient(to bottom, var(--bg2), var(--stone-dark));
  color: var(--txt2);
  font-family: 'Orbitron', sans-serif;
  letter-spacing: 1px;
  text-transform: uppercase;
  font-size: 12px;
  padding: 10px 12px;
  border-radius: 6px;
  cursor:pointer;
  transform: translateY(0);
  box-shadow:
    0 4px 0 var(--stone-void),
    0 10px 18px rgba(0,0,0,.45);
  transition: transform .08s ease, box-shadow .08s ease, border-color .12s ease, color .12s ease, text-shadow .12s ease;
  user-select:none;
}
.btn:hover{
  color: var(--core-glow);
  border-color: rgba(166,0,255,.95);
  text-shadow: 0 0 10px rgba(166,0,255,.85);
  box-shadow:
    0 4px 0 var(--stone-void),
    0 0 22px rgba(166,0,255,.45),
    0 10px 18px rgba(0,0,0,.45);
}
.btn:active{
  transform: translateY(3px);
  box-shadow:
    0 1px 0 var(--stone-void),
    inset 0 2px 6px rgba(0,0,0,.65);
}
.btn-primary{background:linear-gradient(to bottom, var(--bg2), var(--stone-dark));color:var(--txt);}
.btn-amber{
  border-color: rgba(255,153,0,.9);
}
.btn-amber:hover{
  border-color: rgba(255,153,0,.01);
  text-shadow: 0 0 12px rgba(255,153,0,.9);
  box-shadow:
    0 4px 0 var(--stone-void),
    0 0 26px rgba(255,153,0,.45),
    0 10px 18px rgba(0,0,0,.45);
}
.btn-danger{
  border-color: color-mix(in oklab, var(--health-red) 75%, black);
}
.btn-danger:hover{
  border-color: var(--health-red);
  text-shadow: 0 0 10px rgba(201,42,42,.65);
  box-shadow:
    0 4px 0 var(--stone-void),
    0 0 22px rgba(201,42,42,.35),
    0 10px 18px rgba(0,0,0,.45);
}
.btn-green{border-color:rgba(64,224,120,.65);}
.btn-gold{border-color:rgba(255,153,0,.9);}
.btn-salvage{border-color:var(--salvage);color:var(--salvage);}
.btn-sm{padding:4px 10px;font-size:11px;}
.btn-ghost{background:var(--bg2);border:1px solid var(--border2);color:var(--txt2);}


/* Log colors */
.lhit{color:var(--txt);}
.lcrit{color:var(--amber);font-weight:700;}
.lmiss{color:var(--txt3);font-style:italic;}
.ldeath{color:var(--red);font-weight:700;}
.lstatus{color:#a070d8;}
.lheal{color:var(--green);}
.lshield{color:#78a8ff;}
.laxiom{color:#e070ff;font-style:italic;}
.lwave{color:var(--cyan);font-weight:700;display:block;background:rgba(48,208,192,.05);padding:2px 4px;margin:3px 0;border-radius:2px;}

/* Diff pips */
.diff-pip{width:10px;height:10px;border-radius:1px;background:var(--bg3);border:1px solid var(--border2);}
.diff-pip.dp-on{background:var(--red);border-color:var(--red);box-shadow:0 0 4px rgba(224,64,64,.5);}

/* Inventory items */
.inv-item{width:26px;height:26px;border-radius:3px;display:flex;align-items:center;justify-content:center;font-size:13px;cursor:default;border:1px solid;}
.ii-common{border-color:#3a3a5a;background:var(--bg2);}
.ii-uncommon{border-color:#2a5a2a;background:#091209;}
.ii-rare{border-color:#2a2a6a;background:#090920;}
.ii-epic{border-color:#5a2a7a;background:#12091a;}
.ii-legendary{border-color:var(--gold);background:#13110a;}
.ii-axiom{border-color:#9020c0;background:#0f0818;box-shadow:0 0 6px rgba(160,40,200,.3);}

/* Retire banner */
.retire-banner{background:linear-gradient(135deg,#0a0a18,#12081e);border:1px solid var(--gold);border-radius:6px;padding:14px;margin:10px 0;}
.retire-banner-title{font-family:'Orbitron',sans-serif;font-size:13px;color:var(--gold);font-weight:700;margin-bottom:4px;letter-spacing:1px;}

/* â”€â”€ LEGACY SCREEN â”€â”€ */
#legacy-screen{
  position:fixed;inset:0;background:var(--bg0);z-index:100;display:none;flex-direction:column;
  background-image:radial-gradient(ellipse at 30% 40%,rgba(212,160,23,.06) 0%,transparent 50%);
}
#legacy-header{
  background:var(--bg1);border-bottom:1px solid var(--border2);
  display:flex;align-items:center;gap:16px;padding:0 16px;height:48px;flex-shrink:0;position:relative;
}
#legacy-header::after{
  content:'';position:absolute;bottom:0;left:0;right:0;height:1px;
  background:linear-gradient(90deg,transparent,var(--gold) 50%,transparent);
}
.legacy-tabs{display:flex;gap:4px;}
.ltab{
  padding:6px 14px;border-radius:3px;cursor:pointer;font-weight:700;font-size:12px;letter-spacing:.5px;
  transition:all .15s;color:var(--txt3);border:1px solid transparent;
}
.ltab:hover{color:var(--txt2);background:var(--bg2);}
.ltab.active{color:var(--gold);border-color:rgba(212,160,23,.3);background:rgba(212,160,23,.08);}
#legacy-body{flex:1;overflow:hidden;display:flex;flex-direction:column;}
#legacy-content{flex:1;overflow-y:auto;padding:20px;-webkit-overflow-scrolling:touch;}

/* Hero cards in legacy */
.hero-card{
  background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:12px;cursor:pointer;
  transition:all .15s;position:relative;
}
.hero-card:hover{border-color:var(--border3);transform:translateY(-2px);}
.hero-card.hc-dead{opacity:.6;border-color:rgba(200,40,40,.3);}
.hero-card.hc-parent-a{border-color:#4878f0;box-shadow:0 0 10px rgba(72,120,240,.25);}
.hero-card.hc-parent-b{border-color:var(--violet);box-shadow:0 0 10px rgba(144,80,232,.25);}
.hc-gen{font-size:9px;font-weight:700;letter-spacing:2px;color:var(--txt3);text-transform:uppercase;}
.hc-name{font-weight:700;font-size:14px;margin:3px 0;}
.hc-stats{font-size:10.5px;color:var(--txt3);font-family:'Share Tech Mono',monospace;}

/* EV bars */
.ev-bar{height:4px;background:var(--bg3);border-radius:2px;margin-top:2px;overflow:hidden;}
.ev-fill{height:100%;border-radius:2px;transition:width .4s;}

/* Family tree nodes */
.tree-node{
  background:var(--bg2);border:1px solid var(--border2);border-radius:5px;padding:8px 10px;
  position:absolute;cursor:pointer;transition:all .15s;min-width:100px;text-align:center;
}
.tree-node:hover{border-color:var(--border3);z-index:5;}
.tree-node.tn-retired{border-color:rgba(212,160,23,.4);}
.tree-node.tn-spent{border-color:rgba(120,120,160,.35);opacity:.85;}
.tree-node.tn-dead{border-color:rgba(200,40,40,.3);opacity:.7;}
.tree-node.tn-selected{border-color:var(--gold);box-shadow:0 0 12px rgba(212,160,23,.3);z-index:6;}
.tree-badge{position:absolute;top:6px;right:8px;font-size:10px;padding:2px 6px;border-radius:999px;background:rgba(200,40,40,.12);border:1px solid rgba(200,40,40,.35);color:var(--red);}

/* Memory Binding preview */
.child-preview{background:linear-gradient(135deg,#0a0820,#120a30);border:1px solid rgba(144,80,232,.4);border-radius:6px;padding:14px;}

/* Echo Binding card */
.imprint-card{background:var(--bg2);border:1px solid rgba(200,60,255,.3);border-radius:5px;padding:10px;cursor:pointer;transition:all .15s;margin:5px 0;}
.imprint-card:hover{border-color:rgba(200,60,255,.6);background:#120a1e;transform:translateY(-2px);}

/* Animations */
@keyframes pulse2{0%,100%{opacity:1}50%{opacity:.5}}
.pulse{animation:pulse2 1.2s infinite;}
@keyframes slideIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}
.slide-in{animation:slideIn .25s ease;}

/* Overlay */
#overlay{position:fixed;inset:0;background:rgba(4,4,10,.95);display:flex;align-items:center;justify-content:center;z-index:200;}
.ov-box{
  background:var(--bg1);border:1px solid var(--border2);border-radius:8px;padding:32px;max-width:480px;width:92%;text-align:center;
}
.ov-box::before{
  content:'';display:block;height:2px;
  background:linear-gradient(90deg,transparent,var(--violet),var(--amber),transparent);
  margin-bottom:24px;border-radius:1px;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   RESPONSIVE LAYOUT + DRAWERS
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#main{
  grid-template-columns: clamp(210px, 22vw, 280px) 1fr clamp(220px, 24vw, 320px);
}
.mobile-only{display:none;}
.hero-toggle{}
.diff-wrap{
  display:flex;align-items:center;gap:6px;
  padding:4px 8px;border:1px solid var(--border2);
  border-radius:3px;background:var(--bg2);
  color:var(--txt2);
}
.diff-wrap .diff-label{font-size:10px;letter-spacing:1px;text-transform:uppercase;color:var(--txt3);font-weight:700;}
.diff-wrap input[type="range"]{width:120px;accent-color:var(--amber);}
.diff-wrap .diff-val{font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--gold);min-width:48px;text-align:right;}

#drawer-backdrop{
  display:none;
  position:fixed;inset:0;
  background:rgba(0,0,0,.55);
  z-index:45;
}
@media (max-width: 980px){
  #main{grid-template-columns:1fr;}
  .mobile-only{display:inline-flex;}
  #hero-panel, #right-panel{
    position:fixed;
    top:calc(var(--header-h) + env(safe-area-inset-top));
    bottom:calc(var(--footer-h) + env(safe-area-inset-bottom));
    width:min(88vw, 360px);
    z-index:50;
    background:var(--bg1);
    overflow-y:auto;
    box-shadow:0 0 24px rgba(0,0,0,.55);
    transition:transform .18s ease;
    border-right:none;
  }
  #hero-panel{
    left:0;
    transform:translateX(-105%);
    border-right:1px solid var(--border2);
  }
  #right-panel{
    right:0;
    left:auto;
    transform:translateX(105%);
    border-left:1px solid var(--border2);
  }
  body.drawer-hero #hero-panel{transform:translateX(0);}
  body.drawer-right #right-panel{transform:translateX(0);}
  body.drawer-hero #drawer-backdrop,
  body.drawer-right #drawer-backdrop{display:block;}
  #center-panel{border-left:none;border-right:none;}
}
@media (max-width: 720px){
  #game{grid-template-rows:auto 1fr auto;}
  #header{
    flex-wrap:wrap;
    row-gap:6px;
    height:auto;
    padding:6px 10px;
    padding-top:calc(6px + env(safe-area-inset-top));
  }
  #footer{
    flex-wrap:wrap;
    row-gap:6px;
    height:auto;
    padding:6px 10px;
    padding-bottom:calc(6px + env(safe-area-inset-bottom));
  }
  #log-wrap{height:140px;}
  .btn{padding:7px 12px;}
  #legacy-content{padding:14px;}
}
@media (max-width: 600px){
  /* Phone portrait: show hero panel above center content */
  .hero-toggle{display:none !important;}
  #main{display:flex;flex-direction:column;}
  #hero-panel{
    position:relative !important;
    top:auto !important;bottom:auto !important;left:auto !important;right:auto !important;
    width:100% !important;
    transform:none !important;
    box-shadow:none !important;
    border-right:none !important;
    border-left:none !important;
    border-bottom:1px solid var(--border);
    max-height:34vh;
    overflow-y:auto;
  }
  /* Right panel stays a drawer (opened via ğŸ“š Build) */
  #right-panel{width:min(92vw, 380px);}
  #center-panel{border-left:none;border-right:none;}
  .diff-wrap input[type="range"]{width:90px;}
}
@media (max-width: 420px){
  #log-wrap{height:120px;}
  #combat-log{font-size:10px;}
}
@media (max-width: 980px){
  #legacy-header{
    flex-wrap:wrap;
    height:auto;
    padding:10px 12px;
    gap:10px;
  }
  .legacy-tabs{
    width:100%;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
    padding:2px 0;
  }
  .legacy-tabs .ltab{
    flex:0 0 auto;
    white-space:nowrap;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   COLLAPSIBLE COMBAT LOG
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#log-wrap.collapsed{height:34px;}
#log-wrap.collapsed #combat-log{display:none;}
#log-wrap.collapsed #log-head{border-bottom:none;}


/* â”€â”€ TACTICS (pre-wave prep; cost paid when you start the trial) â”€â”€ */
.tactic-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:8px;}
.tactic-card{background:linear-gradient(to bottom, var(--bg2), var(--stone-dark));border:1px solid var(--border2);border-radius:6px;padding:10px;cursor:pointer;transition:transform .12s,border-color .12s,box-shadow .12s;position:relative;}
.tactic-card:hover{transform:translateY(-2px);border-color:var(--amber);box-shadow:0 6px 18px rgba(0,0,0,.25);}
.tactic-card.sel{border-color:rgba(212,160,23,.7);box-shadow:0 0 14px rgba(212,160,23,.22);}
.tactic-card.disabled{opacity:.45;cursor:not-allowed;transform:none;box-shadow:none;}
.tactic-top{display:flex;justify-content:space-between;align-items:flex-start;gap:10px;}
.tactic-name{font-weight:700;font-size:12px;}
.tactic-cost{font-family:'Share Tech Mono',monospace;font-size:11px;color:var(--gold);white-space:nowrap;}
.tactic-desc{font-size:10.5px;color:var(--txt2);line-height:1.35;margin-top:4px;}
.tactic-note{font-size:10px;color:var(--txt3);margin-top:6px;}
.tactic-pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;border:1px solid rgba(240,168,40,.35);background:rgba(240,168,40,.08);font-size:10px;color:var(--amber);}


/* â”€â”€ V5: Memory Binding Actions + Lineage Aspects â”€â”€ */
.breed-actions{display:flex;flex-wrap:wrap;gap:6px;margin:6px 0 10px;}
.ba-btn{background:var(--bg2);border:1px solid var(--border2);color:var(--txt2);}
.ba-btn.active{border-color:rgba(212,160,23,.55);box-shadow:0 0 10px rgba(212,160,23,.18);color:var(--txt);}
.ba-btn.disabled{opacity:.45;cursor:not-allowed;}
.breed-subpanel{background:rgba(20,18,40,.65);border:1px solid var(--border2);border-radius:6px;padding:10px;margin-top:8px;}
.choice-pill{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid rgba(144,80,232,.35);background:rgba(144,80,232,.10);cursor:pointer;font-size:11px;color:var(--txt2);}
.choice-pill.active{border-color:rgba(212,160,23,.6);background:rgba(212,160,23,.10);color:var(--txt);}
.aspect-row{display:flex;align-items:center;gap:8px;margin:6px 0;}
.aspect-bar{flex:1;height:6px;background:var(--bg3);border:1px solid var(--border);border-radius:6px;overflow:hidden;}
.aspect-fill{height:100%;}


@media (prefers-reduced-motion: reduce){
  *{ animation:none !important; transition:none !important; }
  body::after{ display:none; }
}


/* Balance Review (Codex subview) */
.br-codex-wrap{display:flex;flex-direction:column;gap:10px;}
.br-codex-top{display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;}
.br-codex-title{font-family:'Orbitron',sans-serif;font-size:16px;font-weight:900;color:var(--gold);}
.br-toggle{display:flex;gap:6px;flex-wrap:wrap;}
.br-tbtn{padding:5px 10px;border-radius:4px;border:1px solid var(--border2);background:var(--bg2);color:var(--txt2);font-size:11px;cursor:pointer;}
.br-tbtn.active{color:var(--gold);border-color:rgba(212,160,23,.55);box-shadow:0 0 10px rgba(212,160,23,.12) inset;}
.br-panel{background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:10px;}
.br-toolbar{display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px;}
.br-search{flex:1;min-width:220px;background:var(--bg);border:1px solid var(--border2);color:var(--txt);padding:6px 8px;border-radius:4px;font-size:11px;}
.br-toc{display:flex;gap:6px;flex-wrap:wrap;margin:8px 0 12px;}
.br-toc a{font-size:10px;color:var(--cyan);text-decoration:none;border:1px solid var(--border2);padding:3px 7px;border-radius:999px;background:rgba(0,0,0,.18);}
.br-section{border:1px solid var(--border2);border-radius:6px;background:rgba(0,0,0,.12);padding:0 10px;margin-bottom:8px;}
.br-section summary{cursor:pointer;padding:8px 0;color:var(--txt);font-weight:700;}
.br-note{font-size:11px;color:var(--txt3);margin:0 0 8px;line-height:1.5;}
.br-body{padding:0 0 10px;}
.br-h{font-family:'Orbitron',sans-serif;letter-spacing:.3px;}
table.br-table{width:100%;border-collapse:collapse;font-size:10px;}
.br-table th,.br-table td{border:1px solid var(--border2);padding:6px 7px;text-align:left;vertical-align:top;}
.br-table th{background:rgba(0,0,0,.32);color:var(--txt2);font-size:9px;letter-spacing:.6px;text-transform:uppercase;}
.br-chip{display:inline-block;margin:1px 3px 1px 0;padding:1px 6px;border-radius:999px;background:rgba(96,160,255,.12);border:1px solid rgba(96,160,255,.32);color:var(--txt2);font-size:9px;}
.br-rar{display:inline-block;padding:1px 6px;border-radius:999px;border:1px solid var(--border2);font-size:9px;text-transform:uppercase;}
.br-rar.rar-common{color:#cdd6e3}.br-rar.rar-uncommon{color:#7fd4a9}.br-rar.rar-rare{color:#77b7ff}.br-rar.rar-epic{color:#d3a4ff}.br-rar.rar-legendary{color:#f0c36d}.br-rar.rar-axiom{color:#ff7ad8}
.br-new-row td{border-left:3px solid rgba(100,255,220,.55)!important;}
.br-changed-row td{border-left:3px solid rgba(255,196,110,.65)!important;}

</style>
</head>
<body>

<!-- â”€â”€â”€ RUN SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="game">
  <div id="header">
    <span class="logo rune-glow-violet rune-breath">áš  RUNESAGA</span>
    <div style="width:1px;height:20px;background:var(--border2)"></div>
    <span class="wave-num" id="hdr-wave">Trial 1/12</span>
    <span style="font-size:11px;color:var(--txt3)" id="hdr-lvl">Lv.1</span>
    <div id="hdr-root-depth" style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--txt3)"></div>
    <div style="display:flex;align-items:center;gap:3px;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--gold)">á›‹<span id="hdr-gold">0</span></div>
    <div style="display:flex;align-items:center;gap:3px;font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--salvage)">áš±<span id="hdr-salvage">0</span></div>
    <div style="margin-left:auto;display:flex;gap:8px">
      <button class="btn btn-sm mobile-only hero-toggle" onclick="toggleDrawer('hero')">ğŸ§¬ Hero</button>
      <button class="btn btn-sm mobile-only" onclick="toggleDrawer('right')">ğŸ“š Build</button>

      <div class="diff-wrap" title="Difficulty multiplier (enemy stats)">
        <span class="diff-label">DIFF</span>
        <input id="diff-slider" type="range" min="0" max="2" step="0.1" value="1" oninput="onDifficultyInput(this.value)">
        <span class="diff-val" id="diff-val">x1.0</span>
      </div>

      <button class="btn btn-sm" id="btn-speed" onclick="cycleSpeed()">1Ã— Speed</button>
      <button class="btn btn-sm btn-gold" onclick="showLegacy()">á›Ÿ Minni-HÃ¶ll</button>
      <button class="btn btn-sm btn-danger" onclick="confirmReset()">Reset Lineage</button>
    </div>
  </div>
  <div id="main">
    <div class="panel" id="hero-panel"><div id="hero-content"></div></div>
    <div id="center-panel" class="panel" style="border-right:none">
      <div id="center-content" style="flex:1;overflow-y:auto"></div>
      <div id="log-wrap">
        <div id="log-head">
          <span style="font-size:10px;font-weight:700;letter-spacing:2px;color:var(--txt3)">COMBAT LOG</span>
          <div style="display:flex;gap:6px;align-items:center">
            <button class="btn btn-sm btn-ghost" id="btn-log-toggle" onclick="toggleCombatLog()">Collapse</button>
            <button class="btn btn-sm" style="background:var(--bg2);border:1px solid var(--border2);color:var(--txt3);font-size:10px;padding:2px 8px" onclick="clearLog()">Clear</button>
          </div>
        </div>
        <div id="combat-log"></div>
      </div>
    </div>
    <div class="panel" id="right-panel"><div id="right-content"></div></div>
  </div>
  <div id="footer">
    <div id="ftr-btns" style="display:flex;gap:8px;align-items:center"></div>
    <div style="display:flex;gap:8px;align-items:center">
      <button class="btn btn-sm btn-ghost mobile-only" onclick="toggleCombatLog()">ğŸ—’ Log</button>
    </div>
    <div id="ftr-info" style="margin-left:auto;font-size:11px;color:var(--txt3);font-family:'Share Tech Mono',monospace"></div>
  </div>
</div>

<!-- Drawer backdrop for mobile panels -->
<div id="drawer-backdrop" onclick="closeDrawers()" aria-hidden="true"></div>

<!-- â”€â”€â”€ LEGACY SCREEN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="legacy-screen">
  <div id="legacy-header">
    <span style="font-family:'Orbitron',sans-serif;font-size:14px;font-weight:900;color:var(--gold);letter-spacing:2px;text-shadow:0 0 12px rgba(212,160,23,.4)">á›Ÿ MINNI-HÃ–LL</span>
    <div style="width:1px;height:20px;background:var(--border2)"></div>
    <div class="legacy-tabs">
      <div class="ltab active" id="ltab-pool" onclick="setLegacyTab('pool')">Active Stones</div>
      <div class="ltab" id="ltab-breed" onclick="setLegacyTab('breed')">BIND</div>
      <div class="ltab" id="ltab-fallen" onclick="setLegacyTab('fallen')">SCARRED RUNES</div>
      <div class="ltab" id="ltab-tree" onclick="setLegacyTab('tree')">Family Tree</div>
      <div class="ltab" id="ltab-upgrades" onclick="setLegacyTab('upgrades')">Runesmith</div>
      <div class="ltab" id="ltab-codex" onclick="setLegacyTab('codex')">ğŸ“– Codex</div>
    </div>
    <div style="margin-left:auto;display:flex;gap:14px;align-items:center;font-size:12px;font-family:'Share Tech Mono',monospace">
      <span style="color:var(--gold)">á›’ <span id="leg-essence">0</span> Minni</span>
      <span style="color:var(--salvage)">áš± <span id="leg-salvage">0</span> Rune-Shards</span>
      <span style="color:var(--gold)">ğŸ—¿ <span id="leg-relics">0</span> Relics</span>
      <button class="btn btn-sm btn-danger" onclick="hideLegacy()">âœ• Return to Saga</button>
    </div>
  </div>
  <div id="legacy-body">
    <div id="legacy-content"></div>
  </div>
</div>

<!-- â”€â”€â”€ OVERLAY (start screen / retire / echo binding) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
<div id="overlay" style="display:none">
  <div class="ov-box" id="overlay-content"></div>
</div>

<script>
// â•â•â• SEEDED RNG â•â•â•
let _rng=1;
function seedRng(s){_rng=(typeof s==='string'?hashStr(s):(+s||Date.now()))>>>0||1;}
function hashStr(s){let h=2166136261;for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619);}return h>>>0||1;}
function rng(){_rng^=_rng<<13;_rng^=_rng>>>17;_rng^=_rng<<5;return(_rng>>>0)/4294967296;}
function ri(mn,mx){return Math.floor(rng()*(mx-mn+1))+mn;}
function rpick(a){return a[Math.floor(rng()*a.length)];}
function rshuffle(a){const b=[...a];for(let i=b.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));[b[i],b[j]]=[b[j],b[i]];}return b;}
function rwgt(items,wfn){const ws=items.map(wfn),t=ws.reduce((a,b)=>a+b,0);let r=rng()*t;for(let i=0;i<items.length;i++){r-=ws[i];if(r<=0)return items[i];}return items[items.length-1];}
function mkLocalRng(seed){
  let x=(typeof seed==='string'?hashStr(seed):(+seed||1))>>>0||1;
  const next=()=>{x^=x<<13;x^=x>>>17;x^=x<<5;return (x>>>0)/4294967296;};
  return {
    lrng:()=>next(),
    lri:(mn,mx)=>Math.floor(next()*(mx-mn+1))+mn,
    lrpick:(arr)=>arr[Math.floor(next()*arr.length)],
  };
}

const LEX={trial:'Trial',trials:'Trials',saga:'Saga',runeGift:'Rune-Gift',runeGifts:'Rune-Gifts',sagaMarks:'Saga-Marks',runeShards:'Rune-Shards',allfatherBlessing:"Minni",seekOmen:'Seek Another Omen',draftTitle:'Rune-Gift Draft',omens:'Omens',offerings:'Offerings'};
function trialStr(n){return `${LEX.trial} ${n}`;}
function trialsSurvivedStr(n,max){return `${LEX.trials} Survived`;}
function sagaSeedLabel(){return `${LEX.saga} Seed (optional)`;}

// â•â•â• EV SYSTEM â•â•â•
const EV_FACTORS={hp:.6,atk:.08,def:.05,spd:.2,crit:.0012,eva:.0008,acc:.001,ls:.0006};
const BASE_STATS={maxHP:100,atk:15,def:6,spd:45,critChance:.08,critDmg:1.75,evasion:.04,accuracy:.88,lifesteal:0};
const EV_KEYS=['hp','atk','def','spd','crit','eva','acc','ls'];
const EV_CAP_BASE=60;
function evCap(){return Math.min(100,EV_CAP_BASE+(META.upgrades.evCap||0)*10);}
function evDerived(evs){
  return{
    maxHP:BASE_STATS.maxHP+Math.floor((evs.hp||0)*EV_FACTORS.hp),
    atk:Math.round((BASE_STATS.atk+(evs.atk||0)*EV_FACTORS.atk)*10)/10,
    def:Math.round((BASE_STATS.def+(evs.def||0)*EV_FACTORS.def)*10)/10,
    spd:Math.round(BASE_STATS.spd+(evs.spd||0)*EV_FACTORS.spd),
    critChance:Math.min(.9,BASE_STATS.critChance+(evs.crit||0)*EV_FACTORS.crit),
    critDmg:BASE_STATS.critDmg,
    evasion:Math.min(.6,BASE_STATS.evasion+(evs.eva||0)*EV_FACTORS.eva),
    accuracy:Math.min(.99,BASE_STATS.accuracy+(evs.acc||0)*EV_FACTORS.acc),
    lifesteal:Math.min(.4,BASE_STATS.lifesteal+(evs.ls||0)*EV_FACTORS.ls),
  };
}
function emptyEVs(){return{hp:0,atk:0,def:0,spd:0,crit:0,eva:0,acc:0,ls:0};}

// â•â•â• GENETIC TRAITS â•â•â•
const GTRAITS={
  serrated:{name:'Serrated',icon:'ğŸ—¡',desc:'On hit: 22% chance to apply 1 Bleed (2s).',color:'#ff7070'},
  aegis:{name:'Skjald-Born',icon:'ğŸ›¡',desc:'Battle start: gain 8 Shield.',color:'#80a8ff'},
  skirmisher:{name:'Raider-Born',icon:'ğŸ’¨',desc:'+8 SPD when below 50% HP.',color:'#80d0ff'},
  venomkiss:{name:'Venomkiss',icon:'â˜ ',desc:'Poison ticks deal +1 extra damage.',color:'#70d870'},
  gambler:{name:'Fate-Bold',icon:'ğŸ²',desc:'+5% Crit Chance, âˆ’2 DEF.',color:'#e8c048'},
  spite:{name:'Spite',icon:'ğŸŒµ',desc:'Reflect 8% of damage taken as true dmg.',color:'#d0d060'},
  ironblood:{name:'Iron Blood',icon:'âš™',desc:'+5 DEF.',color:'#90a8c8'},
  swift_born:{name:'Swift Born',icon:'âš¡',desc:'+8 SPD.',color:'#c080ff'},
  lucky:{name:'Fortune-Touched',icon:'ğŸ€',desc:'+4% Crit Chance.',color:'#60e090'},
  resilient:{name:'Hardened',icon:'â¤',desc:'+25 Max HP.',color:'#80e080'},
  predatory:{name:'Wolf-Blood',icon:'ğŸ†',desc:'+3 ATK when below 50% HP.',color:'#f08040'},
  vampiric_b:{name:'Wound-Drinker Blood',icon:'ğŸ§›',desc:'+3% Lifesteal.',color:'#d070d8'},
  tenacious:{name:'Tenacious',icon:'ğŸ”°',desc:'Below 25% HP: take 40% less damage.',color:'#60b8ff'},
  executioner_b:{name:"Executor's Blood",icon:'ğŸ’€',desc:'+15% dmg to enemies below 30% HP.',color:'#ff5050'},
};
const GTRAIT_KEYS=Object.keys(GTRAITS);
const TRAIT_MAX_BASE=3;

// â•â•â• STATUS DEFS â•â•â•
const STATUS={
  bleed:{name:'Bleed',icon:'ğŸ©¸',cls:'sb-bleed',desc:'DoT: (3+stacks) dmg/sec'},
  poison:{name:'Poison',icon:'â˜ ',cls:'sb-poison',desc:'DoT: (2+stacks) dmg/sec'},
  shield:{name:'Shield',icon:'ğŸ›¡',cls:'sb-shield',desc:'Absorbs damage'},
  weak:{name:'Weak',icon:'ğŸ’”',cls:'sb-weak',desc:'-25% damage dealt'},
  vulnerable:{name:'Vuln',icon:'ğŸ¯',cls:'sb-vulnerable',desc:'+30% damage taken'},
  rage:{name:'Rage',icon:'ğŸ”¥',cls:'sb-rage',desc:'+3 ATK per stack'},
  slow:{name:'Slow',icon:'ğŸŒ',cls:'sb-slow',desc:'-30% Speed'},
  stun:{name:'Stun',icon:'ğŸ’«',cls:'sb-stun',desc:'Cannot act'},
  tempo:{name:'Tempo',icon:'âš¡',cls:'sb-tempo',desc:'+3 SPD per stack'},
  marked:{name:'Marked',icon:'ğŸ¯',cls:'sb-marked',desc:'Next hit +30% dmg; then consumed'},
  hexed:{name:'Hexed',icon:'ğŸŒ€',cls:'sb-hexed',desc:'Enemy attacks miss more often'},
  momentum:{name:'Momentum',icon:'âš¡',cls:'sb-momentum',desc:'+2 dmg per stack to next attack; then consumed'},
  patience:{name:'Patience',icon:'ğŸ•°',cls:'sb-patience',desc:'+8% dmg per sec not attacking (max +40%); consumed on attack'},
  regen:{name:'Regen',icon:'ğŸ’š',cls:'sb-regen',desc:'Heals HP per sec'},
};

const REALM_TIERS=[];

// â•â•â• BOONS â•â•â•
const BOONS=[
  {id:'iron_skin',name:'Iron Skin',rarity:'common',tags:['Bulwark'],icon:'ğŸ›¡',desc:'+22 Defense.',effects:[{t:'stat',s:'def',v:22}]},
  {id:'battle_fury',name:'Battle Fury',rarity:'common',tags:['Crit'],icon:'âš”',desc:'+14 Attack.',effects:[{t:'stat',s:'atk',v:14}]},
  {id:'thick_blood',name:'Thick Blood',rarity:'common',tags:['Sustain'],icon:'â¤',desc:'+65 Max HP.',effects:[{t:'stat',s:'maxHP',v:65},{t:'stat',s:'hp',v:65}]},
  {id:'sharp_edge',name:'Keen Edge',rarity:'common',tags:['Crit'],icon:'ğŸ—¡',desc:'+9% Crit Chance.',effects:[{t:'stat',s:'critChance',v:.09}]},
  {id:'swift_strikes',name:'Stormblows',rarity:'common',tags:['Tempo'],icon:'ğŸ’¨',desc:'+18 Speed.',effects:[{t:'stat',s:'spd',v:18}]},
  {id:'blood_sense',name:'Blood Sense',rarity:'common',tags:['Bleed'],icon:'ğŸ©¸',desc:'On hit: 20% chance to apply 1 Bleed (3s).',effects:[{t:'onHit',ef:'statusEnemy',st:'bleed',sk:1,dur:3,ch:0.20}]},
  {id:'toxic_touch',name:'Eitr-Touch',rarity:'common',tags:['Poison'],icon:'â˜ ',desc:'On hit: 20% chance to apply 1 Poison (4s).',effects:[{t:'onHit',ef:'statusEnemy',st:'poison',sk:1,dur:4,ch:0.20}]},
  {id:'wound_count',name:'Wound-Counter',rarity:'common',tags:['Execute','Crit'],icon:'ğŸ¯',desc:'On hit: apply Marked (3s) to the target.',effects:[{t:'onHit',ef:'statusEnemy',st:'marked',sk:1,dur:3}]},
  {id:'patient_blade',name:'Patient Blade',rarity:'common',tags:['Tempo'],icon:'ğŸ•°',desc:'Each second without attacking: +8% dmg to next attack (max +40%). Consumed on attack.',effects:[{t:'passive',k:'patienceBlade',v:0.08}]},
  {id:'momentum_start',name:'First Fury',rarity:'common',tags:['Tempo','Crit'],icon:'ğŸ’¥',desc:'First attack of each battle deals +60% damage.',effects:[{t:'passive',k:'firstFury',v:true}]},
  {id:'vampiric',name:"Draugr's Thirst",rarity:'common',tags:['Sustain'],icon:'ğŸ©¸',desc:'+8% Lifesteal.',effects:[{t:'stat',s:'lifesteal',v:.08}]},
  {id:'bulwark_start',name:'Bulwark',rarity:'common',tags:['Bulwark','Shield'],icon:'ğŸ”°',desc:'Start each battle with 35 Shield.',effects:[{t:'onBattleStart',ef:'shield',amt:35}]},
  {id:'dodge_step',name:'Skirmish-Step',rarity:'common',tags:['Tempo'],icon:'ğŸ’ƒ',desc:'+9% Evasion.',effects:[{t:'stat',s:'evasion',v:.09}]},
  {id:'steady_aim',name:"Ullr's Eye",rarity:'common',tags:['Crit'],icon:'ğŸ¯',desc:'+25% Crit Damage.',effects:[{t:'stat',s:'critDmg',v:.25}]},
  {id:'reinforced',name:'Reinforced',rarity:'common',tags:['Bulwark'],icon:'ğŸ°',desc:'+12 Defense, +20 Max HP.',effects:[{t:'stat',s:'def',v:12},{t:'stat',s:'maxHP',v:20},{t:'stat',s:'hp',v:20}]},
  {id:'honed_reflex',name:'Honed Reflex',rarity:'common',tags:['Tempo','Crit'],icon:'âš¡',desc:'+12 Speed, +5% Crit Chance.',effects:[{t:'stat',s:'spd',v:12},{t:'stat',s:'critChance',v:.05}]},

  {id:'hemorrhage',name:'Hemorrhage',rarity:'uncommon',tags:['Bleed'],icon:'ğŸ’¢',desc:'Bleed deals 70% more damage.',effects:[{t:'passive',k:'bleedMult',v:1.70}]},
  {id:'virulent',name:'Festering',rarity:'uncommon',tags:['Poison'],icon:'ğŸ§ª',desc:'Poison deals 70% more damage.',effects:[{t:'passive',k:'poisonMult',v:1.70}]},
  {id:'shield_bash',name:'Shield Bash',rarity:'uncommon',tags:['Bulwark','Thorns'],icon:'ğŸ’¥',desc:'When Shield breaks, deal 22 true dmg.',effects:[{t:'passive',k:'shieldBash',v:22}]},
  {id:'crit_surge',name:'Wound-Open',rarity:'uncommon',tags:['Crit'],icon:'âš¡',desc:'Crits apply Vulnerable (3s) to enemy.',effects:[{t:'onCrit',ef:'statusEnemy',st:'vulnerable',sk:1,dur:3}]},
  {id:'hexing_strike',name:'Hex-Strike',rarity:'uncommon',tags:['Arcane','Crit'],icon:'ğŸŒ€',desc:'On crit: apply Hexed (4s) to the target (âˆ’30% accuracy).',effects:[{t:'onCrit',ef:'statusEnemy',st:'hexed',sk:1,dur:4}]},
  {id:'tempo_rise',name:'Battle-Rise',rarity:'uncommon',tags:['Tempo'],icon:'ğŸŒ€',desc:'Each kill grants +1 Tempo stack.',effects:[{t:'onKill',ef:'status',st:'tempo',sk:1,dur:9999}]},
  {id:'executioner',name:'Executioner',rarity:'uncommon',tags:['Execute'],icon:'ğŸ’€',desc:'+28% damage to enemies below 30% HP.',effects:[{t:'passive',k:'executioner',v:.28}]},
  {id:'thorns',name:'Thorns',rarity:'uncommon',tags:['Thorns'],icon:'ğŸŒµ',desc:'Reflect 22% of damage taken.',effects:[{t:'passive',k:'thorns',v:.22}]},
  {id:'battle_trance',name:'Battle Trance',rarity:'uncommon',tags:['Tempo'],icon:'ğŸ”',desc:'Every 5th attack deals +90% bonus dmg.',effects:[{t:'passive',k:'trance',v:5}]},
  {id:'twin_strike',name:'Twin Strike',rarity:'uncommon',tags:['Tempo','Crit'],icon:'âš”',desc:'22% chance to attack twice per swing.',effects:[{t:'passive',k:'twin',v:.22}]},
  {id:'bleed_weak',name:'Bleeding Edge',rarity:'uncommon',tags:['Bleed'],icon:'ğŸ—¡',desc:'Bleed also applies Weak to target.',effects:[{t:'passive',k:'bleedWeak',v:true}]},
  {id:'poison_slow',name:'Dulling Eitr',rarity:'uncommon',tags:['Poison'],icon:'ğŸŒ',desc:'Applying Poison also Slows the enemy.',effects:[{t:'passive',k:'poisonSlow',v:true}]},
  {id:'guard_mark',name:"Guardian's Mark",rarity:'uncommon',tags:['Bulwark','Sustain'],icon:'âœ¨',desc:'+45 Max HP, +10 Defense.',effects:[{t:'stat',s:'maxHP',v:45},{t:'stat',s:'hp',v:45},{t:'stat',s:'def',v:10}]},

  {id:'necrotic',name:'Corpse-Rot',rarity:'rare',tags:['Poison'],icon:'ğŸ§Ÿ',desc:'Each Poison stack reduces enemy DEF by 3.',effects:[{t:'passive',k:'necroticPoison',v:3}]},
  {id:'vanguard',name:'Vanguard',rarity:'rare',tags:['Bulwark','Shield'],icon:'ğŸ›¡',desc:'Taking HP damage grants 8 Shield.',effects:[{t:'onDmg',ef:'shield',amt:8}]},
  {id:'rampage',name:'Rampage',rarity:'rare',tags:['Execute','Tempo'],icon:'ğŸ˜¤',desc:'Each kill grants +7 ATK (this battle).',effects:[{t:'onKill',ef:'tempStat',s:'atk',v:7}]},
  {id:'soul_rend',name:'Spirit Rend',rarity:'rare',tags:['Arcane'],icon:'ğŸ‘»',desc:'22% of damage bypasses enemy Defense.',effects:[{t:'passive',k:'defpen',v:.22}]},
  {id:'overwhelming',name:'Crusher',rarity:'rare',tags:['Crit','Arcane'],icon:'ğŸ’ª',desc:'Crits ignore 55% of enemy Defense.',effects:[{t:'passive',k:'critDefpen',v:.55}]},
  {id:'predator',name:'Wolf-Hunger',rarity:'rare',tags:['Execute','Sustain'],icon:'ğŸ†',desc:'+22% ATK when below 50% HP.',effects:[{t:'passive',k:'predator',v:.22}]},
  {id:'crimson_tide',name:'Crimson Tide',rarity:'rare',tags:['Bleed'],icon:'ğŸŒŠ',desc:'Bleed also Slows the target.',effects:[{t:'passive',k:'bleedSlow',v:true}]},
  {id:'arcane_surge',name:'Galdr-Surge',rarity:'rare',tags:['Arcane'],icon:'ğŸ”®',desc:'Every 4th attack: +90% magic dmg (ignores DEF).',effects:[{t:'passive',k:'arcane',v:4}]},
  {id:'living_armor',name:'Root-Bound Plate',rarity:'rare',tags:['Sustain'],icon:'ğŸ’š',desc:'Regen 3% Max HP per second.',effects:[{t:'passive',k:'regen',v:.03}]},
  {id:'berserker',name:"Berserker's Heart",rarity:'rare',tags:['Execute','Tempo'],icon:'ğŸ’¢',desc:'Below 30% HP: +40% ATK, +20% SPD.',effects:[{t:'passive',k:'berserk',atk:.40,spd:.20,thr:.30}]},

  {id:'death_mark',name:'Death Mark',rarity:'epic',tags:['Execute','Bleed'],icon:'â˜ ',desc:'On kill, next attack deals +160% bonus dmg.',effects:[{t:'onKill',ef:'flag',f:'deathMark',v:1}]},
  {id:'plague_lord',name:'Eitr-Lord',rarity:'epic',tags:['Poison'],icon:'â˜£',desc:'Applying Poison spreads 1 stack to up to 2 other enemies.',effects:[{t:'passive',k:'plagueLord',v:true}]},
  {id:'void_strike',name:'Ginnunga-Strike',rarity:'epic',tags:['Arcane'],icon:'ğŸŒ€',desc:'Every 8th attack deals 3Ã— damage (ignores DEF).',effects:[{t:'passive',k:'void',v:8}]},
  {id:'apex_predator',name:'Hunt-King',rarity:'epic',tags:['Execute'],icon:'ğŸ¦',desc:'Each kill grants permanent +6 ATK.',effects:[{t:'onKill',ef:'permStat',s:'atk',v:6}]},
  {id:'undying',name:'Undying',rarity:'epic',tags:['Sustain'],icon:'ğŸ”„',desc:'Once per battle, revive with 35% HP.',effects:[{t:'passive',k:'undying',v:true}]},

  {id:'chain_lightning',name:"Thor's Lash",rarity:'legendary',tags:['Arcane','Tempo'],icon:'âš¡',desc:'Crits splash 55% dmg to a random other enemy.',effects:[{t:'onCrit',ef:'splash',v:.55}]},
  {id:'eternal_hunger',name:'Eternal Hunger',rarity:'legendary',tags:['Sustain','Execute'],icon:'ğŸŒ‘',desc:'+18% Lifesteal. Overheal converts to Shield (60%, capped/battle).',effects:[{t:'stat',s:'lifesteal',v:.18},{t:'passive',k:'overhealShield',v:true}]},

  {id:'ax_opening',name:'RUNE: First Blood',rarity:'axiom',tags:['Axiom','Crit'],icon:'ğŸ’«',desc:'First hit each battle always crits.',effects:[{t:'passive',k:'axiomOpen',v:true}]},
  {id:'ax_aegis',name:'RUNE: Shield Law',rarity:'axiom',tags:['Axiom','Shield','Sustain'],icon:'ğŸ’',desc:'Overhealing becomes Shield (60% conversion, capped per battle).',effects:[{t:'passive',k:'overhealShield',v:true}]},
  {id:'ax_crimson',name:'RUNE: Crimson Law',rarity:'axiom',tags:['Axiom','Bleed'],icon:'ğŸ©¸',desc:'Applying Bleed also applies Weak.',effects:[{t:'passive',k:'axiomCrimson',v:true}]},
  {id:'ax_ghost',name:'RUNE: Shade-Step',rarity:'axiom',tags:['Axiom','Tempo'],icon:'ğŸ‘»',desc:'When you dodge, gain +2 Tempo stacks.',effects:[{t:'onDodge',ef:'status',st:'tempo',sk:2,dur:9999}]},
  {id:'ax_echo',name:'RUNE: Echo Strike',rarity:'axiom',tags:['Axiom','Tempo'],icon:'ğŸ”',desc:'Every 4th attack repeats at 40% power.',effects:[{t:'passive',k:'axiomEcho',v:4}]},
  {id:'ax_iron_law',name:'RUNE: Iron Law',rarity:'axiom',tags:['Axiom','Bulwark'],icon:'âš–',desc:'20% of your Defense adds to Attack (max +12).',effects:[{t:'passive',k:'axiomIronLaw',v:.20}]},
  {id:'ax_harvest',name:'RUNE: Death Harvest',rarity:'axiom',tags:['Axiom','Sustain'],icon:'âš—',desc:'Kills restore 12% Max HP.',effects:[{t:'onKill',ef:'healPct',v:.12}]},
  {id:'ax_wrath',name:'RUNE: Berserkr Law',rarity:'axiom',tags:['Axiom','Crit'],icon:'ğŸ”¥',desc:'Crits grant Rage stacks (+3 ATK each, max 15).',effects:[{t:'onCrit',ef:'status',st:'rage',sk:1,dur:9999,mx:15}]},
  {id:'ax_fortress',name:'RUNE: Stone Resolve',rarity:'axiom',tags:['Axiom','Bulwark','Shield'],icon:'ğŸ¯',desc:'While Shield is very high (â‰¥30% Max HP), it absorbs full hits (2s cooldown).',effects:[{t:'passive',k:'axiomFortress',v:true}]},
  {id:'ax_kinetic',name:'RUNE: Storm-Edge',rarity:'axiom',tags:['Axiom','Crit','Tempo'],icon:'ğŸ’ ',desc:'SPD grants Crit Chance (up to +20%).',effects:[{t:'passive',k:'axiomKinetic',v:true}]},
  {id:'ax_plague',name:'RUNE: Eitr Thread',rarity:'axiom',tags:['Axiom','Poison','Bleed'],icon:'ğŸ¦ ',desc:'Status effects last 60% longer.',effects:[{t:'passive',k:'axiomPlague',v:1.6}]},
  {id:'ax_mirror',name:'RUNE: Mirror Law',rarity:'axiom',tags:['Axiom','Thorns'],icon:'ğŸª',desc:'22% of post-shield HP damage is reflected (max 20/hit).',effects:[{t:'passive',k:'axiomMirror',v:.22}]},
  {id:'ax_hunger_law',name:'RUNE: Hunger Law',rarity:'axiom',tags:['Axiom','Execute','Arcane'],icon:'ğŸ¦·',desc:'Attacks against enemies below 50% HP ignore Shield.',effects:[{t:'passive',k:'axiomHungerLaw',v:true}]},

{id:'precision_optics', name:'Hawk-Sight',      rarity:'common',  tags:['Crit'],                icon:'ğŸ”­',desc:'+8% Accuracy.', effects:[{t:'stat',s:'accuracy',v:.08}]},
{id:'cleaving_arc',     name:'Cleaving Arc',          rarity:'uncommon',tags:['Execute','Tempo'],     icon:'ğŸª“',desc:'On hit: splash 35% damage to a random other enemy.', effects:[{t:'onHit',ef:'splash',v:.35}]},
{id:'frost_touch',      name:'Frost Touch',           rarity:'uncommon',tags:['Tempo'],              icon:'â„ï¸',desc:'On hit: apply Slow (2s).', effects:[{t:'onHit',ef:'statusEnemy',st:'slow',sk:1,dur:2}]},
{id:'sunder_blows',     name:'Sunder Blows',          rarity:'uncommon',tags:['Arcane'],             icon:'ğŸª¨',desc:'On hit: reduce enemy DEF by 2 (stacks, battle).', effects:[{t:'passive',k:'shred',v:2}]},
{id:'sniper_protocol',  name:"Huntsman's Mark",       rarity:'uncommon',tags:['Crit'],               icon:'ğŸ¯',desc:'Attacks target the lowest-HP enemy.', effects:[{t:'passive',k:'targetLowest',v:true}]},
{id:'ward_protocol',    name:'Runic Ward',         rarity:'rare',    tags:['Bulwark'],            icon:'ğŸ§¿',desc:'Once per battle, the first debuff applied to you is negated.', effects:[{t:'passive',k:'wardDebuff',v:true}]},
{id:'antitoxin_glands', name:'Hardened Blood',      rarity:'rare',    tags:['Sustain'],            icon:'ğŸ§¬',desc:'Take 40% less Bleed/Poison damage.', effects:[{t:'passive',k:'dotResist',v:.60}]},
{id:'stunning_crits',   name:'Reel-Blow',        rarity:'rare',    tags:['Crit'],               icon:'ğŸ’«',desc:'Crits have 18% chance to Stun (1s).', effects:[{t:'passive',k:'stunCrit',v:.18}]},
{id:'second_wind',      name:'Second Wind',           rarity:'rare',    tags:['Sustain'],            icon:'ğŸŒ¬ï¸',desc:'Once per battle, dropping below 30% HP heals 20% Max HP.', effects:[{t:'passive',k:'secondWind',v:.20}]},
];

const GEAR_TEMPLATES={
  weapon_iron_seax:{slot:'weapon',baseName:'Iron Seax',rarity:'common',loreNote:'A short blade, practical and honest.',affixes:[{stat:'atk',value:8,label:'+8 ATK'}]},
  weapon_ulfberht:{slot:'weapon',baseName:'Ulfberht Blade',rarity:'uncommon',loreNote:'Forged with runes in the steel.',affixes:[{stat:'atk',value:14,label:'+14 ATK'},{stat:'critChance',value:0.06,label:'+6% Crit'}]},
  weapon_gram_shard:{slot:'weapon',baseName:"Gram's Shard",rarity:'rare',loreNote:'A fragment of the sword that slew FÃ¡fnir.',affixes:[{stat:'atk',value:18,label:'+18 ATK'},{stat:'critChance',value:0.10,label:'+10% Crit'},{stat:'onCritBleedChance',value:0.20,label:'On Crit: 20% chance â€” Bleed (3s)'}]},
  weapon_dainsleif:{slot:'weapon',baseName:'DÃ¡insleif',rarity:'epic',loreNote:'"Drawn blade never sheathes unsated."',flavor:'It will not rest until it has fed.',affixes:[{stat:'atk',value:24,label:'+24 ATK'},{stat:'critChance',value:0.15,label:'+15% Crit'},{stat:'executionBonus',value:0.22,label:'+22% dmg below 30%'}]},
  weapon_tyrfing:{slot:'weapon',baseName:'Tyrfing',rarity:'legendary',loreNote:'"Cursed to cause three great evils."',flavor:'Power without mercy.',affixes:[{stat:'atk',value:30,label:'+30 ATK'},{stat:'critChance',value:0.18,label:'+18% Crit'},{stat:'permAtkOnKill',value:4,label:'Kills grant +4 permanent ATK'},{stat:'cursedDamageMult',value:0.08,label:'CURSED: +8% damage taken'}]},
  weapon_gungnir_echo:{slot:'weapon',baseName:"Gungnir's Echo",rarity:'axiom',loreNote:"The Allfather's spear never misses.",flavor:'True weapon. True path.',affixes:[{stat:'atk',value:20,label:'+20 ATK'},{stat:'defPen',value:0.40,label:'Ignore 40% DEF'},{stat:'accuracySet',value:0.99,label:'Accuracy set to 99%'}]},
  armor_hide_wrap:{slot:'armor',baseName:'Hide Wrap',rarity:'common',loreNote:'Rough but better than nothing.',affixes:[{stat:'def',value:6,label:'+6 DEF'}]},
  armor_chain_rings:{slot:'armor',baseName:'Chainmail Rings',rarity:'uncommon',loreNote:'Dvergar-forged links.',affixes:[{stat:'def',value:12,label:'+12 DEF'},{stat:'maxHP',value:20,label:'+20 Max HP'}]},
  armor_rune_plate:{slot:'armor',baseName:'Rune-Plate',rarity:'rare',loreNote:'Protection-runes burned into the steel.',affixes:[{stat:'def',value:18,label:'+18 DEF'},{stat:'maxHP',value:35,label:'+35 Max HP'},{stat:'shieldOnBattleStart',value:15,label:'Battle start: +15 Shield'}]},
  armor_ulfr_hide:{slot:'armor',baseName:'Ulfr Hide',rarity:'epic',loreNote:'Skinned from a Jotunheim cave-wolf.',affixes:[{stat:'def',value:22,label:'+22 DEF'},{stat:'maxHP',value:50,label:'+50 Max HP'},{stat:'dotResist',value:0.30,label:'Take 30% less Bleed/Poison'}]},
  talisman_runestone:{slot:'talisman',baseName:'Carved Runestone',rarity:'common',loreNote:'A ward carved in haste.',affixes:[{stat:'evasion',value:0.04,label:'+4% Evasion'}]},
  talisman_valknut:{slot:'talisman',baseName:'Valknut Amulet',rarity:'uncommon',loreNote:"Three interlocked triangles. Odin's mark.",affixes:[{stat:'critDmg',value:0.25,label:'+25% Crit Damage'},{stat:'evasion',value:0.04,label:'+4% Evasion'}]},
  talisman_yggdrasil_leaf:{slot:'talisman',baseName:'Yggdrasil Leaf',rarity:'rare',loreNote:'Fallen from a branch that no longer exists.',affixes:[{stat:'lifesteal',value:0.06,label:'+6% Lifesteal'},{stat:'regenPct',value:0.02,label:'Regen 2% HP/sec'}]},
  talisman_norns_thread:{slot:'talisman',baseName:"Norn's Thread",rarity:'epic',loreNote:'Spun from the fate of a hero who almost survived.',affixes:[{stat:'critChance',value:0.10,label:'+10% Crit Chance'},{stat:'lifesteal',value:0.08,label:'+8% Lifesteal'},{stat:'evasion',value:0.05,label:'+5% Evasion'}]},
  talisman_wooden_shield:{slot:'talisman',baseName:'Wooden Shield',rarity:'common',isShield:true,loreNote:'Simple planks bound for first blood.',affixes:[{stat:'battleStartShield',value:10,label:'Battle start: +10 Shield'}]},
  talisman_round_shield:{slot:'talisman',baseName:'Round Shield',rarity:'uncommon',isShield:true,loreNote:'Ringed shield with a seasoned boss.',affixes:[{stat:'battleStartShield',value:18,label:'Battle start: +18 Shield'}]},
  talisman_runed_shield:{slot:'talisman',baseName:'Runed Shield',rarity:'rare',isShield:true,loreNote:'Runes etched to turn the first blow.',affixes:[{stat:'def',value:12,label:'+12 DEF'},{stat:'battleStartShield',value:12,label:'Battle start: +12 Shield'}]},
};

function generateGearItem(templateId,template,wave){
  return {id:templateId+'_'+ri(10000,99999),templateId,name:template.baseName,slot:template.slot,rarity:template.rarity,flavor:template.flavor||null,loreNote:template.loreNote||null,affixes:template.affixes.map(a=>({...a})),notches:0,sundered:false,sagaHistory:[],forgedBy:null,forgedByName:null,passiveBonus:null,isShield:!!template.isShield};
}
function getGearEffectiveAffixes(gear){
  if(!gear)return[];
  const mult=gear.sundered?0.70:1.0;
  return gear.affixes.map(affix=>({...affix,effectiveValue:typeof affix.value==='number'?affix.value*mult:affix.value,label:gear.sundered?`${affix.label} âš SUNDERED`:affix.label}));
}

function gearMaxHPAffixValue(item){
  if(!item)return 0;
  return getGearEffectiveAffixes(item).reduce((sum,affix)=>{
    if(affix.stat==='maxHP'&&typeof affix.effectiveValue==='number')return sum+affix.effectiveValue;
    return sum;
  },0);
}
function applyGearMaxHPDelta(hero,oldItem,newItem){
  if(!hero)return;
  const oldMaxHP=gearMaxHPAffixValue(oldItem);
  const newMaxHP=gearMaxHPAffixValue(newItem);
  const delta=Math.floor(newMaxHP-oldMaxHP);
  if(delta===0)return;
  hero.maxHP=Math.max(10,hero.maxHP+delta);
  if(delta>0)hero.hp=Math.min(hero.maxHP,hero.hp+delta);
  else hero.hp=Math.min(hero.hp,hero.maxHP);
}
function applyAllGearMaxHP(hero){
  if(!hero||!hero.gear)return;
  const total=Object.values(hero.gear).reduce((sum,item)=>sum+gearMaxHPAffixValue(item),0);
  if(total<=0)return;
  hero.maxHP=Math.max(10,hero.maxHP+Math.floor(total));
  hero.hp=Math.min(hero.maxHP,hero.hp+Math.floor(total));
}
function gearCost(item){
  const base={common:8,uncommon:14,rare:22,epic:35,legendary:55,axiom:80};
  return (base[item.rarity]||15)+Math.floor((item.notches||0)*-1.5);
}
function rarityColor(rarity){
  const map={common:'#6060a0',uncommon:'#50a050',rare:'#6060d8',epic:'#a040c0',legendary:'var(--gold)',axiom:'#d050ff'};
  return map[rarity]||'#888';
}
function rarityBorderColor(rarity){
  const map={common:'#3a3a5a',uncommon:'#2a5a2a',rare:'#2a2a7a',epic:'#5a2a7a',legendary:'#7a5a00',axiom:'#7a20b0'};
  return map[rarity]||'var(--border2)';
}
function genForgeStallItem(wave){
  const rw={common:40,uncommon:25,rare:15,epic:8,legendary:3,axiom:1};
  const boost=Math.min(wave,10);
  rw.common=Math.max(10,rw.common-boost*2);
  rw.rare+=boost;
  rw.epic+=Math.floor(boost/2);
  const templates=Object.entries(GEAR_TEMPLATES);
  const picked=rwgt(templates,([id,t])=>rw[t.rarity]||1);
  if(!picked)return null;
  return generateGearItem(picked[0],picked[1],wave);
}
function hasSunderedGear(){
  if(!G||!G.hero||!G.hero.gear)return false;
  return Object.values(G.hero.gear).some(item=>item&&item.sundered);
}

const NOTCH_HISTORY_TEMPLATES=[
  wave=>`Bloodied at Trial ${wave}`,
  wave=>`Scarred in the ${wave<=3?'Midgard':wave<=6?'Helheim':wave<=9?'Jotunheim':'Muspelheim'} crossing`,
  wave=>`Worn thin at Trial ${wave}`,
  wave=>`Notched by the battle at Trial ${wave}`,
];
function tryAddNotch(gear,wave){
  if(!gear||gear.sundered)return;
  if(rng()>0.15)return;
  gear.notches=Math.min(5,(gear.notches||0)+1);
  if(gear.sagaHistory&&gear.sagaHistory.length<3)gear.sagaHistory.push(rpick(NOTCH_HISTORY_TEMPLATES)(wave));
  if(gear.notches>=5&&!gear.sundered){
    gear.sundered=true;
    addLog(`âš  ${gear.name} is Sundered. Visit the Forge Stall to recondition it.`,'lstatus');
  }
}
function addNotchesToHeroGear(wave){
  if(!G||!G.hero||!G.hero.gear)return;
  Object.values(G.hero.gear).forEach(item=>{if(item)tryAddNotch(item,wave);});
}
function reconditionGear(slot){
  if(!G||!G.hero||!G.hero.gear)return;
  const item=G.hero.gear[slot];
  if(!item||!item.sundered)return;
  const cost=10+((META.upgrades&&META.upgrades.evCap)||0);
  if(META.salvage<cost){addLog(`áš± ${cost} Rune-Shards required to recondition ${item.name}.`,'lstatus');return;}
  META.salvage-=cost;
  item.notches=0; item.sundered=false;
  if(rng()<0.20+((META.upgrades&&META.upgrades.evCap)||0)*0.05){
    const numericalAffixes=item.affixes.filter(a=>typeof a.value==='number'&&a.value>0);
    if(numericalAffixes.length){
      const target=rpick(numericalAffixes);
      const improvement=Math.max(1,Math.floor(target.value*0.15));
      const oldMaxHP=gearMaxHPAffixValue(item);
      target.value+=improvement;
      target.label+=` (+${improvement} reconditioned)`;
      const newMaxHP=gearMaxHPAffixValue(item);
      if(newMaxHP!==oldMaxHP){const before={...item,affixes:item.affixes.map(a=>({...a}))};before.affixes=before.affixes.map(a=>a.stat==='maxHP'&&typeof a.value==='number'?{...a,value:a.value-improvement}:a);applyGearMaxHPDelta(G.hero,before,item);}
      addLog(`âš’ ${item.name} reconditioned! One affix improved.`,'laxiom');
    }else addLog(`âš’ ${item.name} reconditioned.`,'lstatus');
  }else addLog(`âš’ ${item.name} reconditioned.`,'lstatus');
  item.sagaHistory=item.sagaHistory||[];
  item.sagaHistory.push(`Reforged at Trial ${G.wave}`);
  if(item.sagaHistory.length>3)item.sagaHistory.shift();
  saveMeta(); updateMetaHeader(); renderAll();
}
function buyGear(){
  const item=G.forgeStallItem;
  if(!item)return;
  const cost=gearCost(item);
  if(G.gold<cost)return;
  G.gold-=cost;
  const oldGear=G.hero.gear[item.slot];
  G.hero.gear[item.slot]=item;
  applyGearMaxHPDelta(G.hero,oldGear,item);
  G.forgeStallItem=null;
  addLog(`âš’ Equipped: ${item.name}`,'lheal');
  renderAll();
}
const MYTH_LINES = {
  crit_first: [
    'I mark the flaw; steel yields where I ask.',
    'A clean strike. One branch opens.',
    'I test this line; it rings true.',
    'I do not foretell. I trace what may be.',
    'The cut holds. Continue the pattern.',
    'One notch carved; the work continues.',
  ],
  crit_third: [
    'Three true strikes; the pattern tightens.',
    'I temper this strand in motion.',
    'The structure answers my hand.',
    'The line grows precise under strain.',
    'I carve by increments; this one is sound.',
    'Another branch proves workable.',
  ],
  crit_fifth: [
    'Five true hits; the lattice sings.',
    'I have heat, pressure, and a usable shape.',
    'The knot loosens. What may be expands.',
    'This edge remembers my measure.',
    'A strong sequence. Keep the rhythm.',
    'The craft holds even here at the root.',
  ],

  nearDeath: [
    'The seam splits. I bind it and continue.',
    'Almost broken; not yet unusable.',
    'Under this strain, I learn the weak points.',
    'I keep one ember for what may be.',
    'The pattern frays; I re-knot it.',
    'This thread bends hard, but does not snap.',
  ],
  nearDeathKill: [
    'I answer the crack with force.',
    'Debt pressed close; I cut a path anyway.',
    'A narrow margin, still enough to carve.',
    'I salvage the moment and continue shaping.',
    'The flaw is costly, but instructive.',
    'I keep the thread from cooling out.',
  ],

  kill_first: [
    'One obstacle removed from the pattern.',
    'I clear the surface and keep carving.',
    'A clean reduction. Continue.',
    'This line remains viable.',
    'I mark the cut and move deeper.',
    'The structure opens by one notch.',
  ],
  kill_multi: [
    'Multiple cuts. The branch map simplifies.',
    'I remove noise from the lattice.',
    'Several knots untied in one pass.',
    'The kiln burns hot; I stay methodical.',
    'Good sequence. Keep pressure steady.',
    'More room to shape what may be.',
  ],
  rootDrinks: [
    'The root takes all residue; I keep the form.',
    'What falls is ash; what remains is pattern.',
    'The deep wood drinks; I continue carving.',
    'Loss feeds the dark. I retain the design.',
    'At this depth, every cut has a cost.',
    'The root consumes. I still bind what may be.',
  ],

  levelUp: [
    'I anneal the line and set it stronger.',
    'Another layer tempered into memory.',
    'The strand accepts new structure.',
    'I reinforce the weak seam.',
    'Progress recorded in Minni.',
    'The pattern grows dense and usable.',
  ],

  waveStart: {
    1:  'Trial one. A single generation begins its thread.',
    2:  'Trial two. I test this pattern under load.',
    3:  'Trial three. The sisters watch, but I still carve.',
    4:  'Trial four. Debt gathers in the grain.',
    5:  'Trial five. The roadside fire will judge this line.',
    6:  'Trial six. I keep to structure, not panic.',
    7:  'Trial seven. The root pressure increases.',
    8:  'Trial eight. Few branches remain stable now.',
    9:  'Trial nine. I measure every flaw twice.',
    10: 'Trial ten. The world-decay shows in every strike.',
    11: 'Trial eleven. One test remains after this.',
    12: 'Trial twelve. End this generation without breaking.',
  },

  waveEnd: {
    1:  'First trial finished; Minni holds the mark.',
    3:  'Three trials complete. The thread is still workable.',
    6:  'Six trials tempered. Structure remains.',
    9:  'Nine trials carved. I can still descend.',
    11: 'Eleven trials survived. One final test.',
    12: 'Twelve trials complete. I bind this generation to Minni-HÃ¶ll.',
  },

  axiomPicked: [
    'A rune-gift fitted into the frame.',
    'I choose this branch of what may be.',
    'Useful law. I set it in place.',
    'Another tool for line and load.',
    'I carve this choice into Minni.',
    'The pattern accepts this addition.',
  ],

  retire: [
    'I seal this generation into Minni-HÃ¶ll.',
    'Thread cooled, recorded, and set as stone.',
    'I bind this memory for future tempering.',
    'This line is complete enough to preserve.',
    'I close the ledger and carry the pattern forward.',
    'Workpiece retired; structure retained.',
  ],
  death: [
    'This thread failed under load; I keep the data.',
    'Fracture complete. Record the flaw and continue.',
    'The line broke, but Minni still takes its shape.',
    'Skuld claimed this branch; others remain.',
    'I mark the failure and reforge the next.',
    'Thread lost. Pattern not wasted.',
  ],
  roadside: [
    'I keep the roadside kiln lit between trials.',
    'Water, Clay, Ash â€” choose your treatment.',
    'I offer structure, not comfort.',
    'Every choice here alters what may be.',
    'This fire is where I meet each generation.',
    'Take only what your pattern can bear.',
  ],

  shieldBroke: [
    'The ward cracked; rework immediately.',
    'Outer layer gone. Keep the core intact.',
    'Protection failed. Adapt the structure.',
    'The plating split; hold the line.',
    'A fracture is data. Continue.',
    'The shell is gone; the pattern remains.',
  ],
};

const NarrationEngine = {
  cooldowns: {},
  waveCount: 0,
  WAVE_QUOTA: 5,
  COOLDOWN_TICKS: {
    crit: 80,
    nearDeath: 99999,
    kill: 50,
    levelUp: 99999,
    generic: 40,
  },
  critCount: 0,
  killCount: 0,
  _narratedNearDeath: false,

  reset() {
    this.cooldowns = {};
    this.waveCount = 0;
    this.critCount = 0;
    this.killCount = 0;
    this._narratedNearDeath = false;
    if(G)G._narratedNearDeath=false;
  },

  canFire(category) {
    if (category === 'waveStart' || category === 'waveEnd') return true;
    if (this.waveCount >= this.WAVE_QUOTA) return false;
    const cooldown = this.COOLDOWN_TICKS[category] || 40;
    const lastFired = this.cooldowns[category];
    if (typeof lastFired !== 'number') return true;
    return G ? (G.tick - lastFired) >= cooldown : true;
  },

  fire(category, linesOrLine, logClass) {
    if (!this.canFire(category)) return;
    const line = Array.isArray(linesOrLine) ? rpick(linesOrLine) : linesOrLine;
    if (!line) return;
    this.cooldowns[category] = G ? G.tick : 0;
    if (category !== 'waveStart' && category !== 'waveEnd') this.waveCount++;
    addLog(`  ${line}`, logClass || 'lstatus');
  },

  onCrit() {
    this.critCount++;
    if (this.critCount >= 5) this.fire('crit', MYTH_LINES.crit_fifth, 'lstatus');
    else if (this.critCount >= 3) this.fire('crit', MYTH_LINES.crit_third, 'lstatus');
    else this.fire('crit', MYTH_LINES.crit_first, 'lstatus');
  },

  onKill() {
    this.killCount++;
    if (G && G.tierFlags && G.tierFlags.killDropsMark && this.killCount >= 3) {
      this.fire('kill', MYTH_LINES.rootDrinks, 'lstatus');
    } else if (this.killCount === 1) {
      this.fire('kill', MYTH_LINES.kill_first, 'lstatus');
    } else if (this.killCount >= 4) {
      this.fire('kill', MYTH_LINES.kill_multi, 'lstatus');
    }
  },

  onNearDeath() {
    if (this._narratedNearDeath) return;
    this._narratedNearDeath = true;
    if(G)G._narratedNearDeath=true;
    this.fire('nearDeath', MYTH_LINES.nearDeath, 'lstatus');
  },

  onNearDeathKill() {
    this.fire('generic', MYTH_LINES.nearDeathKill, 'lstatus');
  },
};

// â•â•â• ENEMY ARCHETYPES â•â•â•
const ARCHETYPES = [
  // â”€â”€ MIDGARD TIER (Trials 1â€“3) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    id: 'bruiser',
    displayName: 'Wolf-Warrior',
    norseName: 'ÃšlfheÃ°inn',
    realmTier: 'midgard',
    icon: 'ğŸº', col: '#a03020',
    base: { hp:80, atk:14, def:8, spd:40, cc:.05, cd:1.5 },
    scl:  { hp:28, atk:5,  def:3, spd:2  },
    trait: 'Wolf-Rage',
    td: 'Immune to Slow. Enrages below 35% HP (+5 ATK).',
    beh: 'steady',
    tier2Behavior: 'enrageOnLowHP', tier2Threshold: 0.35, tier2BonusAtk: 5,
  },
  {
    id: 'striker',
    displayName: 'Keen Scout',
    norseName: 'Stormfarer',
    realmTier: 'midgard',
    icon: 'âš¡', col: '#806010',
    base: { hp:48, atk:16, def:4, spd:70, cc:.22, cd:2.0 },
    scl:  { hp:12, atk:6,  def:1, spd:5  },
    trait: 'Keen Edge',
    td: '+25% Crit Chance.',
    beh: 'fast',
    tier2Behavior: 'dodgeAfterCrit', tier2DodgeChance: 0.10,
  },
  {
    id: 'tank',
    displayName: 'Veteran Shield',
    norseName: 'Einherjar',
    realmTier: 'midgard',
    icon: 'ğŸ›¡', col: '#305080',
    base: { hp:120, atk:10, def:22, spd:25, cc:.03, cd:1.5 },
    scl:  { hp:38,  atk:3,  def:3,  spd:1  },
    trait: 'Iron Will',
    td: 'First hit negated. Regains 2% HP on first attack (Tier 2+).',
    beh: 'steady',
    tier2Behavior: 'regenOnFirstAttack', tier2RegenPct: 0.02,
  },
  {
    id: 'archer',
    displayName: 'Runic Archer',
    norseName: "Ullr's Chosen",
    realmTier: 'midgard',
    icon: 'ğŸ¹', col: '#305a6a',
    base: { hp:44, atk:15, def:3, spd:62, cc:.16, cd:1.8 },
    scl:  { hp:14, atk:5,  def:1, spd:3  },
    trait: 'Piercing Shot',
    td: 'Every 4th attack ignores most Defense. Crits may expose Vulnerable.',
    beh: 'fast',
    tier2Behavior: 'exposeCritVuln', tier2ExposeChance: 0.35,
  },
  // â”€â”€ NIFLHEIM / HELHEIM TIER (Trials 4â€“6) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    id: 'swarm',
    displayName: 'Risen Dead',
    norseName: 'Draugr Pack',
    realmTier: 'niflheim',
    icon: 'ğŸ’€', col: '#406020',
    base: { hp:20, atk:8, def:2, spd:62, cc:.05, cd:1.5 },
    scl:  { hp:6,  atk:3, def:1, spd:3  },
    trait: 'Swarming Dead',
    td: 'Spawns in groups of 3. At RagnarÃ¶k Tier 4+, slain members may rise once.',
    beh: 'fast',
    tier2Behavior: null,
  },
  {
    id: 'shaman',
    displayName: 'Curse-Weaver',
    norseName: 'VÃ¶lva',
    realmTier: 'niflheim',
    icon: 'ğŸ”®', col: '#702080',
    base: { hp:58, atk:12, def:6, spd:45, cc:.08, cd:1.5 },
    scl:  { hp:15, atk:4,  def:2, spd:2  },
    trait: 'Curse-Weaving',
    td: 'Every 3rd attack applies Weak. First attack also applies Weak (Tier 2+).',
    beh: 'caster',
    tier2Behavior: 'weakOnFirstAttack',
  },
  {
    id: 'leech',
    displayName: 'Blood-Mage',
    norseName: 'GaldramaÃ°r',
    realmTier: 'helheim',
    icon: 'ğŸ©¸', col: '#402040',
    base: { hp:64, atk:13, def:5, spd:42, cc:.08, cd:1.5 },
    scl:  { hp:18, atk:4,  def:2, spd:2  },
    trait: 'Life-Drain',
    td: 'Heals 30% of damage dealt.',
    beh: 'sustain', ls: .30,
    tier2Behavior: null,
  },
  {
    id: 'warden',
    displayName: 'Barrow-Lord',
    norseName: 'Hersir',
    realmTier: 'helheim',
    icon: 'ğŸ§¿', col: '#5a4a10',
    base: { hp:76, atk:11, def:12, spd:34, cc:.05, cd:1.6 },
    scl:  { hp:22, atk:3,  def:3,  spd:1  },
    trait: 'Death-Banner',
    td: 'Battle start: grants Shield to allies. Every 4th attack applies Weak.',
    beh: 'steady',
    tier2Behavior: null,
  },
  // â”€â”€ JOTUNHEIM TIER (Trials 7â€“9) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    id: 'assassin',
    displayName: 'Shadow-Stalker',
    norseName: 'NÃ­Ã°ing',
    realmTier: 'jotunheim',
    icon: 'ğŸ—¡', col: '#301840',
    base: { hp:38, atk:22, def:3, spd:58, cc:.28, cd:2.2 },
    scl:  { hp:10, atk:8,  def:1, spd:4  },
    trait: 'Dishonored Strike',
    td: 'First attack deals 1.6Ã— damage.',
    beh: 'burst',
    tier2Behavior: 'dodgeAfterCrit', tier2DodgeChance: 0.15,
  },
  {
    id: 'frost',
    displayName: 'Ice-Binder',
    norseName: 'Ãsalfr',
    realmTier: 'jotunheim',
    icon: 'â„ï¸', col: '#204070',
    base: { hp:58, atk:12, def:6, spd:44, cc:.08, cd:1.6 },
    scl:  { hp:16, atk:4,  def:2, spd:2  },
    trait: 'Frostbite',
    td: 'Every 3rd attack applies Slow. Crits may Stun.',
    beh: 'caster',
    tier2Behavior: null,
  },
  // â”€â”€ MUSPELHEIM TIER (Trials 10â€“11) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    id: 'bombardier',
    displayName: 'Rune-Smith',
    norseName: 'Dvergar Forge-Master',
    realmTier: 'muspelheim',
    icon: 'ğŸ’£', col: '#6a4000',
    base: { hp:68, atk:30, def:10, spd:20, cc:.10, cd:2.0 },
    scl:  { hp:20, atk:10, def:3,  spd:1  },
    trait: 'Runic Overcharge',
    td: 'Every 3rd attack deals 2Ã— damage.',
    beh: 'slow',
    tier2Behavior: null,
  },
];

// â•â•â• WAVE TRAITS â•â•â•
const WAVE_TRAITS=[
  {id:'armored',name:'Armored',icon:'ğŸ°',desc:'Enemies gain +25% Defense.',apply(es){es.forEach(e=>e.def=Math.floor(e.def*1.25));}},
  {id:'frenzied',name:'Frenzied',icon:'ğŸ˜¤',desc:'Enemies gain +20% Speed.',apply(es){es.forEach(e=>e.spd=Math.floor(e.spd*1.20));}},
  {id:'toxic_air',name:'Toxic Air',icon:'â˜£',desc:'All units take 1 dmg/sec.',apply(es,h,Gx){Gx.waveFlags.toxicAir=true;}},
  {id:'glass',name:'Reckless Rage',icon:'ğŸ”ª',desc:'Enemies: -25% HP, +30% ATK.',apply(es){es.forEach(e=>{e.hp=e.maxHP=Math.floor(e.hp*.75);e.atk=Math.floor(e.atk*1.30);});}},
  {id:'blessed',name:'Runed',icon:'âœ¨',desc:'Enemies start with 20% HP as Shield.',apply(es){es.forEach(e=>addShieldToUnit(e,Math.floor(e.hp*.20)));}},
  {id:'enraged',name:'Enraged',icon:'ğŸ˜¡',desc:'Enemies gain +15 ATK when ally dies.',apply(es,h,Gx){Gx.waveFlags.enraged=true;}},
  {id:'regenerating',name:'Wound-Knit',icon:'ğŸ’š',desc:'Enemies regen 2% HP/sec.',apply(es,h,Gx){Gx.waveFlags.eRegen=.02;}},
  {id:'elite_wave',name:'Elite',icon:'â­',desc:'One enemy becomes Elite (+65% stats).',apply(es){if(es.length){const e=es[0];e.elite=true;e.hp=e.maxHP=Math.floor(e.hp*1.65);e.atk=Math.floor(e.atk*1.65);e.def=Math.floor(e.def*1.5);e.name='Elite '+e.name;}}},
  {id:'quickened',name:'Quickened',icon:'ğŸ’¨',desc:'Enemies +15% SPD, +10% Crit Chance.',apply(es){es.forEach(e=>{e.spd=Math.floor(e.spd*1.15);e.cc=Math.min(.8,(e.cc||.05)+.10);});}},
  {id:'echo_atk',name:'Echo Barrage',icon:'ğŸ”Š',desc:'Enemies 25% chance to attack twice.',apply(es,h,Gx){Gx.waveFlags.eEcho=true;}},
  {id:'reinforcements',name:'Horde-Call',icon:'ğŸš¨',desc:'+1 additional enemy joins the wave.',apply(es,h,Gx){const cap=(Gx.waveBodyCap||8);if(es.length<cap){const arch=reinforcementArchetypeForWave(Gx.wave);if(arch)es.push(mkEnemy(arch,Gx.wave,false,{isBoss:false}));}}},
  {id:'marked_prey',name:'Marked Prey',icon:'ğŸ¯',desc:'Battle start: hero becomes Vulnerable (3s). Enemies gain +10% Crit Chance.',apply(es,h,Gx){es.forEach(e=>{e.cc=Math.min(.8,(e.cc||.05)+.10);});Gx.waveFlags.heroStartVuln=3;}},
  {id:'echo_wounds',name:'Echo Wounds',icon:'ğŸ©¸',desc:'All DoT damage dealt to enemies is reflected back to the hero at 25%.',apply(es,h,Gx){Gx.waveFlags.echoWounds=true;Gx.waveFlags.echoWoundsPct=0.25;}},
];

const MINOR_WAVE_TRAIT_IDS = ['armored','frenzied','glass','blessed','enraged','regenerating','quickened'];
const MAJOR_WAVE_TRAIT_IDS = ['toxic_air','echo_atk','elite_wave','reinforcements'];
const SPECIAL_WAVE_TRAIT_IDS = ['echo_wounds'];

const TRIAL_CONFIG = {
  1:{slotsMin:2,slotsMax:2,bodyCap:2,minorTraitsMin:0,minorTraitsMax:0,majorTraitsMax:0,allowEliteTrait:false},
  2:{slotsMin:2,slotsMax:2,bodyCap:3,minorTraitsMin:0,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false},
  3:{slotsMin:3,slotsMax:3,bodyCap:3,minorTraitsMin:1,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false},
  4:{slotsMin:2,slotsMax:3,bodyCap:5,minorTraitsMin:1,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false},
  5:{slotsMin:3,slotsMax:3,bodyCap:4,minorTraitsMin:1,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false,maxAnchors:1,forbidWardenSwarm:true},
  6:{slotsMin:3,slotsMax:4,bodyCap:5,minorTraitsMin:0,minorTraitsMax:1,majorTraitsMax:1,allowEliteTrait:false,majorChance:0.25,forbidMajorIds:['echo_atk'],maxAnchors:2,forbidAnchorSwarm:true},
  7:{slotsMin:4,slotsMax:4,bodyCap:6,minorTraitsMin:1,minorTraitsMax:2,majorTraitsMax:1,allowEliteTrait:true,majorChance:0.20},
  8:{slotsMin:2,slotsMax:3,bodyCap:6,minorTraitsMin:0,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false,supportOnlyTraits:true,forbidWardenSwarm:true},
  9:{slotsMin:3,slotsMax:4,bodyCap:5,minorTraitsMin:1,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false,maxAssassins:1,allowRemnantLeech:true},
  10:{slotsMin:4,slotsMax:4,bodyCap:6,minorTraitsMin:1,minorTraitsMax:2,majorTraitsMax:1,allowEliteTrait:true,majorChance:0.35,maxAssassins:1,maxRT:1},
  11:{slotsMin:4,slotsMax:5,bodyCap:7,minorTraitsMin:1,minorTraitsMax:2,majorTraitsMax:1,allowEliteTrait:true,majorChance:0.45,maxAssassins:1,forbidEchoWithAssassin:true},
  12:{slotsMin:3,slotsMax:3,bodyCap:7,minorTraitsMin:2,minorTraitsMax:2,majorTraitsMax:1,allowEliteTrait:false,majorChance:0.30,eitherMajorOrMinors:true,rootKing:true},
};

const TRIAL_POOLS = {
  A:['bruiser','tank','striker','archer'],
  B:['swarm','shaman','leech','warden'],
  C:['assassin','frost','rt_bruiser','rt_shaman','rt_warden','rt_swarm'],
};

function isRTPoolEntry(id){ return typeof id==='string' && id.startsWith('rt_'); }
function baseArchFromPoolEntry(id){ return isRTPoolEntry(id)?id.replace(/^rt_/,''):id; }
function enemyBodiesForPick(id){ return baseArchFromPoolEntry(id)==='swarm'?3:1; }
function trialBlock(wave){ if(wave<=4)return 1; if(wave<=8)return 2; return 3; }
function wavePoolIdsForReinforcement(wave){
  if(wave===4)return TRIAL_POOLS.A;
  if(wave<=3)return TRIAL_POOLS.A;
  if(wave<=8)return TRIAL_POOLS.B;
  if(wave===12)return ['rt_bruiser','rt_shaman','rt_warden','rt_swarm','assassin','frost'];
  const pool=[...TRIAL_POOLS.C];
  if(wave===9)pool.push('leech');
  return pool;
}
function reinforcementArchetypeForWave(wave){
  const ids=wavePoolIdsForReinforcement(wave)||[];
  if(!ids.length)return null;
  const pid=rpick(ids);
  return ARCHETYPES.find(a=>a.id===baseArchFromPoolEntry(pid))||null;
}



function tfSetBool(G,k,val=true){G.tierFlags[k]=!!val;}
function tfFlag(G,k){tfSetBool(G,k,true);}
function tfAdd(G,k,v){G.tierFlags[k]=(G.tierFlags[k]||0)+v;}
function tfMul(G,k,m){G.tierFlags[k]=(typeof G.tierFlags[k]==='number'?G.tierFlags[k]:1)*m;}
function tfMax(G,k,v){G.tierFlags[k]=Math.max((G.tierFlags[k]||0),v);}
function tfMin(G,k,v){G.tierFlags[k]=Math.min((typeof G.tierFlags[k]==='number'?G.tierFlags[k]:v),v);}

const RAGNARÃ–K_TIERS = [
  {tier:1,name:'Fimbulwinter Begins',omen:'The first winter without summer settles over every road.',revealStage:'fimbulwinter',apply(G){tfAdd(G,'heroPermanentSPDPenalty',5);tfMul(G,'enemyHPMult',1.10);}},
  {tier:2,name:'Fimbulwinter Deepens',omen:'Oaths crack in the cold; rage and panic come sooner.',revealStage:'none',apply(G){tfSetBool(G,'allowAggroTraitsInBlock1');}},
  {tier:3,name:'Third Winter / Fenrirâ€™s Chain Weakens',omen:'Gleipnir strains. The old constraints no longer hold.',revealStage:'fenrir',apply(G){tfSetBool(G,'archetypeBehaviors');}},
  {tier:4,name:'Fenrir Breaks Free',omen:'The wolf runs. The dead rise before they cool.',revealStage:'fenrir',apply(G){tfMax(G,'draugrEchoChance',0.15);tfSetBool(G,'eliteSecondPhase');}},
  {tier:5,name:'JÃ¶rmungandr Rises',omen:'Venom rides the wind as the serpent coils around the world.',revealStage:'eitr',apply(G){tfMax(G,'toxicAirFromWave',5);tfMax(G,'toxicAirDmg',1);tfMax(G,'dotDamageBonus',0.10);tfSetBool(G,'bossSignatureAbility');}},
  {tier:6,name:'Naglfar Sets Sail',omen:'The corpse-ship reaches shore; every wave brings more bodies.',revealStage:'indirect',apply(G){tfAdd(G,'enemyMaxSlotsBonus',1);tfAdd(G,'enemyBodyCapBonus',1);tfSetBool(G,'allowHordeCall');}},
  {tier:7,name:'Loki Breaks Free',omen:'Bargains turn barbed. Every choice has a hook.',revealStage:'indirect',apply(G){tfSetBool(G,'cursedBargainInShop');tfMax(G,'rerollCostIncreaseOverride',4);}},
  {tier:8,name:'Surtr Marches / BifrÃ¶st Shatters',omen:'Fire crosses broken bridges. Even the first step burns.',revealStage:'surtr',apply(G){tfMax(G,'muspelheimTagFromWave',1);tfMax(G,'emberSparkChance',0.20);tfAdd(G,'startingGoldReduction',8);}},
  {tier:9,name:'Gods Summon the Einherjar',omen:'Gjallarhorn sounds. The remembered dead answer.',revealStage:'indirect',apply(G){tfSetBool(G,'namedElitesActive');tfMax(G,'killDropsMark',1);}},
  {tier:10,name:'VÃ­grÃ­Ã°r: Plain of Battle',omen:'All roads lead to open war. Nothing waits its turn.',revealStage:'indirect',apply(G){tfSetBool(G,'elitesOnAnyWave');tfAdd(G,'heroSPDBonus',8);tfMul(G,'enemySPDMult',1.05);}},
  {tier:11,name:'The Gods Fall',omen:'No guardians remain. Endurance must come from within.',revealStage:'indirect',apply(G){tfAdd(G,'heroPermanentSPDPenalty',8);tfSetBool(G,'allWavesNiflheimTag');tfMax(G,'regenBoonBonus',0.40);tfMax(G,'lifestealBoonBonus',0.15);}},
  {tier:12,name:'Surtr Burns the Nine Realms',omen:'Ash and venom mix. Corruption descends in sheets.',revealStage:'surtr',apply(G){tfMax(G,'rootTouchedEnemyChance',0.45);tfMax(G,'enemyWaveScaleBonus',1);tfAdd(G,'startingGoldReduction',5);tfMax(G,'toxicAirDmg',2);tfMax(G,'dotDamageBonus',0.20);}},
  {tier:13,name:'NÃ­Ã°hÃ¶ggr Ascends',omen:'The Gnawer rises from below; rot is now the atmosphere.',revealStage:'nidhoggr',apply(G){tfMax(G,'toxicAirFromWave',1);tfMax(G,'toxicAirDmg',2);tfMax(G,'dotDamageBonus',0.30);tfMax(G,'rootTouchedEnemyChance',0.60);tfMax(G,'rootTouchedStatMult',1.20);tfSetBool(G,'guaranteeNamedEliteReturns');}},
  {tier:14,name:'The Binding',omen:'Victory is not clean now. You bind collapse into pattern.',revealStage:'indirect',apply(G){tfMul(G,'enemySPDMult',1.20);tfAdd(G,'heroSPDBonus',10);tfAdd(G,'startingGoldReduction',3);}},
  {tier:15,name:'The Rune of What May Be',omen:'At the deepest root, possibility is carved into law.',revealStage:'nidhoggr',apply(G){tfMax(G,'enemyWaveScaleBonus',2);tfSetBool(G,'allFatherLastGift');}},
];


// â•â•â• META PERSISTENT STATE â•â•â•
const META_KEY='axiom_meta_v3';
let META={
  legacyEssence:0,
  salvage:0,
  retiredPool:[],
  fallenLedger:[],
  family:{},
  upgrades:{evCap:0,imprintChance:0,poolSize:0,mutationRate:0,nursery:0},
  unlockedTraits:new Set(['serrated','aegis','skirmisher','venomkiss','gambler','spite','ironblood','swift_born','lucky','resilient']),
  nextHeroId:1,
  ragnarÃ¶kTier:0,
  ragnarÃ¶kActive:0,
  eliteRoster:{},
  relics:0,
  scarTokens:{},
  lineageScarPool:[],
  hasSeenOpening:false,
  houseName:null,
  codexUnlocked:['weaver','minni','yggdrasil','allfather','valhalla','saga','rune','norns'],
  codexView:'lore',
  bindingCounter:0,
};

function saveMeta(){
  const m={...META,unlockedTraits:[...META.unlockedTraits]};
  try{localStorage.setItem(META_KEY,JSON.stringify(m));}catch(e){}
}
function loadMeta(){
  try{
    const raw=localStorage.getItem(META_KEY);
    if(!raw)return;
    const m=JSON.parse(raw);
    META={...META,...m};
    META.unlockedTraits=new Set(m.unlockedTraits||[]);
    if(typeof META.ragnarÃ¶kTier!=='number')META.ragnarÃ¶kTier=0;
    if(typeof META.ragnarÃ¶kActive!=='number')META.ragnarÃ¶kActive=0;
    if(!META.eliteRoster||typeof META.eliteRoster!=='object')META.eliteRoster={};
    if(typeof META.relics!=='number')META.relics=0;
    if(typeof META.hasSeenOpening!=='boolean')META.hasSeenOpening=false;
    if(!META.codexUnlocked||!Array.isArray(META.codexUnlocked))META.codexUnlocked=['yggdrasil','allfather','valhalla','saga','rune','norns'];
    if(META.codexView!=='balance')META.codexView='lore';
    if(typeof META.bindingCounter!=='number')META.bindingCounter=0;
  }catch(e){}
}
function exportSave(){
  const m={...META,unlockedTraits:[...META.unlockedTraits]};
  return btoa(JSON.stringify(m));
}
function importSave(str){
  try{const m=JSON.parse(atob(str));META={...META,...m};META.unlockedTraits=new Set(m.unlockedTraits||[]);saveMeta();return true;}
  catch(e){return false;}
}
function poolMax(){return 6+(META.upgrades.poolSize||0)*2;}

// â”€â”€â”€ BREED USES (fertility) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getBreedUses(rec){
  if(!rec) return {left:0,max:0};
  const isRet = META && Array.isArray(META.retiredPool) ? META.retiredPool.includes(rec.id) : false;
  const retiredLike = !!(rec.runResult && (rec.runResult.outcome==='retired' || rec.runResult.outcome==='victory'));
  const fallbackMax = (isRet || retiredLike) ? 1 : 0;
  const mx = (typeof rec.breedUsesMax==='number' && rec.breedUsesMax>0) ? rec.breedUsesMax : fallbackMax;
  const lf = (typeof rec.breedUsesLeft==='number') ? rec.breedUsesLeft : mx;
  return {left:Math.max(0,lf), max:Math.max(0,mx)};
}
function assignBreedUses(rec,max){
  if(!rec) return;
  const m = Math.max(0,Math.min(2,Math.floor(max)));
  rec.breedUsesMax = m;
  rec.breedUsesLeft = m;
}
function calcBreedUsesForRetire(){
  // 1 or 2 uses; later waves slightly increase chance of 2
  const w = (G && typeof G.wave==='number') ? G.wave : 1;
  if(G && G.phase==='VICTORY') return 2;
  let p2 = 0.25 + Math.min(0.25, Math.max(0, (w-4))*0.04); // 25% â†’ up to 50%
  p2 += (META.upgrades.nursery||0)*0.15;
  p2 = Math.min(0.85, Math.max(0.05, p2));
  return (rng() < p2) ? 2 : 1;
}
function removeFromRetiredPoolById(id){
  META.retiredPool = META.retiredPool.filter(x=>x!==id);
  const i = BREED_SELECTED.indexOf(id);
  if(i>=0) BREED_SELECTED.splice(i,1);
}
function removeFromRetiredPool(evt,id){
  if(evt){evt.stopPropagation();evt.preventDefault();}
  removeFromRetiredPoolById(id);
  saveMeta();
  if(typeof setLegacyTab==='function') setLegacyTab('pool');
}
function consumeBreedUse(id){
  const rec = META.family[id];
  if(!rec) return;
  const u = getBreedUses(rec);
  rec.breedUsesMax = u.max;
  rec.breedUsesLeft = Math.max(0, u.left-1);
  if(rec.breedUsesLeft<=0){
    removeFromRetiredPoolById(id);
  }
}

function isFallenHero(id){
  return !!(META && Array.isArray(META.fallenLedger) && META.fallenLedger.includes(id));
}
function canHeroBreed(id){
  const rec = META && META.family ? META.family[id] : null;
  return !!(rec && !isFallenHero(id) && getBreedUses(rec).left>0);
}

// â•â•â• HERO RECORD â•â•â•
function mkHeroId(){return 'H'+(META.nextHeroId++);}
function mkHeroRecord(name,gen,parentIds,evs,traits){
  return {id:mkHeroId(),name,gen,parentIds:parentIds||[],evs:{...evs},traits:[...traits],runResult:null,breedUsesMax:0,breedUsesLeft:0};
}

// â•â•â• NAME GENERATION â•â•â•
const NAME_PREFIXES=['Hrafn', 'Skjold', 'Eirik', 'Sigr', 'Bjorn', 'Ulf', 'Astrid', 'Freya', 'Thora', 'Odin', 'Vidar', 'Helga', 'Runa', 'Frost', 'Skadi', 'Leif', 'Dag', 'Inga', 'Yng', 'Kari', 'Tor', 'Gunn', 'Rolf', 'Hild', 'Aske'];
const NAME_SUFFIXES=['son', 'dottir', 'skald', 'bjorn', 'ulf', 'hild', 'gard', 'heim', 'rune', 'brand', 'vald', 'grim', 'bane', 'born', 'mark', 'ward', 'frost', 'storm', 'spear', 'shield'];
const EPITHETS={Bleed:'the Bloodmarked',Poison:'the Serpent-Touched',Crit:'the Keen-Eyed',Tempo:'the Stormswift',Bulwark:'the Shieldbound',Arcane:'the Seer',Thorns:'the Thorned',Execute:'the Wolf-Sworn',Sustain:'the Iron-Hearted',Axiom:'the Runebound'};
function genName(gen,topTag,parentNames){
  if(gen===0)return rpick(NAME_PREFIXES)+''+rpick(NAME_SUFFIXES);
  const ep=EPITHETS[topTag]||'the Ascendant';
  const base=parentNames&&parentNames[0]?parentNames[0].split(' ')[0]:rpick(NAME_PREFIXES);
  return `${base} ${ep}`;
}

// Echo Binding chance
function imprintChance(){return Math.min(.75,.15+(META.upgrades.imprintChance||0)*.15);}
// Mutation chance
function mutationRate(){return Math.min(.20,.04+(META.upgrades.mutationRate||0)*.03);}

// â•â•â• GAME STATE â•â•â•
let G=null;

// UI state
const UI_KEY='axiom_ui_v1';
let UI={logCollapsed:false,difficulty:1};
function loadUI(){try{const r=localStorage.getItem(UI_KEY);if(r)UI={...UI,...JSON.parse(r)};}catch(e){}}
function saveUI(){try{localStorage.setItem(UI_KEY,JSON.stringify(UI));}catch(e){}}

function clampNum(v,min,max){
  const n=Number(v);
  if(Number.isNaN(n))return min;
  return Math.max(min,Math.min(max,n));
}
function currentDifficulty(){
  if(G && typeof G.difficulty==='number')return G.difficulty;
  return (typeof UI.difficulty==='number')?UI.difficulty:1;
}
function setDifficulty(v){
  UI.difficulty=clampNum(v,0,2);
  saveUI();
  updateDifficultyUI();
}
function onDifficultyInput(v,src){
  // src is optional ('start' when called from start overlay)
  setDifficulty(v);
  const sv=document.getElementById('start-diff-val');
  if(sv)sv.textContent='x'+Number(UI.difficulty??1).toFixed(1);
}
function updateDifficultyUI(){
  const d=currentDifficulty();
  const s=document.getElementById('diff-slider');
  const v=document.getElementById('diff-val');
  if(v)v.textContent='x'+Number(d).toFixed(1);
  if(s){
    s.value=Number(d);
    // lock during an active run (keeps difficulty consistent)
    s.disabled=!!G;
    s.style.opacity=s.disabled?0.7:1;
  }
  const sd=document.getElementById('start-diff');
  if(sd){
    sd.value=Number(UI.difficulty??1);
    const sv=document.getElementById('start-diff-val');
    if(sv)sv.textContent='x'+Number(UI.difficulty??1).toFixed(1);
  }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TACTICS (pre-wave prep; cost paid when you start the trial)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TACTICS=[
  {id:'t_focus_threat',  name:'Mark: Strongest',   icon:'ğŸ¯', cost:9, kind:'target', mode:'threat', desc:'Hero targets the highest ATK enemy first.'},
  {id:'t_focus_wounded', name:'Mark: Broken',  icon:'ğŸ©¸', cost:12, kind:'target', mode:'wounded', desc:'Hero targets the lowest HP% enemy first.'},
  {id:'t_fortify',       name:'Fortify',         icon:'ğŸ›¡', cost:11, kind:'start',  desc:'+30 Shield and Regen for 8s at battle start.'},
  {id:'t_ambush',        name:'Ambush',          icon:'ğŸ—¡', cost:11, kind:'start',  desc:'Your first attack deals double damage and ignores 30% DEF.'},
  {id:'t_sabotage',      name:'Weaken',        icon:'ğŸ§¨', cost:12, kind:'start',  desc:'Enemies start with -15% Defense.'},
  {id:'t_flare',         name:'Expose',           icon:'ğŸ”¥', cost:12, kind:'start',  desc:'Enemies start Vulnerable for 3s.'},
  {id:'t_greed',         name:'Greed',           icon:'ğŸª™', cost:5,  kind:'econ',   desc:'+20% Saga-Marks for this trial.'},
];
const TACTIC_BY_ID=Object.fromEntries(TACTICS.map(t=>[t.id,t]));

const RESOLVE_RELICS=[
  {id:'root_cup',name:'Resolve: The Root-Cup',icon:'ğŸ’š',desc:'Your stolen mercy becomes arithmetic.',mults:{lifesteal:2.0}},
  {id:'wolf_step',name:'Resolve: The Wolf-Step',icon:'âš¡',desc:'When momentum starts, it does not apologize.',mults:{tempoStacks:2.0}},
  {id:'fired_ward',name:'Resolve: The Fired Ward',icon:'ğŸ›¡',desc:'The first breath of battle meets a wall.',mults:{battleStartShield:2.0,shieldGain:1.5}},
  {id:'carvers_edge',name:"Resolve: The Carver's Edge",icon:'ğŸ©¸',desc:'Wounds remember what words cannot.',mults:{bleedStacks:2.0}},
  {id:'eitr_kiln',name:'Resolve: The Eitr Kiln-Vial',icon:'â˜ ï¸',desc:"The root's poison becomes your ink.",mults:{poisonStacks:2.0}},
  {id:'sootglass_eye',name:'Resolve: The Sootglass Eye',icon:'ğŸ—¡',desc:'A clearer strike, paid for in heat.',mults:{critDmg:1.5}},
];
const DEBTS=[
  {id:'skuld_mark',name:"Debt: Skuld's Mark",icon:'ğŸ¯',desc:'The future notices you first.',battleStart:[{st:'vulnerable',sk:1,dur:3}],apply(){}},
  {id:'frost_lungs',name:'Debt: Frost in the Lungs',icon:'â„ï¸',desc:'Cold takes the first breath.',battleStart:[{st:'slow',sk:1,dur:3}],apply(){}},
  {id:'ashen_breath',name:'Debt: Ashen Breath',icon:'ğŸ’”',desc:'Speech turns to cinders.',battleStart:[{st:'weak',sk:1,dur:3}],apply(){}},
  {id:'short_thread',name:'Debt: Shortened Thread',icon:'ğŸ§µ',desc:'Your span tightens.',apply(G){G.hero.maxHP=Math.max(1,Math.floor(G.hero.maxHP*0.90));G.hero.hp=Math.min(G.hero.hp,G.hero.maxHP);}},
  {id:'cracked_mail',name:'Debt: Cracked Mail',icon:'ğŸª¨',desc:'Armor remembers every strike.',apply(G){G.hero.def=Math.max(0,G.hero.def-10);}},
  {id:'trembling_hands',name:'Debt: Trembling Hands',icon:'ğŸ«³',desc:'Your edge wavers.',apply(G){G.hero.critChance=Math.max(0,G.hero.critChance-0.05);}},
  {id:'clouded_sight',name:'Debt: Clouded Sight',icon:'ğŸŒ«',desc:'The world blurs at the edges.',apply(G){G.hero.accuracy=Math.max(0.10,G.hero.accuracy-0.08);}},
  {id:'frayed_step',name:'Debt: Frayed Step',icon:'ğŸŒ',desc:'Your stride shortens.',apply(G){G.hero.spd=Math.max(1,G.hero.spd-12);}},
  {id:'bitter_fang',name:'Debt: Bitter Fang',icon:'â˜ ï¸',desc:'Poison comes first.',battleStart:[{st:'poison',sk:1,dur:4}],apply(){}},
  {id:'root_wound',name:'Debt: Root-Wound',icon:'ğŸ©¸',desc:'The root keeps score.',battleStart:[{st:'bleed',sk:1,dur:3}],apply(){}},
];
function rmult(k){return (G&&G.roadside&&G.roadside.resolveMult&&G.roadside.resolveMult[k])||1.0;}

const BOSS_SIGNATURES={
  bruiser:{
    name:'Serpent Surge',
    desc:'Every 4th attack deals true damage equal to 15% of hero max HP.',
    apply(enemy,h){
      enemy._sigCtr=(enemy._sigCtr||0)+1;
      if(enemy._sigCtr%4===0){
        const trueDmg=Math.floor(h.maxHP*0.15);
        heroDmg(trueDmg,enemy,'true');
        addLog(`  â­ ${enemy.displayName||enemy.name} â€” Serpent Surge! ${trueDmg} true damage!`,'lcrit');
      }
    }
  },
  tank:{
    name:'Unyielding Skjald',
    desc:'Below 50% HP, gains 15 Shield per attack received.',
    apply(enemy){
      if(enemy.hp<enemy.maxHP*0.5){
        addShieldToUnit(enemy,15);
      }
    }
  },
  bombardier:{
    name:'Rune Surge',
    desc:'Every 3rd attack applies Vulnerable to the hero (3s) if not already active.',
    apply(enemy,h){
      enemy._sigCtr=(enemy._sigCtr||0)+1;
      if(enemy._sigCtr%3===0){
        const hasVuln=!!(h.statuses&&h.statuses.vulnerable&&h.statuses.vulnerable.dur>0);
        if(!hasVuln){
          applyStatus(h,'vulnerable',1,3);
          addLog(`  â­ ${enemy.displayName||enemy.name} â€” Rune Surge! Vulnerable.`,'lstatus');
        }
      }
    }
  },
  _default:{
    name:'Root-Power',
    desc:'Gains +3 ATK per enemy slain this trial.',
    apply(){/* handled via wave flags */}
  },
};

const CURSED_BARGAINS=[
  {
    id:'cb_blood_price',name:'Blood Price',icon:'ğŸ©¸',
    desc:'+30 ATK for this saga. Hero takes +8% damage permanently.',
    cost:25,
    apply(G){
      G.hero.atk+=30;
      G.hero.cursedMult=(G.hero.cursedMult||1.0)*1.08;
      addLog('âš  Blood Price accepted. Power costs something.','laxiom');
    }
  },
  {
    id:'cb_glass_soul',name:'Glass Heart',icon:'ğŸ’',
    desc:'+25% Crit Chance. Evasion set to 0 permanently.',
    cost:30,
    apply(G){
      G.hero.critChance=Math.min(0.9,G.hero.critChance+0.25);
      G.hero.evasion=0;
      addLog('âš  Glass Heart accepted. Fortune without flinching.','laxiom');
    }
  },
  {
    id:'cb_norn_debt',name:"Norn's Debt",icon:'ğŸŒ€',
    desc:'Gain 50 Saga-Marks now. End-of-trial Saga-Marks reduced by 20%.',
    cost:0,isFree:true,
    apply(G){
      G.gold+=50;
      G.waveGoldMult=(G.waveGoldMult||1.0)*0.80;
      G.hero._nornDebt=true;
      addLog("âš  Norn's Debt accepted. The weavers remember.",'laxiom');
    }
  },
  {
    id:'cb_iron_hunger',name:'Iron Hunger',icon:'âš™',
    desc:'+20 DEF. Lifesteal reduced to 0.',
    cost:20,
    apply(G){
      G.hero.def+=20;
      G.hero.lifesteal=0;
      addLog('âš  Iron Hunger accepted. Defense before all else.','laxiom');
    }
  },
];

function takeCursedBargain(id){
  const bargain=CURSED_BARGAINS.find(b=>b.id===id);
  if(!bargain)return;
  if(!bargain.isFree&&G.gold<bargain.cost)return;
  if(!bargain.isFree)G.gold-=bargain.cost;
  bargain.apply(G);
  G.cursedBargainUsedThisWave=true;
  G._waveBargainOffer=null;
  renderAll();
}

function genTacticOffers(){
  // 3 random options each wave (keeps the loop fresh without hiding the core shop)
  const pool=[...TACTICS];
  G.tacticOffers=rshuffle(pool).slice(0,3);
}
function selectPendingTactic(id){
  const t=TACTIC_BY_ID[id];
  if(!t) return;
  G.pendingTactic=id;
  G.pendingTacticPaid=false;
  addLog(`ğŸ§  Planned tactic: ${t.icon} ${t.name} (cost á›‹${t.cost} on start)`,'lstatus');
  renderAll();
}
function clearPendingTactic(){
  G.pendingTactic=null;G.pendingTacticPaid=false;
  renderAll();
}
function commitPendingTactic(){
  // called when starting a wave (charges gold once)
  G.activeTactic=null;
  G.waveGoldMult=1;
  if(!G.pendingTactic) return true;
  const t=TACTIC_BY_ID[G.pendingTactic];
  if(!t){G.pendingTactic=null;G.pendingTacticPaid=false;return true;}
  if(!G.pendingTacticPaid){
    if(G.gold < t.cost){
      addLog(`á›‹${t.cost} required to use tactic: ${t.icon} ${t.name}`,'lstatus');
      return false;
    }
    G.gold -= t.cost;
    G.pendingTacticPaid=true;
    addLog(`ğŸ§  Tactic engaged: ${t.icon} ${t.name} (á›‹${t.cost})`,'laxiom');
  }
  G.activeTactic=G.pendingTactic;
  G.pendingTactic=null;
  G.pendingTacticPaid=false;
  return true;
}
function applyBattleStartTactics(){
  const t=TACTIC_BY_ID[G.activeTactic];
  if(!t) return;
  const h=G.hero;
  if(t.id==='t_fortify'){
    addShieldToUnit(h,30);
    h.statuses.regen={stacks:1,value:6,dur:8};
    addLog(`  ğŸ›¡ Fortify: +30 Shield, Regen (8s)`,'lstatus');
  } else if(t.id==='t_ambush'){
    h.flags.tacticAmbush=true;
    h.flags.tacticAmbushDefPen=0.30;
    addLog(`  ğŸ—¡ Ambush: first strike empowered`,'lstatus');
  } else if(t.id==='t_sabotage'){
    G.enemies.filter(e=>!e.dead).forEach(e=>{e.def=Math.max(0,Math.floor(e.def*0.85));});
    addLog(`  ğŸ§¨ Weaken: enemies DEF reduced`,'lstatus');
  } else if(t.id==='t_flare'){
    G.enemies.filter(e=>!e.dead).forEach(e=>applyStatus(e,'vulnerable',1,3));
    addLog(`  ğŸ”¥ Expose: enemies Vulnerable (3s)`,'lstatus');
  } else if(t.id==='t_greed'){
    G.waveGoldMult=1.20;
    addLog(`  ğŸª™ Greed: +20% Saga-Marks this trial`,'lstatus');
  }
}
function tacticTargetMode(){
  const t=TACTIC_BY_ID[G.activeTactic];
  return (t && t.kind==='target') ? t.mode : null;
}


function newHero(evs,traits,record){
  const derived=evDerived(evs);
  const h={
    ...derived,
    hp:derived.maxHP,
    statuses:{},actionMeter:0,atkCount:0,
    tempStats:{},permStats:{},flags:{},
    usedUndying:false,
    evs:{...evs},
    traits:[...traits],
    record:record||null,
    gear:{weapon:null,armor:null,talisman:null},
  };
  if(record&&record.inheritedGear)Object.assign(h.gear,record.inheritedGear);
  applyPatternTraitStats(h);
  applyAllGearMaxHP(h);
  applyHouseBlessingsToHero(h);
  return h;
}
function applyPatternTraitStats(h){
  for(const tk of (h.traits||[])){
    if(tk==='ironblood')h.def+=5;
    if(tk==='swift_born')h.spd+=8;
    if(tk==='lucky')h.critChance=Math.min(.9,h.critChance+.04);
    if(tk==='resilient'){h.maxHP+=25;h.hp=h.maxHP;}
    if(tk==='gambler'){h.critChance=Math.min(.9,h.critChance+.05);h.def=Math.max(0,h.def-2);}
    if(tk==='vampiric_b')h.lifesteal=Math.min(.4,h.lifesteal+.03);
  }
}

function initGame(seedVal,evs,traits,parentRecord){
  seedRng(seedVal||Date.now());
  const rec=parentRecord||mkHeroRecord(genName(0,null,null),0,[],evs||emptyEVs(),traits||[]);
  G={
    phase:'WAVE_PREVIEW',
    difficulty:(typeof UI.difficulty==='number'?UI.difficulty:1),
    hero:newHero(evs||emptyEVs(),traits||[],rec),
    wave:1,maxWaves:12,
    gold:30,xp:0,xpNeeded:80,level:1,
    boons:[],draft:[],rerollCost:10,
    enemies:[],waveTraits:[],waveFlags:{},waveGold:0,
    bossWaves:[8,12],
    speed:1,tick:0,interval:null,statusTick:0,
    seed:seedVal,
    retireAvailable:false,
    retireWaves:[],
    runBoons:[],
    pendingTactic:null,pendingTacticPaid:false,activeTactic:null,tacticOffers:[],waveGoldMult:1,
    ragnarÃ¶kActive:META.ragnarÃ¶kActive||0,
    tierFlags:{},
    forgeStallItem:null,
    roadside:{used:{5:false,9:false},resolveRelics:[],debts:[],goldMult:1.0,essenceMult:1.0,resolveMult:{lifesteal:1.0,tempoStacks:1.0,battleStartShield:1.0,shieldGain:1.0,bleedStacks:1.0,poisonStacks:1.0,critDmg:1.0}},
    roadsideAvailable:false,
  };
  updateMetaHeader();
  applyRagnarÃ¶kTiers(G);
  genWave();
  renderAll();
  updateDifficultyUI();
}

// Stub â€” fully implemented in Prompt 6
function applyRagnarÃ¶kTiers(G) {
  G.tierFlags = {
    enemyHPMult:1,
    enemySPDMult:1,
    rootTouchedStatMult:1.10,
    toxicAirDmg:1,
  };
  const activeTier = G.ragnarÃ¶kActive || 0;
  for (let i = 0; i < activeTier && i < RAGNARÃ–K_TIERS.length; i++) {
    const tierDef = RAGNARÃ–K_TIERS[i];
    if (tierDef && typeof tierDef.apply === 'function') tierDef.apply(G);
  }

  if (G.tierFlags.startingGoldReduction) G.gold = Math.max(0, G.gold - G.tierFlags.startingGoldReduction);
  if (G.tierFlags.heroPermanentSPDPenalty && G.hero) G.hero.spd = Math.max(5, G.hero.spd - G.tierFlags.heroPermanentSPDPenalty);
  if (G.tierFlags.heroSPDBonus && G.hero) G.hero.spd += G.tierFlags.heroSPDBonus;
}

function checkRagnarÃ¶kUnlock() {
  if (!G) return;
  const currentActive = G.ragnarÃ¶kActive || 0;
  const currentUnlocked = META.ragnarÃ¶kTier || 0;
  if (currentActive < currentUnlocked) return;

  const isVictory = (G.phase === 'VICTORY');
  const isFullClear = isVictory && (typeof G.maxWaves === 'number') && (G.wave >= G.maxWaves);
  if (!isFullClear) return;

  const newTier = Math.min(15, currentUnlocked + 1);
  if (newTier <= currentUnlocked) return;

  META.ragnarÃ¶kTier = newTier;
  if (G.hero && G.hero.record) {
    G.hero.record.ragnarÃ¶kStamp = newTier;
  }
  saveMeta();
  addLog(`áš¢ RagnarÃ¶k Tier Unlocked: ${newTier}`, 'laxiom');
}


function startFirstHero(seedVal){
  normalizeMeta();
  const rec=mkHeroRecord(genName(0,null,null),0,[],emptyEVs(),[]);
  let inheritedScar=null;
  if((rec.traits||[]).length===0 && META.lineageScarPool.length && rng()<LINEAGE_SCAR_INHERIT_CHANCE){
    inheritedScar=rpick(META.lineageScarPool);
    if(inheritedScar)rec.traits=[inheritedScar];
  }
  META.family[rec.id]=rec;
  saveMeta();
  initGame(seedVal||null,emptyEVs(),[],rec);
  if(inheritedScar)addLog(`Lineage Memory: inherited scar â€” ${GTRAITS[inheritedScar]?.name||inheritedScar}.`,'laxiom');
}

// â•â•â• WAVE GENERATION â•â•â•
function genWave(){
  G.enemies=buildEnemies(G.wave);
  G.waveTraits=pickWaveTraitsByTrial(G.wave);
  G.waveFlags={};G.waveGold=0;
  G.waveGoldMult=1;
  G.activeTactic=null;
  G.cursedBargainUsedThisWave=false;
  G._waveBargainOffer=null;
  G.pendingTactic=null;
  G.pendingTacticPaid=false;
  G.waveFlags.rootKingRevive=(G.wave===12);
  genTacticOffers();
  G.retireAvailable=false;
  G.roadsideAvailable=!!(G.phase!=='GAME_OVER'&&(G.wave===5||G.wave===9)&&!(G.roadside&&G.roadside.used&&G.roadside.used[G.wave]));
  G.phase='WAVE_PREVIEW';
}
function buildEnemies(wave){
  const cfg=TRIAL_CONFIG[wave]||{slotsMin:3,slotsMax:4,bodyCap:8};
  const effSlotsMin=cfg.slotsMin;
  const effSlotsMax=cfg.slotsMax + ((G.tierFlags&&G.tierFlags.enemyMaxSlotsBonus)||0);
  const effBodyCap=(cfg.bodyCap||8) + ((G.tierFlags&&G.tierFlags.enemyBodyCapBonus)||0);
  const bossWave=(wave===8||wave===12);
  const pickBodyCap=Math.max(0, effBodyCap - (bossWave ? 1 : 0));
  G.waveBodyCap=effBodyCap;
  const out=[]; const picks=[];
  const counts={anchors:0,assassin:0,rt:0,hasWarden:false,hasSwarm:false};

  const markPick=(pid)=>{
    const base=baseArchFromPoolEntry(pid);
    if(base==='warden'||base==='shaman')counts.anchors++;
    if(base==='assassin')counts.assassin++;
    if(isRTPoolEntry(pid))counts.rt++;
    if(base==='warden')counts.hasWarden=true;
    if(base==='swarm')counts.hasSwarm=true;
  };
  const canPick=(pid)=>{
    const base=baseArchFromPoolEntry(pid);
    const projected=picks.reduce((a,p)=>a+enemyBodiesForPick(p),0)+enemyBodiesForPick(pid);
    if(projected>pickBodyCap)return false;
    if(cfg.maxAnchors!=null&&(base==='warden'||base==='shaman')&&counts.anchors>=cfg.maxAnchors)return false;
    if(base==='assassin'&&counts.assassin>=1)return false;
    if(cfg.maxAssassins!=null&&base==='assassin'&&counts.assassin>=cfg.maxAssassins)return false;
    if(cfg.maxRT!=null&&isRTPoolEntry(pid)&&counts.rt>=cfg.maxRT)return false;
    if((cfg.forbidAnchorSwarm||cfg.forbidWardenSwarm)&&((base==='swarm'&&counts.hasWarden)||(base==='warden'&&counts.hasSwarm)))return false;
    return true;
  };

  if(wave===8){
    const bossArch=ARCHETYPES.find(a=>a.id==='bombardier');
    const boss=mkEnemy(bossArch,wave,true,{isBoss:true});
    if(G.tierFlags&&G.tierFlags.bossSignatureAbility)boss.signature=BOSS_SIGNATURES[bossArch.id]||BOSS_SIGNATURES._default;
    out.push(boss);
  }
  if(wave===12){
    const bossArch=ARCHETYPES.find(a=>a.id==='warden');
    const boss=mkEnemy(bossArch,wave,true,{isBoss:true,forceRootTouched:true});
    boss.displayName='Root-King '+boss.displayName; boss.name=boss.displayName;
    if(G.tierFlags&&G.tierFlags.bossSignatureAbility)boss.signature=BOSS_SIGNATURES[bossArch.id]||BOSS_SIGNATURES._default;
    out.push(boss);
  }

  const fill=(pool,slots,maxAttempts=120)=>{let a=0;while(picks.length<slots&&a<maxAttempts){a++;const pid=rpick(pool);if(!canPick(pid))continue;picks.push(pid);markPick(pid);}};

  if(wave>=1&&wave<=3){ fill(TRIAL_POOLS.A,ri(effSlotsMin,effSlotsMax),80); }
  else if(wave===4){
    if(canPick('swarm')){picks.push('swarm');markPick('swarm');}
    const slots=ri(effSlotsMin,effSlotsMax);
    let a=0;
    while(picks.length<slots&&a<90){
      a++;
      let pid=rpick(TRIAL_POOLS.A);
      if(!canPick(pid))continue;
      picks.push(pid);markPick(pid);
    }
  }else if(wave>=5&&wave<=7){ fill(TRIAL_POOLS.B,ri(effSlotsMin,effSlotsMax),120); }
  else if(wave===8){ fill(TRIAL_POOLS.B,ri(effSlotsMin,effSlotsMax),140); }
  else if(wave>=9&&wave<=11){ const pool=[...TRIAL_POOLS.C]; if(wave===9&&cfg.allowRemnantLeech)pool.push('leech'); fill(pool,ri(effSlotsMin,effSlotsMax),150); }
  else if(wave===12){ fill(['rt_bruiser','rt_shaman','rt_warden','rt_swarm','assassin','frost'],cfg.slotsMin,160); }

  const forceEliteAnyWave=G.tierFlags&&G.tierFlags.elitesOnAnyWave&&!bossWave&&rng()<0.25;
  let eliteSpent=false;
  picks.forEach((pid)=>{
    const arch=ARCHETYPES.find(a=>a.id===baseArchFromPoolEntry(pid)); if(!arch)return;
    const opts={forceRootTouched:isRTPoolEntry(pid),isBoss:false};
    if(forceEliteAnyWave&&!eliteSpent){opts.forceElite=true; eliteSpent=true;}
    out.push(mkEnemy(arch,wave,false,opts));
  });

  const exp=[];
  out.forEach(e=>{
    exp.push(e);
    if(e.archId==='swarm'){
      for(let i=1;i<3;i++){
        if(exp.length>=effBodyCap)break;
        const c={...JSON.parse(JSON.stringify(e)),id:e.id+'_'+i,actionMeter:rng()*.5,_isEcho:false};
        exp.push(c);
      }
    }
  });
  exp.forEach(e=>{if(e.elite&&!e.namedElite){const force=!!(G.tierFlags&&G.tierFlags.guaranteeNamedEliteReturns&&(wave===10||wave===11));const n=checkForNamedEliteReturn(e.archId,wave,force);if(n){e.namedElite=true;e.displayName=n.name;e.name=n.name;}}});
  return exp.slice(0,effBodyCap||8);
}
function mkEnemy(arch,wave,boss,opts){
  opts=opts||{};
  const waveScaleBonus = (G && G.tierFlags && G.tierFlags.enemyWaveScaleBonus) || 0;
  const effectiveWave = Math.min(wave + waveScaleBonus, 20);
  const w = effectiveWave - 1;
  const b = arch.base, s = arch.scl;
  const mult = (G && typeof G.difficulty === 'number') ? G.difficulty : 1;
  const enemyHPMult = (G && G.tierFlags && G.tierFlags.enemyHPMult) || 1.0;
  const spdMult = (G && G.tierFlags && G.tierFlags.enemySPDMult) || 1.0;
  const baseHP = b.hp + s.hp * w;
  const enemyTuningMult = 0.85;
  const hp = Math.max(1, Math.floor(baseHP * mult * enemyHPMult * enemyTuningMult));
  const atk = Math.max(1, Math.floor((b.atk + s.atk * w) * mult * enemyTuningMult));
  const def = Math.max(0, Math.floor((b.def + s.def * w) * mult * enemyTuningMult));
  const baseSpdMult = 0.6 + 0.4 * mult;
  const spd = Math.max(5, Math.floor((b.spd + s.spd * w) * baseSpdMult * spdMult * enemyTuningMult));
  const rootTouchedChance=(G&&G.tierFlags&&G.tierFlags.rootTouchedEnemyChance)||0;
  const canTierRootTouched=(wave>=9)&&!boss&&!opts.forceRootTouched&&!opts.noRootTouched;
  const rootTouched=!!(opts.forceRootTouched||(canTierRootTouched&&rng()<rootTouchedChance));
  const cappedDef=(arch.id==='tank')?Math.min(def,55):def;
  const enemy={id:arch.id+'_'+ri(1000,9999),archId:arch.id,
    displayName:arch.displayName||arch.name||arch.id,norseName:arch.norseName||null,name:arch.displayName||arch.name||arch.id,
    realmTier:arch.realmTier||'midgard',icon:arch.icon,col:arch.col,hp,maxHP:hp,atk,def:cappedDef,spd,
    cc:arch.id==='striker'?Math.min(.7,b.cc+.25+.003*w):b.cc,cd:b.cd,lifesteal:arch.ls||0,trait:arch.trait,td:arch.td,beh:arch.beh,
    statuses:{},actionMeter:rng()*.5,_firstAtkDone:false,_hexCtr:0,_chargeCtr:0,_tankGuard:true,_tier2Done:false,
    elite:!!(boss||opts.forceElite),dead:false,rootTouched,namedElite:false,signature:null,isBoss:!!opts.isBoss,_rootKingRevived:false,_noEcho:false};
  if(rootTouched){const rtMult=(G&&G.tierFlags&&G.tierFlags.rootTouchedStatMult)||1.10;enemy.displayName='Root-Touched '+(arch.displayName||arch.name||arch.id);enemy.name=enemy.displayName;enemy.col='#2a1a3a';enemy.hp=enemy.maxHP=Math.floor(enemy.hp*rtMult);enemy.atk=Math.floor(enemy.atk*rtMult);}
  return enemy;
}

function heroShieldCap(){
  const pct = heroHasShieldEquipped() ? 1.05 : 0.75;
  return Math.floor(G.hero.maxHP * pct);
}

function addShieldToUnit(unit,amt,opts={}){
  let gain=Math.max(0,Math.floor(amt||0));
  if(unit===G.hero && !opts.bypassShieldPenalty && !heroHasShieldEquipped())gain=Math.floor(gain*0.50);
  if(gain<=0)return;
  if(!unit.statuses.shield)unit.statuses.shield={stacks:1,value:0,dur:9999};
  unit.statuses.shield.value+=gain;
  if (unit === G.hero) unit.statuses.shield.value=Math.min(unit.statuses.shield.value, heroShieldCap());
}
function pickWaveTraitsByTrial(wave) {
  const cfg=TRIAL_CONFIG[wave]||{minorTraitsMin:0,minorTraitsMax:1,majorTraitsMax:0,allowEliteTrait:false};
  const minTraits=(G&&G.tierFlags&&G.tierFlags.minWaveTraits)||0;
  const majorChance=(typeof cfg.majorChance==='number')?cfg.majorChance:0.45;
  const bossWave=!!((G&&G.enemies||[]).some(e=>e.isBoss) || (G&&G.bossWaves&&G.bossWaves.includes(wave)));
  const heroStartsVuln=!!((G.hero&&G.hero.traits&&G.hero.traits.includes('frayed_nerves')) || (G.roadside&&Array.isArray(G.roadside.debts)&&G.roadside.debts.some(d=>(d.battleStart||[]).some(bs=>bs.st==='vulnerable'&&(bs.dur||0)>0))));

  let minorPool=WAVE_TRAITS.filter(t=>MINOR_WAVE_TRAIT_IDS.includes(t.id));
  let majorPool=WAVE_TRAITS.filter(t=>MAJOR_WAVE_TRAIT_IDS.includes(t.id));
  if(wave<=4 && !(G.tierFlags&&G.tierFlags.allowAggroTraitsInBlock1)) minorPool=minorPool.filter(t=>t.id!=='enraged'&&t.id!=='frenzied');
  if(!cfg.allowEliteTrait)majorPool=majorPool.filter(t=>t.id!=='elite_wave');
  if(cfg.forbidMajorIds)majorPool=majorPool.filter(t=>!cfg.forbidMajorIds.includes(t.id));
  if(!(G.tierFlags&&G.tierFlags.allowHordeCall)) majorPool=majorPool.filter(t=>t.id!=='reinforcements');
  if(heroStartsVuln)majorPool=majorPool.filter(t=>t.id!=='marked_prey');

  const isInvalidCombo=(ids)=>{
    if(ids.includes('echo_atk')&&ids.includes('marked_prey'))return true;
    if(wave>=10&&ids.includes('echo_atk')&&ids.includes('elite_wave'))return true;
    if(heroStartsVuln&&ids.includes('marked_prey'))return true;
    return false;
  };

  const minorTarget=ri(cfg.minorTraitsMin||0,cfg.minorTraitsMax||0);
  const majorAllowed=(cfg.majorTraitsMax||0)>0;
  const majorTarget=(majorAllowed&&majorPool.length&&rng()<majorChance)?1:0;

  const picked=[]; const used=new Set();
  const pickFrom=(pool)=>{
    const opts=pool.filter(t=>!used.has(t.id));
    if(!opts.length)return null;
    const shuffled=[...opts];
    for(let i=shuffled.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));const tmp=shuffled[i];shuffled[i]=shuffled[j];shuffled[j]=tmp;}
    for(const cand of shuffled){
      const ids=[...picked.map(x=>x.id),cand.id];
      if(isInvalidCombo(ids))continue;
      used.add(cand.id);picked.push(cand);return cand;
    }
    return null;
  };
  for(let i=0;i<minorTarget;i++)pickFrom(minorPool);
  for(let i=0;i<Math.min(cfg.majorTraitsMax||0,majorTarget);i++)pickFrom(majorPool);

  const maxSoft=(cfg.minorTraitsMax||0)+(cfg.majorTraitsMax||0)+1;
  const floor=Math.min(maxSoft,minTraits||0);
  let fillPool=[...minorPool];
  const allowMajorInFill=majorAllowed && !bossWave && !cfg.eitherMajorOrMinors;
  if(allowMajorInFill) fillPool=[...minorPool,...majorPool];
  while(picked.length<floor){if(!pickFrom(fillPool))break;}

  if(wave>=7&&!bossWave&&rng()<0.12){
    const specialPool=WAVE_TRAITS.filter(t=>SPECIAL_WAVE_TRAIT_IDS.includes(t.id)&&!used.has(t.id));
    const blocked=picked.some(t=>t.id==='echo_atk'||t.id==='elite_wave');
    if(!blocked&&specialPool.length){const st=rpick(specialPool);used.add(st.id);picked.push(st);}
  }

  if(wave===12&&cfg.eitherMajorOrMinors){
    const isMajor=(t)=>MAJOR_WAVE_TRAIT_IDS.includes(t.id);
    const majors=picked.filter(isMajor);
    if(majors.length)return [majors[0]];
    return picked.filter(t=>!isMajor(t)).slice(0,2);
  }

  if(wave===9&&(G.enemies||[]).some(e=>e.archId==='assassin')) return picked.filter(t=>!MAJOR_WAVE_TRAIT_IDS.includes(t.id));
  if(wave===11&&cfg.forbidEchoWithAssassin&&(G.enemies||[]).filter(e=>e.archId==='assassin').length>=1) return picked.filter(t=>t.id!=='echo_atk');
  if(wave===12&&picked.some(t=>t.id==='toxic_air')&&picked.some(t=>t.id==='echo_atk')) return picked.filter(t=>t.id!==(rng()<0.5?'toxic_air':'echo_atk'));
  return picked;
}

function applyWaveTraitsToEnemies(){
  G.waveFlags={};
  const cfg=TRIAL_CONFIG[G.wave]||{};
  const hasBoss=(G.enemies||[]).some(e=>e.isBoss);
  const supportOnly=!!(cfg.supportOnlyTraits||hasBoss);
  const traitTargets=supportOnly?G.enemies.filter(e=>!e.isBoss):G.enemies;
  G.waveTraits.forEach(t=>t.apply(traitTargets,G.hero,G));

  if(G.tierFlags&&G.tierFlags.allWavesNiflheimTag){
    if(!G.waveFlags._fimbulwinterApplied){
      G.waveFlags._fimbulwinterApplied=true;
      applyStatus(G.hero,'slow',1,3);
      addLog('  âš° The gods fall â€” the air drags at your steps.','lstatus');
    }
  }
}

// â•â•â• PASSIVE HELPERS â•â•â•
function passive(k){for(const b of G.boons)for(const e of b.effects)if(e.t==='passive'&&e.k===k)return e.v??true;return null;}
function hasP(k){return passive(k)!==null;}
function hasTrait(tk){return G.hero.traits&&G.hero.traits.includes(tk);}

function effectiveStats(){
  const h=G.hero;
  const s={atk:h.atk+(h.permStats.atk||0),def:h.def,spd:h.spd,critChance:h.critChance,critDmg:h.critDmg,lifesteal:h.lifesteal,evasion:h.evasion,accuracy:h.accuracy};
  const il=passive('axiomIronLaw');if(il)s.atk+=Math.min(12,Math.floor(s.def*il));
  if(hasP('axiomKinetic')) s.critChance += Math.min(0.20, h.spd * 0.0015);

  h.cursedMult=1;
  if(h.gear){
    Object.values(h.gear).forEach(item=>{
      if(!item)return;
      const affixes=getGearEffectiveAffixes(item);
      affixes.forEach(affix=>{
        const v=affix.effectiveValue;
        if(typeof v!=='number')return;
        if(affix.stat==='atk')s.atk+=v;
        if(affix.stat==='def')s.def+=v;
        if(affix.stat==='spd')s.spd+=v;
        if(affix.stat==='critChance')s.critChance=Math.min(0.9,s.critChance+v);
        if(affix.stat==='critDmg')s.critDmg+=v;
        if(affix.stat==='evasion')s.evasion=Math.min(0.6,s.evasion+v);
        if(affix.stat==='lifesteal')s.lifesteal=Math.min(0.4,s.lifesteal+v);
        if(affix.stat==='accuracySet')s.accuracy=v;
        if(affix.stat==='defPen')s._gearDefPen=(s._gearDefPen||0)+v;
        if(affix.stat==='maxHP')s._gearMaxHP=(s._gearMaxHP||0)+v;
        if(affix.stat==='executionBonus')s._gearExecutionBonus=(s._gearExecutionBonus||0)+v;
        if(affix.stat==='regenPct')s._gearRegenPct=(s._gearRegenPct||0)+v;
        if(affix.stat==='dotResist')s._gearDotResist=(s._gearDotResist||0)+v;
        if(affix.stat==='cursedDamageMult')h.cursedMult=Math.max(h.cursedMult||1,1+v);
      });
      if(item.passiveBonus){
        const pb=item.passiveBonus;
        if(pb.stat==='atk'&&typeof pb.value==='number')s.atk+=pb.value;
        if(pb.stat==='def'&&typeof pb.value==='number')s.def+=pb.value;
      }
    });
    s.critChance=Math.min(0.9,Math.max(0,s.critChance));
    s.evasion=Math.min(0.6,Math.max(0,s.evasion));
    s.lifesteal=Math.min(0.4,Math.max(0,s.lifesteal));
  }
  return s;
}

function heroAtk(){
  const h=G.hero,es=effectiveStats();
  let a=es.atk+(h.tempStats.atk||0);
  const rage=h.statuses.rage;if(rage)a+=rage.stacks*3;
  if(h.statuses.weak)a=Math.floor(a*.75);
  const pred=passive('predator');if(pred&&h.hp<h.maxHP*.50)a=Math.floor(a*(1+pred));
  if(hasTrait('predatory')&&h.hp<h.maxHP*.50)a+=3;
  const bers=passive('berserk');if(bers&&h.hp<h.maxHP*bers.thr)a=Math.floor(a*(1+bers.atk));
  return Math.max(1,Math.floor(a));
}
function heroSpd(){
  const h=G.hero;
  let s=h.spd+(h.tempStats.spd||0);
  const tempo=h.statuses.tempo;if(tempo)s+=tempo.stacks*3;
  const bers=passive('berserk');if(bers&&h.hp<h.maxHP*bers.thr)s=Math.floor(s*(1+bers.spd));
  if(hasTrait('skirmisher')&&h.hp<h.maxHP*.50)s+=8;
  if(h.statuses.slow)s=Math.floor(s*.70);
  return Math.max(5,s);
}
function eSpd(e){
  let s=e.spd;
  if(e.archId==='bruiser')return Math.max(5,s);
  if(e.statuses.slow)s=Math.floor(s*.70);
  return Math.max(5,s);
}

// â•â•â• STATUS APPLICATION â•â•â•
function applyStatus(unit,key,stacks,dur,maxStacks){
  if(key==='slow'&&unit.archId==='bruiser')return;
  if(unit===G.hero && unit.flags && unit.flags.debuffWard){
    const neg = (key==='bleed'||key==='poison'||key==='weak'||key==='vulnerable'||key==='slow'||key==='stun');
    if(neg){
      unit.flags.debuffWard=false;
      addLog('  ğŸ§¿ Ward negates '+(STATUS[key]?.name||key)+'!','laxiom');
      return;
    }
  }
  const plagMult=passive('axiomPlague')||1.0;
  if(dur!==9999)dur=Math.floor(dur*plagMult);
  if(!unit.statuses[key])unit.statuses[key]={stacks:0,value:0,dur:0};
  const mx=(maxStacks==null)?(key==='tempo'?12:99):maxStacks;
  unit.statuses[key].stacks=Math.min(mx,unit.statuses[key].stacks+stacks);
  unit.statuses[key].dur=Math.max(unit.statuses[key].dur,dur);

  if(key==='bleed'){
    if(hasP('bleedWeak')||hasP('axiomCrimson'))applyStatus(unit,'weak',1,dur);
    if(hasP('bleedSlow'))applyStatus(unit,'slow',1,dur);
  }
  if(key==='poison'&&unit!==G.hero){
    if(hasP('poisonSlow'))applyStatus(unit,'slow',1,dur);
    if(hasP('plagueLord')){
      const others=(G.enemies||[]).filter(e=>!e.dead&&e!==unit);
      for(let i=others.length-1;i>0;i--){const j=Math.floor(rng()*(i+1));const tmp=others[i];others[i]=others[j];others[j]=tmp;}
      others.slice(0,2).forEach(e=>{
        if(!e.statuses.poison)e.statuses.poison={stacks:0,value:0,dur:0};
        e.statuses.poison.stacks=Math.min(10,e.statuses.poison.stacks+1);
        e.statuses.poison.dur=Math.max(e.statuses.poison.dur,3);
      });
    }
  }
}

// â•â•â• DAMAGE / HEAL â•â•â•
function dealToEnemy(enemy,dmg,opts){
  opts=opts||{};
  if(enemy.dead||dmg<=0)return 0;
  if(enemy.archId==='tank'&&enemy._tankGuard){enemy._tankGuard=false;addLog(`  ğŸ›¡ ${enemy.displayName||enemy.name} Iron Will negates!`,'lstatus');return 0;}

  const sh=enemy.statuses.shield;
  if(!opts.ignoreShield&&sh&&sh.value>0){
    const abs=Math.min(sh.value,dmg);sh.value-=abs;dmg-=abs;
    if(sh.value<=0)delete enemy.statuses.shield;
    if(dmg<=0)return abs;
  }

  const prev=enemy.hp;
  enemy.hp=Math.max(0,enemy.hp-dmg);
  if(enemy.hp<=0&&!enemy.dead){enemy.dead=true;onKill(enemy);}
  return Math.min(dmg,prev);
}

function dealToEnemyFromHero(enemy,dmg){
  const hunger=passive('axiomHungerLaw');
  const ignore=!!(hunger&&enemy&&!enemy.dead&&enemy.hp<enemy.maxHP*0.50);
  if(ignore&&enemy.statuses&&enemy.statuses.shield&&enemy.statuses.shield.value>0)addLog('  ğŸ¦· Hunger Law pierces Shield!','laxiom');
  return dealToEnemy(enemy,dmg,{ignoreShield:ignore});
}

function heroDmg(rawDmg,attacker,src){
  const hero=G.hero;
  if(rawDmg<=0)return 0;

  let incoming=Math.floor(rawDmg);
  if(hero.cursedMult&&hero.cursedMult>1.0)incoming=Math.floor(incoming*hero.cursedMult);
  if(hasTrait('tenacious')&&hero.hp<hero.maxHP*.25)incoming=Math.floor(incoming*.60);
  if(hero.statuses.vulnerable&&hero.statuses.vulnerable.dur>0)incoming=Math.floor(incoming*1.30);

  const gen = (hero?.record?.gen ?? 0);
  const mitiPerGen = 0.025;
  const mitiCap = 0.22;
  const miti = Math.max(0, Math.min(mitiCap, gen * mitiPerGen));
  hero.ancestralMitigation = miti;
  if (miti > 0) incoming = Math.max(1, Math.floor(incoming * (1 - miti)));

  let hpDamage=0;
  const sh=hero.statuses.shield;
  if(sh&&sh.value>0){
    const fortressReady = hasP('axiomFortress') && sh.value >= Math.floor(hero.maxHP * 0.30) && !(hero.statuses && hero.statuses.fortressCD);
    if(fortressReady){
      addLog('  ğŸ¯ Stone Resolve: hit absorbed!','laxiom');
      sh.value=Math.max(0,sh.value-incoming);
      if(sh.value<=0){delete hero.statuses.shield;shieldBreak(attacker);}
      hero.statuses.fortressCD={stacks:1,dur:2};
      hpDamage=0;
    }else{
      const abs=Math.min(sh.value,incoming);
      sh.value-=abs;
      incoming-=abs;
      if(sh.value<=0){delete hero.statuses.shield;shieldBreak(attacker);}
      hpDamage=Math.max(0,incoming);
    }
  }else hpDamage=Math.max(0,incoming);

  const prev=hero.hp;
  if(hpDamage>0)hero.hp=Math.max(0,hero.hp-hpDamage);

  if(src!=='mirror'&&src!=='thorns'&&src!=='dot'&&attacker&&attacker!==hero&&hpDamage>0){
    const m=passive('axiomMirror');
    if(m){
      const md=Math.min(20,Math.floor(hpDamage*m));
      if(md>0){dealToEnemy(attacker,md);addLog('  ğŸª Mirror: '+md+' reflected!','laxiom');}
    }
    const th=passive('thorns');if(th){const td=Math.floor(hpDamage*th);if(td>0)dealToEnemy(attacker,td);}
    if(hasTrait('spite')){const sp=Math.min(20,Math.floor(hpDamage*.08));if(sp>0)dealToEnemy(attacker,sp);}
  }

  if(hero.hp>0&&hero.hp<hero.maxHP*0.25)NarrationEngine.onNearDeath();
  if(hero.hp<=0&&!hero.usedUndying&&hasP('undying')){
    hero.usedUndying=true;hero.hp=Math.floor(hero.maxHP*.35);
    addLog('  ğŸ”„ UNDYING! Hero rises with '+hero.hp+' HP!','laxiom');
  }
  const sw=passive('secondWind');
  if(sw && !hero.flags.secondWindUsed && hero.hp>0 && hero.hp<hero.maxHP*0.30){
    hero.flags.secondWindUsed=true;
    const heal=Math.floor(hero.maxHP*sw);
    addLog('  ğŸŒ¬ï¸ Second Wind! +'+heal,'laxiom');
    healHero(heal,'sw');
  }
  if (hpDamage > 0) trigBoon('onDmg',hero,attacker,{});
  return Math.min(hpDamage,prev);
}

function shieldBreak(attacker){
  addLog(`  ğŸ’” Shield broken!`,'lshield');
  const bash=passive('shieldBash');
  if(bash&&attacker&&!attacker.dead){dealToEnemy(attacker,bash);addLog(`  ğŸ’¥ Shield Bash! ${attacker.displayName||attacker.name} takes ${bash}!`,'lhit');}
}

function healHero(amt,src){
  const h=G.hero;
  let mod=1;
  if(hasTrait&&hasTrait('shallow_breath'))mod*=0.80;
  if(hasTrait&&hasTrait('thin_margin')&&h.hp<h.maxHP*0.30)mod*=0.65;
  amt=Math.max(0,Math.floor(amt*mod));
  const over = Math.max(0, (h.hp + amt) - h.maxHP);
  h.hp = Math.min(h.maxHP, h.hp + amt);

  if (over > 0 && hasP('overhealShield')) {
    const conv = 0.60;
    const cap = (typeof h._overhealShieldCapThisBattle === 'number') ? h._overhealShieldCapThisBattle : Math.floor(h.maxHP * 0.60);
    const gained = (typeof h._overhealShieldGained === 'number') ? h._overhealShieldGained : 0;
    const remaining = Math.max(0, cap - gained);
    const desired = Math.floor(over * conv);
    const grant = Math.min(remaining, desired);
    if (grant > 0) {
      const before = h.statuses?.shield?.value || 0;
      addShieldToUnit(h, grant);
      const after = h.statuses?.shield?.value || 0;
      const actual = Math.max(0, after - before);
      h._overhealShieldGained = gained + actual;
      if (actual > 0) addLog(`  ğŸ’ Overheal â†’ ${actual} Shield`,'laxiom');
      if (remaining <= actual) addLog('  â›“ï¸ Overheal shield capped this battle.','lstatus');
    }
  }

  if(amt>0&&src!=='ls'&&src!=='regen')addLog(`  ğŸ’š Healed ${amt} HP`,'lheal');
}

// â•â•â• BOON EVENT SYSTEM â•â•â•
function trigBoon(evType,hero,target,ctx={}){
  for(const b of G.boons)for(const ef of b.effects){
    if(ef.t!==evType)continue;
    if(typeof ef.ch==='number'&&rng()>ef.ch)continue;
    if(ef.ef==='status'){
      const sk=(ef.st==='tempo')?Math.max(1,Math.floor((ef.sk||1)*rmult('tempoStacks'))):(ef.sk||1);
      applyStatus(hero,ef.st,sk,ef.dur,ef.mx);
    }
    else if(ef.ef==='statusEnemy'){
      if(target&&target!==hero&&!target.dead){
        let sk=ef.sk||1;
        if(ef.st==='bleed')sk=Math.max(1,Math.floor(sk*rmult('bleedStacks')));
        if(ef.st==='poison')sk=Math.max(1,Math.floor(sk*rmult('poisonStacks')));
        applyStatus(target,ef.st,sk,ef.dur);
      }
    }
    else if(ef.ef==='shield')addShieldToUnit(hero,Math.floor((ef.amt||0)*rmult('shieldGain')));
    else if(ef.ef==='tempStat')hero.tempStats[ef.s]=(hero.tempStats[ef.s]||0)+ef.v;
    else if(ef.ef==='permStat'){hero.permStats[ef.s]=(hero.permStats[ef.s]||0)+ef.v;addLog('  â­ '+b.name+': perm +'+ef.v+' ATK!','laxiom');}
    else if(ef.ef==='healPct')healHero(Math.floor(hero.maxHP*ef.v),'kill');
    else if(ef.ef==='flag')hero.flags[ef.f]=(hero.flags[ef.f]||0)+ef.v;
    else if(ef.ef==='splash'){
      if(ctx.isBonusHit)continue;
      const base=Math.max(0,Math.floor(ctx.actualDamage||0));
      if(base<=0)continue;
      const others=G.enemies.filter(e=>!e.dead&&e!==target);
      if(others.length){
        const t2=rpick(others);
        const sd=Math.max(1,Math.floor(base*ef.v));
        dealToEnemy(t2,sd);
        addLog("  âš¡ Thor's Lash â†’ "+t2.name+" for "+sd+"!",'laxiom');
      }
    }
  }
}

function applyBoonEffectsOnPick(boon){
  for(const ef of boon.effects){
    if(ef.t==='stat'){
      if(ef.s==='hp')G.hero.hp=Math.min(G.hero.maxHP+ef.v,G.hero.hp+ef.v);
      G.hero[ef.s]=(G.hero[ef.s]||0)+ef.v;
    }
  }
}
function applyBattleStartBoons(){
  for(const b of G.boons)for(const ef of b.effects){
    if(ef.t==='onBattleStart'&&ef.ef==='shield')addShieldToUnit(G.hero,Math.floor((ef.amt||0)*rmult('battleStartShield')));
    if(ef.t==='onBattleStart'&&ef.ef==='status')applyStatus(G.hero,ef.st,ef.sk||1,ef.dur,ef.mx);
  }
  if(hasTrait('aegis'))addShieldToUnit(G.hero,Math.floor(8*rmult('battleStartShield')));
  if(hasTrait('frayed_nerves'))applyStatus(G.hero,'vulnerable',1,1.5);
  if(hasTrait('death_oath'))applyStatus(G.hero,'weak',1,2);
  if(hasTrait('eitr_cough'))applyStatus(G.hero,'weak',1,2);
  if(hasTrait('panic_surge')){applyStatus(G.hero,'momentum',2,9999,99);G.hero.flags.panicFirstAccPenalty=true;}
  if(hasTrait('shattered_guard')&&heroHasShieldEquipped())addShieldToUnit(G.hero,Math.floor(18*rmult('battleStartShield')));
  if(G.hero.gear){
    Object.values(G.hero.gear).forEach(item=>{
      if(!item)return;
      getGearEffectiveAffixes(item).forEach(affix=>{
        if((affix.stat==='shieldOnBattleStart'||affix.stat==='battleStartShield')&&typeof affix.effectiveValue==='number')addShieldToUnit(G.hero,Math.floor(affix.effectiveValue*rmult('battleStartShield')));
      });
    });
  }
  if(G.roadside&&Array.isArray(G.roadside.debts)){
    G.roadside.debts.forEach(d=>{(d.battleStart||[]).forEach(bs=>applyStatus(G.hero,bs.st,bs.sk||1,bs.dur||2));});
  }
}


function pickHeroTarget(alive){
  if(!alive || !alive.length) return null;
  const tmode=tacticTargetMode();
  if(tmode==='threat'){
    // Highest ATK first (ties: lower HP)
    return alive.reduce((m,e)=> (e.atk>m.atk || (e.atk===m.atk && e.hp<m.hp)) ? e : m, alive[0]);
  }
  if(tmode==='wounded' || hasP('targetLowest')){
    return alive.reduce((m,e)=>((e.hp/e.maxHP) < (m.hp/m.maxHP))?e:m, alive[0]);
  }
  return alive[0];
}
function applyEnemyStartTraits(){
  // Warden banner: grant allies Shield at battle start (scales lightly with wave)
  const wardens = G.enemies.filter(e=>!e.dead && e.archId==='warden');
  if(wardens.length){
    const amt = 10 + Math.floor((G.wave-1)*1.2);
    G.enemies.filter(e=>!e.dead).forEach(e=>addShieldToUnit(e, amt));
    addLog(`  ğŸ§¿ Banner: enemies gain ${amt} Shield!`,'lstatus');
  }
}

// â•â•â• COMBAT LOOP â•â•â•
function startBattle(){
  const h=G.hero;
  if(!commitPendingTactic()){renderAll();return;}
  const carryShield=h.statuses?.shield?.value||0;
  h.statuses={};h.actionMeter=0;h.atkCount=0;h.tempStats={};h.flags={};h.usedUndying=false;
  if(hasP('axiomOpen'))h.flags.openStrike=true;
  if(hasP('wardDebuff'))h.flags.debuffWard=true;
  h.flags.secondWindUsed=false;
  h._firstFuryUsedThisBattle=false;
  h._attackedThisSecond=false;
  h._overhealShieldGained = 0;
  h._overhealShieldCapThisBattle = Math.floor(h.maxHP * (heroHasShieldEquipped() ? 0.85 : 0.55));
  applyWaveTraitsToEnemies();
  applyBattleStartBoons();
  if(heroHasShieldEquipped()&&carryShield>0)addShieldToUnit(h,carryShield,{bypassShieldPenalty:true});

  if(G.tierFlags&&G.tierFlags.allFatherLastGift&&G.wave===1&&!G._allFatherGiftOffered){
    G._allFatherGiftOffered=true;
    if(G.interval)clearInterval(G.interval);
    G.phase='ALLFATHER_GIFT';
    renderAll();
    showAllFatherGift();
    return;
  }

  applyEnemyStartTraits();
  applyBattleStartTactics();
  if(G.waveFlags.heroStartVuln){applyStatus(G.hero,'vulnerable',1,G.waveFlags.heroStartVuln);addLog('  ğŸ¯ Marked Prey: Vulnerable ('+G.waveFlags.heroStartVuln+'s)','lstatus');}
  G.phase='BATTLE';G.tick=0;G.statusTick=0;G._critLandedThisWave=false;G._narratedNearDeath=false;
  addLog('âš” Trial '+G.wave+' â€” '+G.enemies.length+' enemies!','lwave');

  NarrationEngine.reset();
  const waveStartLine=MYTH_LINES.waveStart[G.wave];
  if(waveStartLine) NarrationEngine.fire('waveStart',waveStartLine,'lstatus');
  if(G.wave===4) addLog('  The dead should not walk here.','lstatus');
  if(G.wave===5) addLog('  The root turns downward. The air grows thin.','lstatus');
  if(G.wave===9) addLog('  Mist rises. The cold has teeth.','lstatus');
  if(G.wave===12) addLog('  He is not a king. He is an argument.','lstatus');

  if(G.interval)clearInterval(G.interval);
  G.interval=setInterval(combatTick,100/G.speed);
}

function combatTick(){
  if(G.phase!=='BATTLE'){clearInterval(G.interval);return;}
  G.tick++;G.statusTick++;
  if(G.statusTick>=10){
    G.statusTick=0;
    tickStatuses(G.hero,true);
    G.enemies.filter(e=>!e.dead).forEach(e=>tickStatuses(e,false));
    const toxicAirActive=G.waveFlags.toxicAir||(G.tierFlags&&G.tierFlags.toxicAirFromWave&&G.wave>=G.tierFlags.toxicAirFromWave);
    if(toxicAirActive){
      const taDmg=(G.tierFlags&&G.tierFlags.toxicAirDmg)||1;
      G.enemies.filter(e=>!e.dead).forEach(e=>{e.hp=Math.max(0,e.hp-taDmg);if(e.hp<=0&&!e.dead){e.dead=true;onKill(e);}});
      heroDmg(taDmg,null,'dot');
    }
    if(G.waveFlags.eRegen){
      G.enemies.filter(e=>!e.dead).forEach(e=>{e.hp=Math.min(e.maxHP,e.hp+Math.floor(e.maxHP*G.waveFlags.eRegen));});
    }
    const ren=passive('regen');
    if(ren){
      const regenBonus=(G.tierFlags&&G.tierFlags.regenBoonBonus)||0;
      healHero(Math.floor(G.hero.maxHP*ren*(1+regenBonus)),'regen');
    }
    if(passive('patienceBlade')){
      if(!G.hero._attackedThisSecond)applyStatus(G.hero,'patience',1,9999,5);
      G.hero._attackedThisSecond=false;
    }
    if(G.hero.gear){
      Object.values(G.hero.gear).forEach(item=>{
        if(!item)return;
        getGearEffectiveAffixes(item).forEach(affix=>{
          if(affix.stat==='regenPct'&&typeof affix.value==='number'){
            const regenBonus=(G.tierFlags&&G.tierFlags.regenBoonBonus)||0;
            const healAmt=Math.floor(G.hero.maxHP*affix.effectiveValue*(1+regenBonus));
            if(healAmt>0)healHero(healAmt,'gear-regen');
          }
        });
      });
    }
  }
  if(checkEnd())return;

  if(!G.hero.statuses.stun){
    G.hero.actionMeter+=heroSpd()/500;
    if(G.hero.actionMeter>=1){G.hero.actionMeter=0;doHeroAtk();}
  }
  G.enemies.filter(e=>!e.dead).forEach(e=>{
    if(e.statuses.stun)return;
    e.actionMeter+=eSpd(e)/500;
    if(e.actionMeter>=1){e.actionMeter=0;doEnemyAtk(e);}
  });

  if(checkEnd())return;
  if(G.tick%2===0)renderBattleUI();
}

function heroHasShieldEquipped(){
  return !!(G&&G.hero&&G.hero.gear&&G.hero.gear.talisman&&G.hero.gear.talisman.isShield);
}

function resolveHeroHit(target,opts={}){
  const h=G.hero;
  if(!target||target.dead)return {hit:false,crit:false,actual:0,killed:false};
  const es=effectiveStats();
  const isBonusHit=!!opts.isBonusHit;
  const canCrit=(opts.canCrit!==false);
  const triggerOnCrit=(opts.triggerOnCrit!==false);
  const allowOnHitSplash=(opts.allowOnHitSplash!==false);
  const dmgMult=(typeof opts.damageMult==='number')?opts.damageMult:1.0;

  if(!isBonusHit && rng()>es.accuracy-(target.evasion||0)){
    addLog('  â†© Miss!','lmiss');
    return {hit:false,crit:false,actual:0,killed:false};
  }

  let crit=false;
  if(canCrit)crit=h.flags.openStrike?(h.flags.openStrike=false,true):(rng()<es.critChance);

  let dmg=heroAtk();
  if(!isBonusHit){
    if(h.flags.tacticAmbush){dmg=Math.floor(dmg*2);addLog('  ğŸ—¡ Ambush!','laxiom');}
    if(h.flags.deathMark){dmg=Math.floor(dmg*2.6);h.flags.deathMark=0;addLog('  â˜  Death Mark!','laxiom');}
    const tr=passive('trance');if(tr&&h.atkCount%tr===0){dmg=Math.floor(dmg*1.9);addLog('  ğŸ” Battle Trance!','laxiom');}
    const arc=passive('arcane');if(arc&&h.atkCount%arc===0){const md=Math.floor(dmg*.9);addLog('  ğŸ”® Arcane Surge! +'+md,'laxiom');dealToEnemyFromHero(target,md);}
    const vs=passive('void');if(vs&&h.atkCount%vs===0){const vd=Math.floor(dmg*3);addLog('  ğŸŒ€ GINNUNGA-STRIKE! '+vd+'!','laxiom');dealToEnemyFromHero(target,vd);fxEnemyImpact(target.id,{big:true});if(target.dead)return {hit:true,crit:false,actual:0,killed:true};}
  }

  if(crit)dmg=Math.floor(dmg*es.critDmg*rmult('critDmg'));
  if(crit&&hasTrait('brittle_edge')&&!target.dead)applyStatus(target,'marked',1,2);
  if(!isBonusHit&&hasTrait('death_oath')&&!h.flags.deathOathUsed){h.flags.deathOathUsed=true;applyStatus(target,'marked',1,3);}
  if(!isBonusHit&&passive('firstFury')&&!h._firstFuryUsedThisBattle){h._firstFuryUsedThisBattle=true;h.flags.firstFury=true;}
  if(h.flags.firstFury){dmg=Math.floor(dmg*1.60);h.flags.firstFury=false;addLog('  ğŸ’¥ First Fury!','laxiom');}
  if(h.statuses.momentum){const ms=h.statuses.momentum.stacks||0;dmg+=ms*2;delete h.statuses.momentum;addLog('  âš¡ Momentum! +'+(ms*2)+' dmg','lstatus');}
  if(h.statuses.patience){const ps=h.statuses.patience.stacks||0;dmg=Math.floor(dmg*(1+0.08*ps));delete h.statuses.patience;addLog('  ğŸ•° Patience! +'+Math.round(8*ps)+'% dmg','lstatus');}
  if(target.statuses.marked){dmg=Math.floor(dmg*1.30);delete target.statuses.marked;addLog('  ğŸ¯ Marked! +30% dmg','lstatus');}
  dmg=Math.floor(dmg*dmgMult);

  let effDef=target.def;
  if(hasP('necroticPoison')&&target.statuses.poison)effDef=Math.max(0,effDef-target.statuses.poison.stacks*passive('necroticPoison'));
  let dp=passive('defpen')||0;
  const gearDp=es._gearDefPen||0;
  dp = 1-((1-dp)*(1-gearDp));
  if(!isBonusHit&&h.flags.tacticAmbush&&h.flags.tacticAmbushDefPen)dp = 1-((1-dp)*(1-h.flags.tacticAmbushDefPen));
  if(dp>0)effDef=Math.floor(effDef*(1-dp));
  if(crit){const cdp=passive('critDefpen');if(cdp)effDef=Math.floor(effDef*(1-cdp));}

  const exec=passive('executioner');if(exec&&target.hp<target.maxHP*.30)dmg=Math.floor(dmg*(1+exec));
  const gearExec=es._gearExecutionBonus||0;if(gearExec&&target.hp<target.maxHP*.30)dmg=Math.floor(dmg*(1+gearExec));
  if(hasTrait('executioner_b')&&target.hp<target.maxHP*.30)dmg=Math.floor(dmg*1.15);
  if(target.statuses.vulnerable)dmg=Math.floor(dmg*1.30);

  dmg=Math.max(1,dmg-effDef);
  const actual=dealToEnemyFromHero(target,dmg);

  if(crit) fxEnemyImpact(target.id,{crit:true});
  else if(actual >= Math.floor(target.maxHP * 0.18)) fxEnemyImpact(target.id,{big:true});

  if(G.hero.gear){
    Object.values(G.hero.gear).forEach(item=>{
      if(!item)return;
      getGearEffectiveAffixes(item).forEach(affix=>{
        if(affix.stat==='onCritBleedChance'&&crit&&!target.dead){if(rng()<affix.effectiveValue)applyStatus(target,'bleed',1,3);}
        if(affix.stat==='permAtkOnKill'&&target.dead){
          G.hero.permStats.atk=(G.hero.permStats.atk||0)+Math.floor(affix.effectiveValue);
          addLog('  âš” Tyrfing feeds. +'+Math.floor(affix.effectiveValue)+' permanent ATK.','laxiom');
        }
      });
    });
  }

  if(crit){
    G._critLandedThisWave=true;
    addLog('  âš” CRIT! '+(target.displayName||target.name)+' â† '+actual,'lcrit');
    NarrationEngine.onCrit();
  } else addLog('  âš” '+(target.displayName||target.name)+' â† '+actual,'lhit');

  let ls=Math.floor(actual*(es.lifesteal||0)*rmult('lifesteal'));
  if(hasTrait('bitter_blood'))ls=Math.floor(ls*0.50);
  if(ls>0)healHero(ls,'ls');
  if(hasTrait('serrated')&&rng()<.22&&!target.dead)applyStatus(target,'bleed',1,2);
  if(hasTrait('eitr_cough')&&rng()<0.15&&!target.dead)applyStatus(target,'poison',1,3);

  trigBoon('onHit',h,target,{actualDamage:actual,isBonusHit:!allowOnHitSplash||isBonusHit,source:isBonusHit?'bonus':'primary'});
  const sh=passive('shred');if(sh && !target.dead){const before=target.def;target.def=Math.max(0,target.def-sh);if(target.def!==before)addLog('  ğŸª¨ Sunder! '+(target.displayName||target.name)+' DEF -'+(before-target.def),'lstatus');}

  if(triggerOnCrit&&crit)trigBoon('onCrit',h,target,{actualDamage:actual,isBonusHit:false,source:'crit'});
  const sc=passive('stunCrit');if(crit&&sc&&rng()<sc&&!target.dead){applyStatus(target,'stun',1,1);addLog('  ğŸ’« Stun!','lstatus');}

  if(!isBonusHit&&h.flags.tacticAmbush){h.flags.tacticAmbush=false;h.flags.tacticAmbushDefPen=0;}
  return {hit:true,crit:crit,actual:actual,killed:!!target.dead};
}

function doHeroAtk(){
  const h=G.hero,alive=G.enemies.filter(e=>!e.dead);
  if(!alive.length)return;
  h._attackedThisSecond=true;
  h.atkCount++;

  let target=pickHeroTarget(alive);
  const echoPeriod=passive('axiomEcho');
  const doEcho=!!(echoPeriod && h.atkCount%echoPeriod===0);

  const primary=resolveHeroHit(target,{damageMult:1,canCrit:true,triggerOnCrit:true,isBonusHit:false,allowOnHitSplash:true});
  if(!primary.hit)return;

  let target2=target;
  if(target2.dead){
    const alive2=G.enemies.filter(e=>!e.dead);
    target2=alive2.length?pickHeroTarget(alive2):null;
  }
  if(!target2||target2.dead)return;

  const tw=passive('twin');
  if(tw&&rng()<tw){
    const r=resolveHeroHit(target2,{damageMult:1.0,canCrit:false,triggerOnCrit:false,isBonusHit:true,allowOnHitSplash:false});
    if(r.hit)addLog('  âš”âš” Twin! '+(target2.displayName||target2.name)+' â† '+r.actual,'lhit');
  }else if(doEcho){
    const r=resolveHeroHit(target2,{damageMult:0.40,canCrit:false,triggerOnCrit:false,isBonusHit:true,allowOnHitSplash:false});
    if(r.hit)addLog('  ğŸ” Echo! '+(target2.displayName||target2.name)+' â† '+r.actual,'laxiom');
  }
}

function doEnemyAtk(enemy){
  const h=G.hero;
  let ev=effectiveStats().evasion;
  if(enemy.statuses.hexed)ev=Math.min(0.95,ev+0.30);
  const pendingDodge=enemy._tier2DodgePending||0;
  enemy._tier2DodgePending=0; // consume immediately
  if(rng()<Math.min(0.95,ev+pendingDodge)){
    addLog(`  ğŸ’ƒ Dodged ${enemy.displayName||enemy.name}!`,'lmiss');
    trigBoon('onDodge',h,enemy);
    return;
  }

  // â”€â”€ TIER 2 BEHAVIORS (active when G.tierFlags.archetypeBehaviors is true) â”€â”€
  const tier2Active=!!(G.tierFlags&&G.tierFlags.archetypeBehaviors);
  const arch=ARCHETYPES.find(a=>a.id===enemy.archId);
  if(tier2Active&&arch&&arch.tier2Behavior){
    if(arch.tier2Behavior==='regenOnFirstAttack'&&!enemy._tier2Done){
      enemy._tier2Done=true;
      const heal=Math.floor(enemy.maxHP*(arch.tier2RegenPct||0));
      enemy.hp=Math.min(enemy.maxHP,enemy.hp+heal);
      addLog(`  âš™ ${enemy.displayName||enemy.name} Iron Regen: +${heal} HP`,'lstatus');
    }
    if(arch.tier2Behavior==='weakOnFirstAttack'&&!enemy._tier2Done){
      enemy._tier2Done=true;
      applyStatus(h,'weak',1,3);
      addLog(`  ğŸ”® ${enemy.displayName||enemy.name} Hex â€” first strike! Weak applied.`,'lstatus');
    }
  }

  let dmg=enemy.atk;
  let crit=rng()<(enemy.cc||.05);

  // New archetype abilities
  if(enemy.archId==='archer'){
    enemy._pierceCtr=(enemy._pierceCtr||0)+1;
    enemy._pierce=(enemy._pierceCtr%4===0);
    if(enemy._pierce) addLog(`  ğŸ¹ Piercing Shot!`,'lstatus');
  }
  if(enemy.archId==='frost'){
    enemy._frostCtr=(enemy._frostCtr||0)+1;
    if(enemy._frostCtr%3===0){applyStatus(h,'slow',1,3);addLog(`  â„ï¸ Frostbite! Slow`,'lstatus');}
    if(crit&&rng()<0.15){applyStatus(h,'stun',1,1);addLog(`  ğŸ’« Frozen! Stun`,'lstatus');}
  }
  if(enemy.archId==='warden'){
    enemy._bannerCtr=(enemy._bannerCtr||0)+1;
    if(enemy._bannerCtr%4===0){applyStatus(h,'weak',1,3);addLog(`  ğŸ§¿ Suppressed! Weak`,'lstatus');}
  }

  if(enemy.beh==='burst'&&!enemy._firstAtkDone){enemy._firstAtkDone=true;dmg=Math.floor(dmg*1.6);addLog(`  ğŸ—¡ AMBUSH! ${enemy.displayName||enemy.name}!`,'lcrit');}
  if(enemy.archId==='bombardier'){enemy._chargeCtr++;if(enemy._chargeCtr%3===0){dmg*=2;addLog(`  ğŸ’£ OVERCHARGE! ${enemy.displayName||enemy.name}!`,'lcrit');}}
  if(enemy.archId==='shaman'){enemy._hexCtr++;if(enemy._hexCtr%3===0){applyStatus(h,'weak',1,4);addLog(`  ğŸ”® Hex! Weak on hero`,'lstatus');}}

  if(tier2Active&&arch&&arch.tier2Behavior==='enrageOnLowHP'){
    if(enemy.hp<enemy.maxHP*(arch.tier2Threshold||0.35)&&!enemy._tier2Enraged){
      enemy._tier2Enraged=true;
      enemy.atk+=arch.tier2BonusAtk||5;
      addLog(`  ğŸº ${enemy.displayName||enemy.name} Wolf-Rage! +${arch.tier2BonusAtk||5} ATK`,'lcrit');
    }
  }

  if(crit)dmg=Math.floor(dmg*(enemy.cd||1.5));
  if(crit&&hasTrait('iron_reflex')){const bonus=Math.max(0,dmg-enemy.atk);dmg=enemy.atk+Math.floor(bonus*0.5);}

  const heroDef=(enemy.archId==='archer'&&enemy._pierce)?Math.floor(h.def*0.2):h.def;
  const reduced=Math.max(1,Math.floor(dmg)-heroDef);
  const actual=heroDmg(reduced,enemy,'attack');

  if(crit)addLog(`  ğŸ’¥ ${enemy.displayName||enemy.name} CRITS! ${actual}`,'lcrit');
  else addLog(`  ğŸ‘Š ${enemy.displayName||enemy.name} hits ${actual}`,'lhit');

  if(crit) fxHpImpact({crit:true});
  else if(actual >= Math.floor(G.hero.maxHP * 0.18)) fxHpImpact({big:true});

  if(enemy.lifesteal>0)enemy.hp=Math.min(enemy.maxHP,enemy.hp+Math.floor(actual*enemy.lifesteal));

  if(enemy.rootTouched&&!enemy.dead){
    if((enemy.archId==='bruiser'||enemy.archId==='warden')&&rng()<0.30){
      applyStatus(G.hero,'vulnerable',1,3);
      addLog(`  ğŸŒ‘ Root-Touched corruption: Vulnerable (3s)`,'lstatus');
    }else if((enemy.archId==='shaman'||enemy.archId==='swarm')&&rng()<0.30){
      applyStatus(G.hero,'poison',1,4);
      addLog(`  ğŸŒ‘ Root-Touched eitr: Poison (4s)`,'lstatus');
    }
  }

  if(crit&&tier2Active&&arch&&arch.tier2Behavior==='dodgeAfterCrit'&&arch.tier2DodgeChance){
    enemy._tier2DodgePending=arch.tier2DodgeChance;
  }
  if(crit&&tier2Active&&arch&&arch.tier2Behavior==='exposeCritVuln'&&arch.tier2ExposeChance&&rng()<arch.tier2ExposeChance){
    applyStatus(h,'vulnerable',1,3);
    addLog(`  ğŸ¯ ${enemy.displayName||enemy.name} exposes weakness! Vulnerable`,'lstatus');
  }

  if(G.waveFlags.eEcho&&rng()<.25){
    const e2=Math.max(1,Math.floor(enemy.atk*.55)-h.def);
    heroDmg(e2,enemy,'echo');
    addLog(`  ğŸ”Š Echo! ${e2}`,'lhit');
  }

  if(G.tierFlags&&G.tierFlags.emberSparkChance&&G.wave>=(G.tierFlags.muspelheimTagFromWave||7)){
    if(rng()<G.tierFlags.emberSparkChance){
      const sparkDmg=Math.max(1,Math.floor(enemy.atk*0.15)-G.hero.def);
      heroDmg(sparkDmg,enemy,'ember');
      addLog(`  ğŸ”¥ Ember spark! ${sparkDmg} fire damage.`,'lstatus');
      applyStatus(G.hero,'bleed',1,2);
    }
  }

  if(enemy.signature&&typeof enemy.signature.apply==='function'){
    enemy.signature.apply(enemy,G.hero);
  }
  if(G.tierFlags&&G.tierFlags.eliteSecondPhase&&enemy.elite&&!enemy._secondPhaseActivated){
    if(enemy.hp<enemy.maxHP*0.40){
      enemy._secondPhaseActivated=true;
      enemy.atk=Math.floor(enemy.atk*1.20);
      enemy.spd=Math.floor(enemy.spd*1.15);
      addLog(`  â­ ${enemy.displayName||enemy.name} â€” SECOND WIND! +20% ATK, +15% SPD!`,'lcrit');
    }
  }
}

function onKill(enemy){
  addLog(`  ğŸ’€ ${enemy.displayName||enemy.name} slain!`,'ldeath');
  // Near-death kill narration
  if(G.hero.hp<G.hero.maxHP*0.25){
    NarrationEngine.onNearDeathKill();
  }
  NarrationEngine.onKill();
  if(G.waveFlags.enraged){
    G.enemies.filter(e=>!e.dead).forEach(e=>e.atk+=15);
    addLog(`  ğŸ˜¡ Enraged! +15 ATK!`,'lstatus');
  }
  G.waveGold+=ri(3,7);

  if(G.tierFlags&&G.tierFlags.killDropsMark){
    G.gold+=G.tierFlags.killDropsMark;
  }

  if(G.wave===12&&G.waveFlags&&G.waveFlags.rootKingRevive&&!enemy.isBoss&&!enemy._isEcho&&!enemy._rootKingRevived){
    setTimeout(()=>rootKingRevive(enemy),0);
  }

  if(G.tierFlags&&G.tierFlags.draugrEchoChance&&!enemy._isEcho&&!enemy._noEcho){
    if(rng()<G.tierFlags.draugrEchoChance){
      setTimeout(()=>draugrEchoRevive(enemy),0);
    }
  }

  trigBoon('onKill',G.hero,enemy);
}

function rootKingRevive(originalEnemy){
  if(!G||G.phase!=='BATTLE')return;
  const revivedHP=Math.max(1,Math.floor(originalEnemy.maxHP*0.25));
  const risen={...JSON.parse(JSON.stringify(originalEnemy)),id:originalEnemy.id+'_risen',hp:revivedHP,maxHP:revivedHP,displayName:'Risen: '+(originalEnemy.displayName||originalEnemy.name),name:'Risen: '+(originalEnemy.displayName||originalEnemy.name),dead:false,_isEcho:false,_rootKingRevived:true,_noEcho:true,actionMeter:0.3,statuses:{},elite:false};
  G.enemies.push(risen);
  addLog(`  ğŸœ NÃ­Ã°hÃ¶ggr's gnawing holds it â€” it rises again.`,'lstatus');
}

function draugrEchoRevive(originalEnemy){
  if(!G||G.phase!=='BATTLE')return;
  const echoHP=Math.floor(originalEnemy.maxHP*0.25);
  const echo={
    ...JSON.parse(JSON.stringify(originalEnemy)),
    id:originalEnemy.id+'_echo',
    hp:echoHP,maxHP:echoHP,
    displayName:'Echo: '+(originalEnemy.displayName||originalEnemy.name),
    name:'Echo: '+(originalEnemy.displayName||originalEnemy.name),
    dead:false,
    _isEcho:true,
    actionMeter:0.3,
    statuses:{},
    elite:false,
    _noEcho:true,
  };
  if(originalEnemy.archId==='frost'||originalEnemy.realmTier==='niflheim'){
    echo.statuses.slow={stacks:1,value:0,dur:4};
  }
  G.enemies.push(echo);
  addLog(`  ğŸ’€ The dead remember â€” ${originalEnemy.displayName||originalEnemy.name} rises!`,'lstatus');
}

function tickStatuses(unit,isHero){
  const bm=isHero?1.0:Math.max(1,passive('bleedMult')||1);
  const pm=isHero?1.0:Math.max(1,passive('poisonMult')||1);
  const vk=isHero?0:(hasTrait('venomkiss')?1:0);

  if(isHero&&hasTrait('open_wound')&&unit.statuses.bleed){heroDmg(1,null,'dot');}
  for(const [k,s] of Object.entries(unit.statuses)){
    if(!s)continue;
    if(k==='shield')continue;
    if(s.dur!==9999){
      s.dur--;
      if(s.dur<=0){delete unit.statuses[k];continue;}
    }
    if(k==='bleed'){
      let d=Math.floor((3+s.stacks)*bm);
      if(!isHero&&G.tierFlags&&G.tierFlags.dotDamageBonus){
        d=Math.floor(d*(1+G.tierFlags.dotDamageBonus));
      }
      if(isHero){const dr=passive('dotResist');if(dr)d=Math.floor(d*dr);const gdr=(effectiveStats()._gearDotResist||0);if(gdr)d=Math.floor(d*(1-gdr));const bm=(unit.dotResistMul_fromBlessings||1);if(bm&&bm!==1)d=Math.floor(d*bm);}
      if(isHero)heroDmg(d,null,'dot');
      else{unit.hp=Math.max(0,unit.hp-d);if(unit.hp<=0&&!unit.dead){unit.dead=true;onKill(unit);}if(G.waveFlags&&G.waveFlags.echoWounds){const pct=G.waveFlags.echoWoundsPct||0.25;const rd=Math.floor(d*pct);if(rd>0)heroDmg(rd,null,'dot');}}
    }
    if(k==='poison'){
      let d=Math.floor((2+s.stacks+vk)*pm);
      if(!isHero&&G.tierFlags&&G.tierFlags.dotDamageBonus){
        d=Math.floor(d*(1+G.tierFlags.dotDamageBonus));
      }
      if(isHero){const dr=passive('dotResist');if(dr)d=Math.floor(d*dr);const gdr=(effectiveStats()._gearDotResist||0);if(gdr)d=Math.floor(d*(1-gdr));const bm=(unit.dotResistMul_fromBlessings||1);if(bm&&bm!==1)d=Math.floor(d*bm);}
      if(isHero)heroDmg(d,null,'dot');
      else{unit.hp=Math.max(0,unit.hp-d);if(unit.hp<=0&&!unit.dead){unit.dead=true;onKill(unit);}if(G.waveFlags&&G.waveFlags.echoWounds){const pct=G.waveFlags.echoWoundsPct||0.25;const rd=Math.floor(d*pct);if(rd>0)heroDmg(rd,null,'dot');}}
    }
    if(k==='regen'&&isHero){
      const baseHeal=s.value||3;
      const regenBonus=(G.tierFlags&&G.tierFlags.regenBoonBonus)||0;
      const totalHeal=Math.floor(baseHeal*(1+regenBonus));
      healHero(totalHeal,'regen');
    }
  }
}

// â•â•â• END CONDITIONS â•â•â•
function checkEnd(){
  if(G.hero.hp<=0){
    clearInterval(G.interval);
    addLog('  ğŸ’€ Hero has fallen.','ldeath');
    heroFell();
    G.phase='GAME_OVER';
    renderAll();
    return true;
  }
  if(G.enemies.every(e=>e.dead)){
    clearInterval(G.interval);
    const baseGoldRaw=15+G.wave*3+(G.waveGold||0);
    const roadsideGoldMult=(G.roadside?.goldMult||1);
    let baseGold=Math.floor(baseGoldRaw*(G.waveGoldMult||1)*roadsideGoldMult);
    if(hasTrait('coin_scar'))baseGold=Math.floor(baseGold*1.15);
    G.gold+=baseGold;
    const xpEarned=20+G.wave*9;G.xp+=xpEarned;
    addLog(`ğŸ† Trial ${G.wave} complete! +${baseGold}á›‹${(G.roadside?.goldMult||1)>1?` (x${(G.roadside.goldMult).toFixed(2)})`:''} +${xpEarned}XP`,'lwave');
    G.activeTactic=null;G.waveGoldMult=1;
    checkLevelUp();
    G.rerollCost=10;
    G.enemies.filter(e=>e.elite).forEach(e=>{
      const heroSurvived=G.hero.hp>0;
      recordEliteEncounter(e.archId,heroSurvived,G._narratedNearDeath||false,G._critLandedThisWave||false);
    });
    G._critLandedThisWave=false;
    genDraft();
    const waveEndLine=MYTH_LINES.waveEnd[G.wave];
    if(waveEndLine) NarrationEngine.fire('waveEnd',waveEndLine,'lstatus');
    addNotchesToHeroGear(G.wave);
    G.forgeStallItem=genForgeStallItem(G.wave);
    G.phase='REWARDS';
    renderAll();
    return true;
  }
  return false;
}

function checkLevelUp(){
  while(G.xp>=G.xpNeeded){
    G.xp-=G.xpNeeded;G.level++;G.xpNeeded=Math.floor(G.xpNeeded*1.35);
    G.hero.maxHP+=18;G.hero.hp=Math.min(G.hero.maxHP,G.hero.hp+18);G.hero.atk+=3;G.hero.def+=1;
    addLog(`ğŸŒŸ Level Up â†’ Lv.${G.level}! (+18 HP +3 ATK +1 DEF)`,'laxiom');
    NarrationEngine.fire('levelUp',MYTH_LINES.levelUp,'lstatus');
  }
}

// â”€â”€â”€ RETIRE FLOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function computeEarnedEVs(trialOverride){
  const t = (typeof trialOverride === 'number') ? trialOverride : (G?.wave || 1);
  const lvl = (G?.level || 1);
  const gen = (G?.hero?.record?.gen || 1);
  const tier = (G?.ragnarÃ¶kActive || 0);

  const progress = Math.max(0, t - 1);
  const tierMult = 1 + (tier * 0.22);
  const genMult  = 1 + Math.min(0.80, (gen-1)*0.12);
  const s = (progress * 1.4 + lvl * 1.0) * tierMult * genMult;

  const clamp = (x,a,b)=>Math.max(a, Math.min(b, Math.floor(x)));

  return {
    hp:   clamp(s * 0.85, 0, 26),
    atk:  clamp(s * 0.65, 0, 20),
    def:  clamp(s * 0.55, 0, 18),
    spd:  clamp(s * 0.60, 0, 20),
    crit: clamp(lvl * 0.9 + tier * 0.8, 0, 12),
    eva:  clamp(lvl * 0.55 + progress * 0.22, 0, 10),
    acc:  clamp(lvl * 0.50 + progress * 0.20, 0, 10),
    ls:   clamp(lvl * 0.35 + tier * 0.25, 0, 8),
  };
}

function retireHero(trialOverride){
  const rec=G.hero.record;
  const trial=(typeof trialOverride==='number')?trialOverride:G.wave;
  const earnedEVs=computeEarnedEVs(trial);
  rec.runResult={
    outcome:'retired',wave:trial,
    boons:G.boons.map(b=>b.id),
    axioms:G.boons.filter(b=>b.rarity==='axiom').map(b=>b.id),
    level:G.level,earnedEVs,ts:Date.now()
  };
  assignBreedUses(rec, calcBreedUsesForRetire());
  const cap=evCap();
  EV_KEYS.forEach(k=>rec.evs[k]=Math.min(cap,(rec.evs[k]||0)+(earnedEVs[k]||0)));
  META.family[rec.id]=rec;
  if(META.retiredPool.length>=poolMax())META.retiredPool.shift();
  META.retiredPool.push(rec.id);
  const baseEssence=Math.floor(G.gold*.35)+trial*4;
  const essence=Math.floor(baseEssence*(G.roadside?.essenceMult||1));
  META.legacyEssence+=essence;
  if(G.interval)clearInterval(G.interval);
  addLog(`ğŸ› ${rec.name} sealed their saga at Trial ${trial}! +${essence} Minni.`,'laxiom');
  NarrationEngine.fire('generic',MYTH_LINES.retire,'laxiom');
  checkRagnarÃ¶kUnlock();
  saveMeta();
  showRetireRelicChoice(rec, essence);
}

function showImprintOffer(rec,axiomBoons,essence){
  const candidates=axiomBoons.slice(0,3);
  const chance=imprintChance();
  let html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;color:var(--gold);margin-bottom:8px">áš±áš¢áš¾ ECHO BINDING</div>
    <p style="color:var(--txt2);font-size:12px;margin-bottom:16px">${rec.name} carried Axiom knowledge. You may attempt to echo binding one as a heritable pattern trait.<br>
    <span style="color:var(--amber)">Echo Binding Chance: ${Math.round(chance*100)}%</span></p>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px">
    ${candidates.map(b=>{
      const traitMapping={'ax_crimson':'serrated','ax_ghost':'skirmisher','ax_harvest':'resilient','ax_wrath':'gambler','ax_iron_law':'ironblood','ax_echo':'swift_born','ax_aegis':'aegis','ax_opening':'lucky','ax_kinetic':'lucky','ax_fortress':'tenacious','ax_plague':'venomkiss','ax_mirror':'spite'};
      const tk=traitMapping[b.id]||rpick(GTRAIT_KEYS);
      const gt=GTRAITS[tk];
      return `<div class="imprint-card" onclick="tryImprint('${rec.id}','${tk}',${chance},'${b.id}')">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div><span style="font-size:14px">${b.icon}</span> <strong style="font-size:12px">${b.name}</strong></div>
          <div style="font-size:10px;color:var(--amber)">${Math.round(chance*100)}% chance</div>
        </div>
        <div style="font-size:10px;color:var(--txt3);margin-top:3px">â†’ Pattern: <span style="color:#d090ff">${gt?gt.icon+' '+gt.name:'Unknown'}</span>: ${gt?gt.desc:''}</div>
      </div>`;
    }).join('')}
    </div>
    <button class="btn btn-sm btn-ghost" style="width:100%" onclick="showRetireSummary(META.family['${rec.id}'],${essence},null)">Skip Echo Binding</button>`;
  showOverlayContent(html);
}

function tryImprint(heroId,traitKey,chance,boonId){
  const rec=META.family[heroId];if(!rec)return;
  const success=Math.random()<chance;
  if(success&&rec.traits.length<TRAIT_MAX_BASE){
    if(!rec.traits.includes(traitKey))rec.traits.push(traitKey);
    saveMeta();
    addLog(`ğŸ§¬ OATH SEALED! ${GTRAITS[traitKey]?.name||traitKey} is now hereditary!`,'laxiom');
  }else{
    addLog(`ğŸ§¬ The oath slips away. The knowledge fades...`,'lstatus');
  }
  showRetireSummary(rec,META.legacyEssence,null);
}

function showRetireSummary(rec,essence,earnedEVs){
  const ev=rec.evs;
  let html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;
              color:var(--gold);margin-bottom:8px">ğŸ› MEMORY BOUND</div>
    <div style="color:var(--txt2);font-size:13px;margin-bottom:6px">
      ${rec.name} has been added to the Memory Stones.
    </div>
    <div style="font-size:11px;color:var(--txt3);font-style:italic;margin-bottom:14px">
      "Let the blood carry the rest."
    </div>
    <div style="background:var(--bg2);border:1px solid var(--border2);border-radius:5px;padding:12px;margin-bottom:14px;text-align:left">
      <div style="font-size:10px;color:var(--txt3);letter-spacing:2px;margin-bottom:8px">SCARS / PATTERN</div>
      ${EV_KEYS.map(k=>`<div class="srow"><span class="sl">${k.toUpperCase()}_EV</span><span class="sv">${ev[k]||0} / ${evCap()}</span></div>`).join('')}
      ${rec.traits.length?`<div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:3px">${rec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:''}
    </div>
    <div style="color:var(--green);font-size:13px;margin-bottom:16px">+${essence} Minni added to lineage coffers.</div><div style="font-size:10px;color:var(--txt3);margin-bottom:10px">RagnarÃ¶k tiers unlock only on full victory (Trial 12 clear).</div>
    <div style="margin:0 0 14px">
      <label style="font-size:11px;color:var(--txt3);display:block;margin-bottom:6px;letter-spacing:1px;text-transform:uppercase">Difficulty (enemy stats)</label>
      <div style="display:flex;align-items:center;gap:10px">
        <input id="start-diff" type="range" min="0" max="2" step="0.1"
          value="${Number(UI.difficulty??1)}"
          oninput="onDifficultyInput(this.value,'start')"
          style="flex:1;accent-color:var(--amber)">
        <span id="start-diff-val" style="font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--gold)">x${Number(UI.difficulty??1).toFixed(1)}</span>
      </div>
      <div style="font-size:10px;color:var(--txt3);margin-top:4px">0 = trivial Â· 1 = default Â· 2 = brutal</div>
    </div>
    <div style="display:flex;gap:8px">
      <button class="btn btn-primary" style="flex:1" onclick="hideOverlay();showLegacy()">ğŸ› View Minni-HÃ¶ll</button>
      <button class="btn btn-green" style="flex:1" onclick="hideOverlay();showStartScreen()">â–¶ Begin New Saga</button>
    </div>`;
  showOverlayContent(html);
}

// â”€â”€â”€ DEATH FLOW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function heroFell(){
  const rec=G.hero.record;
  const salvageEarned=G.wave*2+G.boons.filter(b=>b.rarity==='axiom').length*5+Math.floor(G.boons.length/2);
  rec.runResult={outcome:'fallen',wave:G.wave,boons:G.boons.map(b=>b.id),axioms:G.boons.filter(b=>b.rarity==='axiom').map(b=>b.id),level:G.level,salvageEarned,ts:Date.now()};
  META.family[rec.id]=rec;
  META.fallenLedger.push(rec.id);
  META.salvage+=salvageEarned;
  saveMeta();
  addLog(`  The saga closed. áš±${salvageEarned} Rune-Shards recovered from ${rec.name}'s last stand.`,'ldeath');
  NarrationEngine.fire('generic',MYTH_LINES.death,'ldeath');
  updateMetaHeader();
}

// â”€â”€â”€ BREEDING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let BREED_SELECTED=[];
function breedHeroes(idA,idB){
  const recA=META.family[idA],recB=META.family[idB];
  if(!recA||!recB)return null;
  const cap=evCap();
  const VAR=5;
  const childEVs={};
  EV_KEYS.forEach(k=>{
    let val=Math.round(((recA.evs[k]||0)+(recB.evs[k]||0))/2+ri(-VAR,VAR));
    if(rng()<.08)val+=ri(5,12);
    childEVs[k]=Math.min(cap,Math.max(0,val));
  });
  const allParentTraits=[...new Set([...recA.traits,...recB.traits])];
  const sharedTraits=recA.traits.filter(t=>recB.traits.includes(t));
  const childTraits=[];
  for(const t of allParentTraits){
    const baseChance=sharedTraits.includes(t)?.75:.45;
    if(rng()<baseChance)childTraits.push(t);
  }
  if(rng()<mutationRate()){
    const unlocked=[...META.unlockedTraits];
    const available=unlocked.filter(t=>!childTraits.includes(t));
    if(available.length){
      const mut=rpick(available);
      childTraits.push(mut);
      addLog(`ğŸ§¬ MUTATION! New trait emerged: ${GTRAITS[mut]?.name||mut}!`,'laxiom');
    }
  }
  const finalTraits=childTraits.slice(0,TRAIT_MAX_BASE);
  const genNum=Math.max(recA.gen,recB.gen)+1;
  const topEvK=EV_KEYS.reduce((a,b)=>childEVs[a]>childEVs[b]?a:b);
  const evTagMap={hp:'Sustain',atk:'Execute',def:'Bulwark',spd:'Tempo',crit:'Crit',eva:'Tempo',acc:'Crit',ls:'Sustain'};
  const topTag=evTagMap[topEvK]||'Arcane';
  const childName=genName(genNum,topTag,[recA.name,recB.name]);
  const childRec=mkHeroRecord(childName,genNum,[recA.id,recB.id],childEVs,finalTraits);
  META.family[childRec.id]=childRec;
  saveMeta();
  return childRec;
}

// â”€â”€â”€ DRAFT SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function genDraft(){
  const owned=new Set(G.boons.map(b=>b.id));
  const curTags=new Set(G.boons.flatMap(b=>b.tags));
  const rw={common:40,uncommon:26,rare:16,epic:9,legendary:4,axiom:3};
  const boost=Math.min(G.wave,10);
  rw.common=Math.max(8,rw.common-boost*2);rw.rare+=boost;rw.epic+=Math.floor(boost/2);rw.axiom+=Math.floor(boost/3);

  const pool=BOONS.filter(b=>!owned.has(b.id));
  if(pool.length<1){G.draft=[];return;}

  const wfn=b=>{
    let w=rw[b.rarity]||5;
    const synCount=b.tags.filter(t=>curTags.has(t)).length;
    const syn=Math.min(2,synCount);
    w+=syn*6;
    if(synCount===0 && G.wave<=3 && (b.rarity==='common'||b.rarity==='uncommon')) w+=3;
    if(G.wave<=2&&b.rarity==='common')w+=20;
    return Math.max(1,w);
  };

  const picked=[],used=new Set();
  let att=0;
  while(picked.length<4&&att<300){
    att++;
    const b=rwgt(pool.filter(x=>!used.has(x.id)),wfn);
    if(b&&!used.has(b.id)){picked.push(b);used.add(b.id);}
  }
  G.draft=picked;
}

function pickBoon(id){
  const boon=BOONS.find(b=>b.id===id);if(!boon)return;
  G.boons.push(boon);
  applyBoonEffectsOnPick(boon);
  addLog(`ğŸ“œ Rune-Gift chosen: ${boon.name} [${boon.rarity}]`,'laxiom');
  if(boon.rarity==='axiom'){
    NarrationEngine.fire('generic',MYTH_LINES.axiomPicked,'laxiom');
  }
  G.draft=[];

  if(G.wave>=G.maxWaves){
    const rec=G.hero.record;
    rec.runResult={outcome:'victory',wave:G.wave,boons:G.boons.map(b=>b.id),axioms:G.boons.filter(b=>b.rarity==='axiom').map(b=>b.id),level:G.level,ts:Date.now()};
    assignBreedUses(rec, 2);
    const earnedEVs=computeEarnedEVs(G.wave);
    EV_KEYS.forEach(k=>rec.evs[k]=Math.min(evCap(),(rec.evs[k]||0)+(earnedEVs[k]||0)));
    META.family[rec.id]=rec;
    if(META.retiredPool.length>=poolMax())META.retiredPool.shift();
    META.retiredPool.push(rec.id);
    const victoryEssence=Math.floor(80*(G.roadside?.essenceMult||1));
    META.legacyEssence+=victoryEssence;
    rec.runResult.victoryEssence=victoryEssence;
    saveMeta();
    G.phase='VICTORY';
    checkRagnarÃ¶kUnlock();
    renderAll();
    return;
  }

  G.wave++;
  genWave();
  renderAll();
}

function doReroll(){
  const rerollCost=G.rerollCost + (hasTrait&&hasTrait('coin_scar')?5:0);
  if(G.gold<rerollCost)return;
  G.gold-=rerollCost;
  const increase=(G.tierFlags&&G.tierFlags.rerollCostIncreaseOverride)||6;
  G.rerollCost+=increase;
  genDraft();
  renderAll();
}

function shopBuy(item){
  const shop={
    heal:{cost:20,fn(){const h=Math.floor(G.hero.maxHP*.36);healHero(h,'shop');}},
    atk:{cost:14,fn(){G.hero.atk+=7;addLog(`â¬† +7 ATK`,'lheal');}},
    def:{cost:12,fn(){G.hero.def+=5;addLog(`â¬† +5 DEF`,'lheal');}},
    hp:{cost:10,fn(){G.hero.maxHP+=28;G.hero.hp=Math.min(G.hero.maxHP,G.hero.hp+28);addLog(`â¬† +28 MaxHP`,'lheal');}},
    spd:{cost:15,fn(){G.hero.spd+=10;addLog(`â¬† +10 SPD`,'lheal');}},
    crit:{cost:20,fn(){G.hero.critChance=Math.min(.9,G.hero.critChance+.06);addLog(`â¬† +6% Crit`,'lheal');}},
  };
  const s=shop[item];if(!s||G.gold<s.cost)return;
  G.gold-=s.cost;s.fn();renderAll();
}

// â•â•â• RUN RENDERING â•â•â•
function renderAll(){renderHero();renderRight();renderCenter();renderFooter();updateHeader();updateMetaHeader();}
function renderBattleUI(){renderHero();renderCenter();updateHeader();}

function updateHeader(){
  if(!G)return;
  document.getElementById('hdr-wave').textContent=`Trial ${G.wave}/${G.maxWaves}`;
  document.getElementById('hdr-lvl').textContent=`Lv.${G.level}Â·${G.xp}/${G.xpNeeded}XP`;
  document.getElementById('hdr-gold').textContent=G.gold;
  document.getElementById('hdr-salvage').textContent=META.salvage;
}

function updateMetaHeader(){
  const el1=document.getElementById('leg-essence');if(el1)el1.textContent=META.legacyEssence;
  const el2=document.getElementById('leg-salvage');if(el2)el2.textContent=META.salvage;
  const el3=document.getElementById('leg-relics');if(el3)el3.textContent=META.relics||0;
  const hs=document.getElementById('hdr-salvage');if(hs)hs.textContent=META.salvage;
  checkCodexUnlocks();
  updateRootDepthHeader();
}

function renderHero(){
  if(!G)return;
  const h=G.hero,es=effectiveStats();
  const hpPct=Math.max(0,h.hp/h.maxHP*100);
  const sh=h.statuses.shield;
  const shPct=sh?Math.min(100-hpPct,sh.value/h.maxHP*100):0;
  const pm=(h.permStats.atk||0),tmp=(h.tempStats.atk||0);
  let atkStr=`${Math.round(h.atk+pm)}`;if(tmp>0)atkStr+=` <span class="sdp">+${tmp}</span>`;
  const rec=h.record;

  let html='';
  if(rec){
    html+=`<div style="background:var(--bg2);border:1px solid var(--border);border-radius:4px;padding:5px 8px;margin-bottom:6px">
      <div style="font-size:11px;color:var(--txt3)">Gen ${rec.gen} Â· ${rec.name}</div>
      ${rec.traits.length?`<div style="display:flex;flex-wrap:wrap;gap:2px;margin-top:3px">${rec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait" title="${gt.desc}">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:''}
    </div>`;
  }


  const tact=(G.activeTactic && TACTIC_BY_ID[G.activeTactic]) || (G.pendingTactic && TACTIC_BY_ID[G.pendingTactic]);
  if(tact){
    const state=G.activeTactic?'Active':'Planned';
    const extra=G.activeTactic?'':` Â· á›‹${tact.cost} on start`;
    html+=`<div style="margin:6px 0 2px"><span class="tactic-pill">ğŸ§  ${state}: ${tact.icon} ${tact.name}${extra}</span></div>`;
  }

  html+=`<div class="sec-title">Hero Stats</div>
  <div class="bar-wrap">
    <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--txt3);margin-bottom:3px">
      <span>HP</span><span style="font-family:'Share Tech Mono',monospace">${h.hp}/${h.maxHP}${sh?' ğŸ›¡'+sh.value:''}</span>
    </div>
    <div id="hero-hp-bar" class="bar bar-hp"><div class="bar-fill" style="width:${hpPct}%"></div>${sh?`<div class="bar-shield-ovl" style="left:${hpPct}%;width:${shPct}%"></div>`:''}</div>
    <div class="bar bar-xp" style="margin-top:3px"><div class="bar-xp-fill" style="width:${(G.xp/G.xpNeeded*100)}%"></div></div>
    <div class="bar-txt">${h.hp}/${h.maxHP} HP Â· Lv.${G.level}</div>
  </div>
  <div style="margin-top:6px">
    <div class="srow"><span class="sl">âš” ATK</span><span class="sv">${atkStr}</span></div>
    <div class="srow"><span class="sl">ğŸ›¡ DEF</span><span class="sv">${Math.round(h.def)}</span></div>
    <div class="srow"><span class="sl">â„¹ Shield</span><span class="sv" style="font-size:10px">Shield carryover requires a Shield offhand.</span></div>
    ${h.ancestralMitigation?`<div class="srow"><span class="sl">ğŸ§¬ Ancestral Mitigation</span><span class="sv">${Math.round(h.ancestralMitigation*100)}%</span></div>`:''}
    ${h.houseBlessings?`<div class="srow" title="${houseBlessingsTooltip(h.houseBlessings)}"><span class="sl">ğŸ› Blessings</span><span class="sv" style="font-size:10px">${formatHouseBlessingsSummary(h.houseBlessings)}</span></div>`:''}
    <div class="srow"><span class="sl">âš¡ SPD</span><span class="sv">${Math.round(h.spd)}</span></div>
    <div class="srow"><span class="sl">ğŸ¯ Crit</span><span class="sv">${Math.round(es.critChance*100)}% / ${Math.round(es.critDmg*100)}%</span></div>
    <div class="srow"><span class="sl">ğŸ’ƒ Eva</span><span class="sv">${Math.round(h.evasion*100)}%</span></div>
    <div class="srow"><span class="sl">ğŸ§› LS</span><span class="sv">${Math.round(h.lifesteal*100)}%</span></div>
  </div>`;

  const sbadges=Object.entries(h.statuses).filter(([k,s])=>s&&(s.stacks>0||s.value>0));
  if(sbadges.length){
    html+=`<div class="sec-title" style="margin-top:7px">Statuses</div><div style="display:flex;flex-wrap:wrap;gap:2px">`;
    sbadges.forEach(([k,s])=>{
      const sd=STATUS[k];if(!sd)return;
      const lbl=k==='shield'?`${sd.name}:${s.value}`:`${sd.name}${s.stacks>1?' Ã—'+s.stacks:''}${s.dur!==9999?' ('+s.dur+'s)':''}`;
      html+=`<span class="sbadge ${sd.cls}" title="${sd.desc}">${sd.icon} ${lbl}</span>`;
    });
    html+=`</div>`;
  }

  if(G.boons.length){
    html+=`<div class="sec-title" style="margin-top:7px">Rune-Gifts (${G.boons.length})</div><div style="display:flex;flex-wrap:wrap;gap:3px">`;
    G.boons.forEach(b=>html+=`<div class="inv-item ii-${b.rarity}" title="${b.name}: ${b.desc}">${b.icon}</div>`);
    html+=`</div>`;
  }
  const gearSlots=G.hero.gear?Object.entries(G.hero.gear).filter(([slot,item])=>item):[];
  if(gearSlots.length){
    html+=`<div class="sec-title" style="margin-top:7px">Gear</div><div style="display:flex;flex-direction:column;gap:3px">`;
    gearSlots.forEach(([slot,item])=>{
      const sunTag=item.sundered?' <span style="color:var(--amber);font-size:9px">âš SUNDERED</span>':'';
      const notchPips=item.notches>0?('<span style="font-size:9px;color:var(--txt3)"> '+'â—†'.repeat(item.notches)+'</span>'):'';
      const tt=`${item.affixes.map(a=>a.label).join(', ')}${item.loreNote?'\n'+item.loreNote:''}`;
      html+=`<div title="${tt}" style="font-size:10px;color:${rarityColor(item.rarity)}">${slot.toUpperCase()}: ${item.name}${sunTag}${notchPips}</div>`;
    });
    html+=`</div>`;
  }
  document.getElementById('hero-content').innerHTML=html;
}

function renderRight(){
  if(!G){document.getElementById('right-content').innerHTML='';return;}
  const tagCounts={};G.boons.forEach(b=>b.tags.forEach(t=>{tagCounts[t]=(tagCounts[t]||0)+1;}));
  const topTags=Object.entries(tagCounts).sort((a,b)=>b[1]-a[1]).slice(0,8);
  let html='';
  if(topTags.length){
    html+=`<div class="sec-title">Build Tags</div><div style="display:flex;flex-wrap:wrap;gap:3px;margin-bottom:5px">`;
    topTags.forEach(([t,c])=>html+=`<span class="tag t-${t}">${t} Ã—${c}</span>`);
    html+=`</div>`;
  }
  const axioms=G.boons.filter(b=>b.rarity==='axiom');
  if(axioms.length){
    html+=`<div class="sec-title">Active Runes</div>`;
    axioms.forEach(b=>{
      html+=`<div style="background:#120a1e;border:1px solid #7a20b0;border-radius:4px;padding:5px 8px;margin:2px 0">
        <div style="font-size:11px;font-weight:700;color:#d050ff">${b.icon} ${b.name.replace('RUNE: ','')}</div>
        <div style="font-size:10px;color:#9060c0;margin-top:2px">${b.desc}</div>
      </div>`;
    });
  }
  if(G.boons.length){
    const rc={common:'#6060a0',uncommon:'#50a050',rare:'#6060d8',epic:'#a040c0',legendary:'#d4a017',axiom:'#d050ff'};
    html+=`<div class="sec-title">Rune-Gifts</div>`;
    G.boons.forEach(b=>html+=`<div style="margin:2px 0;font-size:11px" title="${b.desc}"><span style="color:${rc[b.rarity]||'#888'}">${b.icon}</span> ${b.name}</div>`);
  }
  if(G.roadside&&G.roadside.resolveRelics&&G.roadside.resolveRelics.length){
    html+=`<div class="sec-title">Resolve Relics</div>`;
    G.roadside.resolveRelics.forEach(r=>html+=`<div style="margin:2px 0;font-size:11px" title="${r.desc}">${r.icon} ${r.name}</div>`);
  }
  if(G.roadside&&G.roadside.debts&&G.roadside.debts.length){
    html+=`<div class="sec-title">Debts</div>`;
    G.roadside.debts.forEach(d=>html+=`<div style="margin:2px 0;font-size:11px" title="${d.desc}">${d.icon} ${d.name}</div>`);
  }
  if((G.roadside?.goldMult||1)>1||(G.roadside?.essenceMult||1)>1){
    html+=`<div style="font-size:10px;color:var(--txt3);margin-top:6px">Road Mult: Gold x${(G.roadside.goldMult||1).toFixed(2)}, Essence x${(G.roadside.essenceMult||1).toFixed(2)}</div>`;
  }
  document.getElementById('right-content').innerHTML=html||`<div style="color:var(--txt3);font-size:11px;margin-top:8px">No Rune-Gifts yet.</div>`;
}

function renderCenter(){
  if(!G)return;
  const el=document.getElementById('center-content');
  if(G.phase==='WAVE_PREVIEW')el.innerHTML=renderWavePreview();
  else if(G.phase==='BATTLE')el.innerHTML=renderBattle();
  else if(G.phase==='REWARDS')el.innerHTML=renderRewards();
  else if(G.phase==='GAME_OVER'||G.phase==='VICTORY')el.innerHTML=renderEndScreen();
}

function renderWavePreview(){
  const isBoss=G.bossWaves.includes(G.wave);
  const ep=G.enemies.reduce((s,e)=>s+e.hp/8+e.atk*1.8+e.def*.8,0);
  const hp=G.hero.maxHP/8+G.hero.atk*1.8+G.hero.def*.8+G.boons.length*15;
  const diff=Math.min(5,Math.max(1,Math.ceil(ep/Math.max(1,hp)*2)));
  const diffColors=['#50a050','#80a030','#a08030','#a04020','#c01010'];
  const diffLabels=['Trivial','Easy','Moderate','Hard','Brutal'];

  let h=`<div class="slide-in" style="padding:16px">`;
  if(G.roadsideAvailable){
    h+=`<div class="retire-banner">
      <div class="retire-banner-title">ğŸ”¥ THE WEAVER'S ROADSIDE FIRE</div>
      <div style="font-size:11px;color:var(--txt2);margin-bottom:8px">I tend the roadside kiln and offer three workings: Water, Clay, or Ash.</div>
      <button class="btn btn-gold btn-sm" onclick="showRoadsideFire()">ğŸ”¥ Approach the Fire</button>
    </div>`;
  }
  h+=`<div style="display:flex;align-items:center;gap:12px;margin-bottom:16px">
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;color:${isBoss?'var(--amber)':'var(--cyan)'}">${isBoss?'â­ BOSS â€” ':''}Trial ${G.wave}</div>
    <div style="display:flex;gap:3px;align-items:center">
      ${Array(5).fill(0).map((_,i)=>`<div class="diff-pip${i<diff?' dp-on':''}" ${i<diff?`style="background:${diffColors[diff-1]};border-color:${diffColors[diff-1]}"`:''}></div>`).join('')}
      <span style="font-size:11px;color:${diffColors[diff-1]};margin-left:5px;font-weight:700">${diffLabels[diff-1]}</span>
    </div>
  </div>`;

  if(G.waveTraits.length){
    h+=`<div class="sec-title">Omens</div>`;
    G.waveTraits.forEach(t=>{
      h+=`<div class="trait-card"><div class="ticon">${t.icon}</div><div><div class="tname">${t.name}</div><div class="tdesc">${t.desc}</div></div></div>`;
    });
    h+=`<div style="height:8px"></div>`;
  }

  const activeTier=G.ragnarÃ¶kActive||0;
  if(activeTier>0){
    const activeTiers=RAGNARÃ–K_TIERS.slice(0,activeTier);
    h+=`
      <div class="sec-title" style="margin-top:10px">
        ${rootDepthIcon(activeTier)} Root Depth ${activeTier} â€” Active Omens
        <button onclick="
          var tl=document.getElementById('tier-list-wave');
          tl.style.display=(tl.style.display==='none'?'block':'none');
        " style="float:right;background:none;border:none;color:var(--txt3);cursor:pointer;font-size:10px;margin-top:2px">
          Show/Hide
        </button>
      </div>
      <div id="tier-list-wave" style="display:none;margin-bottom:8px">
        ${activeTiers.map(t=>`
          <div style="font-size:10px;color:var(--txt3);margin:2px 0;padding:3px 6px;
                      background:var(--bg2);border-radius:3px;border-left:2px solid var(--border2)">
            <span style="color:var(--amber);font-weight:700">${t.tier}.</span>
            ${t.name} â€” <em>${t.omen}</em>
          </div>
        `).join('')}
      </div>
    `;
  }


  // Tactics (cost paid when you start the trial)
  if(G.tacticOffers && G.tacticOffers.length){
    h+=`<div class="sec-title">Tactics</div>`;
    h+=`<div class="tactic-grid">`+G.tacticOffers.map(t=>{
      const affordable = (G.gold>=t.cost);
      const sel = (G.pendingTactic===t.id);
      const cls = `tactic-card${sel?' sel':''}${!affordable?' disabled':''}`;
      const on = affordable ? `selectPendingTactic('${t.id}')` : '';
      return `<div class="${cls}" ${on?`onclick="${on}"`:''} title="${t.desc}">
        <div class="tactic-top">
          <div class="tactic-name">${t.icon} ${t.name}</div>
          <div class="tactic-cost">á›‹${t.cost}</div>
        </div>
        <div class="tactic-desc">${t.desc}</div>
      </div>`;
    }).join('')+`</div>`;
    if(G.pendingTactic){
      const t=TACTIC_BY_ID[G.pendingTactic];
      if(t){
        h+=`<div class="tactic-note"><span class="tactic-pill">Selected: ${t.icon} ${t.name} Â· costs á›‹${t.cost} on start</span>
          <button class="btn btn-sm" style="margin-left:8px;background:var(--bg2);border:1px solid var(--border2);color:var(--txt2)" onclick="clearPendingTactic()">Clear</button>
        </div>`;
      }
    } else {
      h+=`<div class="tactic-note">Pick one tactic (you pay when you start the trial).</div>`;
    }
    h+=`<div style="height:10px"></div>`;
  }

  h+=`<div class="sec-title">Enemy Lineup (${G.enemies.length} units)</div>`;
  G.enemies.forEach(e=>{
    const rootBorder=e.rootTouched?'border-color:#4a1a6a;background:#0e0818;box-shadow:0 0 8px rgba(100,20,140,.3)':'';
    h+=`<div class="enemy-card${e.elite?' ec-elite':''}" style="${rootBorder}">
      <div class="eicon" style="background:${e.col}22;border:1px solid ${e.col}55">${e.icon}</div>
      <div class="einfo">
        <div class="ename" style="color:${e.elite?'var(--amber)':'var(--txt)'}">
          ${e.displayName||e.name}
          ${e.namedElite?'<span style="font-size:9px;color:var(--amber);margin-left:6px;font-style:italic">â€” A familiar name returns.</span>':''}
        </div>
        <div class="etrait">â—ˆ ${e.norseName?`<em style="color:var(--txt3)">${e.norseName}</em> â€” `:''}${e.trait}: ${e.td}</div>
        <div class="estats">HP:${e.hp} ATK:${e.atk} DEF:${e.def} SPD:${e.spd}</div>
        ${e.signature?`<div style="font-size:10px;color:var(--amber);margin-top:3px;border-top:1px solid rgba(240,168,40,.2);padding-top:3px">â­ ${e.signature.name}: ${e.signature.desc}</div>`:''}
      </div>
    </div>`;
  });
  h+=`</div>`;
  return h;
}

function renderBattle(){
  const alive=G.enemies.filter(e=>!e.dead),dead=G.enemies.filter(e=>e.dead);
  let h=`<div style="padding:12px">
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
      <span style="font-weight:800;font-size:14px;color:var(--red)" class="pulse">âš” BATTLE â€” TRIAL ${G.wave}</span>
    </div>`;

  alive.forEach(e=>{
    const hp=Math.max(0,e.hp/e.maxHP*100),shv=e.statuses.shield,shpct=shv?Math.min(100-hp,shv.value/e.maxHP*100):0;
    const sbs=Object.entries(e.statuses).filter(([k])=>e.statuses[k]&&k!=='shield'&&e.statuses[k].stacks>0);
    h+=`<div class="enemy-card${e.elite?' ec-elite':''}${e.rootTouched?' ec-root-touched':''}">
      <div class="eicon" style="background:${e.col}22;border:1px solid ${e.col}55">${e.icon}</div>
      <div class="einfo">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="ename" style="color:${e.elite?'var(--amber)':'var(--txt)'}">${e.displayName||e.name}</div>
          <div style="font-size:10px;color:var(--txt3);font-family:'Share Tech Mono',monospace">${e.hp}/${e.maxHP}${shv?' ğŸ›¡'+shv.value:''}</div>
        </div>
        <div id="enemy-hp-bar-${e.id}" class="bar bar-hp enemy-hp-bar">
          <div class="bar-fill" style="width:${hp}%"></div>
          ${shv ? `<div class="bar-shield-ovl" style="left:${hp}%;width:${shpct}%"></div>` : ``}
        </div>
        ${sbs.length?`<div style="margin-top:3px">${sbs.map(([k,s])=>{const sd=STATUS[k];return sd?`<span class="sbadge ${sd.cls}" style="font-size:9px;padding:1px 4px">${sd.icon}${s.stacks>1?' Ã—'+s.stacks:''}</span>`:''}).join('')}</div>`:''}
      </div>
    </div>`;
  });

  if(dead.length){
    h+=`<div style="margin-top:4px;opacity:.3">${dead.map(e=>`<div style="font-size:11px;color:var(--txt3);padding:1px">â˜  ${e.name}</div>`).join('')}</div>`;
  }

  h+=`</div>`;
  return h;
}

function renderRewards(){
  const shop=[
    {id:'heal',icon:'ğŸ’š',name:'Heal',cost:20,desc:'Restore 36% HP'},
    {id:'atk',icon:'âš”',name:'+ATK',cost:14,desc:'+7 Attack'},
    {id:'def',icon:'ğŸ›¡',name:'+DEF',cost:12,desc:'+5 Defense'},
    {id:'hp',icon:'â¤',name:'+HP',cost:10,desc:'+28 MaxHP'},
    {id:'spd',icon:'ğŸ’¨',name:'+SPD',cost:15,desc:'+10 Speed'},
    {id:'crit',icon:'ğŸ¯',name:'+CRIT',cost:20,desc:'+6% Crit'},
  ];
  const hpPct=Math.max(0,G.hero.hp/G.hero.maxHP*100);
  const showForge=!!(G.forgeStallItem||hasSunderedGear());
  let h=`<div class="slide-in" style="padding:16px">
    <div style="font-size:16px;font-weight:800;color:var(--green);margin-bottom:12px">ğŸ† Trial ${G.wave} Complete!</div>
    <div style="display:grid;grid-template-columns:1fr 1fr${showForge?' 1fr':''};gap:14px">`;

  h+=`<div>
    <div class="sec-title">á›‹ Offerings (á›‹${G.gold} Saga-Marks)</div>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px">
      ${shop.map(s=>`<div class="shop-btn${G.gold<s.cost?' sb-disabled':''}" onclick="shopBuy('${s.id}')" title="${s.desc}">
        <div class="sb-name">${s.icon} ${s.name}</div><div class="sb-cost">á›‹${s.cost}</div><div class="sb-desc">${s.desc}</div>
      </div>`).join('')}
    </div>
    ${(()=>{
      if(!(G.tierFlags&&G.tierFlags.cursedBargainInShop&&!G.cursedBargainUsedThisWave))return '';
      const bargain=G._waveBargainOffer||(G._waveBargainOffer=rpick(CURSED_BARGAINS));
      return `
        <div style="margin-top:10px;border-top:1px solid rgba(220,60,20,.3);padding-top:10px">
          <div class="sec-title" style="color:var(--amber)">âš  The Norns Offer a Bargain</div>
          <div style="background:#120a06;border:1px solid rgba(220,60,20,.4);border-radius:5px;padding:10px;margin:4px 0">
            <div style="font-weight:700;color:var(--amber);margin-bottom:3px">${bargain.icon} ${bargain.name}</div>
            <div style="font-size:11px;color:var(--txt2);margin-bottom:8px">${bargain.desc}</div>
            <button class="btn btn-sm btn-danger${(!bargain.isFree&&G.gold<bargain.cost)?' sb-disabled':''}" onclick="takeCursedBargain('${bargain.id}')">Accept${bargain.isFree?'':` (á›‹${bargain.cost})`}</button>
          </div>
        </div>
      `;
    })()}
    <div style="margin-top:8px;font-size:10px;color:var(--txt3)">HP: <span style="color:${hpPct>60?'var(--green)':hpPct>30?'var(--amber)':'var(--red)'}">${G.hero.hp}/${G.hero.maxHP} (${Math.round(hpPct)}%)</span></div>
  </div>`;

  h+=`<div>
    <div class="sec-title">ğŸ“œ Rune-Gift Draft â€” Choose one omen.</div>
    ${G.draft.length?G.draft.map(b=>`
      <div class="boon-card rc-${b.rarity}" onclick="pickBoon('${b.id}')" style="margin-bottom:6px">
        <div class="boon-rar rar-${b.rarity}">${b.rarity.toUpperCase()}</div>
        <div><span style="font-size:14px">${b.icon}</span> <span class="boon-name">${b.name}</span></div>
        <div class="boon-desc" style="margin-top:3px">${b.desc}</div>
        <div style="display:flex;flex-wrap:wrap;gap:2px;margin-top:4px">${b.tags.map(t=>`<span class="tag t-${t}">${t}</span>`).join('')}</div>
      </div>`).join(''):`<div style="color:var(--txt3);font-size:12px">No more Rune-Gifts!</div>`}
    ${G.draft.length?`<button class="btn btn-sm btn-ghost" style="width:100%;margin-top:4px" onclick="doReroll()">ğŸ”® Seek Another Omen (á›‹${G.rerollCost})${G.gold<G.rerollCost?' â€” need Saga-Marks':''}</button>`:''}
  </div>`;

  if(showForge){
    h+=`<div>
      <div class="sec-title">âš’ Forge Stall</div>
      ${G.forgeStallItem?`
        <div style="background:var(--bg2);border:1px solid ${rarityBorderColor(G.forgeStallItem.rarity)};border-radius:5px;padding:10px;margin-bottom:8px">
          <div style="font-size:9px;font-weight:700;color:${rarityColor(G.forgeStallItem.rarity)};margin-bottom:3px">${G.forgeStallItem.rarity.toUpperCase()}</div>
          <div style="font-weight:700;font-size:12px">${G.forgeStallItem.name}</div>
          ${G.forgeStallItem.loreNote?`<div style="font-size:9px;color:var(--txt3);font-style:italic;margin-top:2px">${G.forgeStallItem.loreNote}</div>`:''}
          <div style="font-size:10px;color:var(--txt2);margin-top:4px">${G.forgeStallItem.affixes.map(a=>a.label).join(' Â· ')}</div>
          <div style="font-size:9px;color:var(--txt3);margin-top:3px">Slot: ${G.forgeStallItem.slot.toUpperCase()}${G.hero.gear&&G.hero.gear[G.forgeStallItem.slot]?` Â· Replaces: ${G.hero.gear[G.forgeStallItem.slot].name}`:' Â· Slot empty'}</div>
          <button class="btn btn-sm btn-amber${G.gold<gearCost(G.forgeStallItem)?' sb-disabled':''}" style="margin-top:8px;width:100%" onclick="buyGear()">Equip (á›‹${gearCost(G.forgeStallItem)})</button>
        </div>
      `:'<div style="font-size:11px;color:var(--txt3)">Nothing forged this trial.</div>'}
      ${hasSunderedGear()?`
        <div style="margin-top:8px;border-top:1px solid var(--border);padding-top:8px">
          <div style="font-size:10px;color:var(--amber);font-weight:700;margin-bottom:4px">âš’ Recondition</div>
          ${Object.entries(G.hero.gear||{}).filter(([s,item])=>item?.sundered).map(([slot,item])=>`
            <div style="margin:4px 0;font-size:11px;display:flex;justify-content:space-between;align-items:center">
              <span style="color:var(--amber)">${item.name}</span>
              <button class="btn btn-sm btn-salvage${META.salvage<10?' sb-disabled':''}" onclick="reconditionGear('${slot}')">áš±10</button>
            </div>
          `).join('')}
        </div>
      `:''}
    </div>`;
  }

  h+=`</div></div>`;
  return h;
}

function renderEndScreen(){
  const won=G.phase==='VICTORY';
  const rec=G.hero.record;
  const tagCounts={};G.boons.forEach(b=>b.tags.forEach(t=>{tagCounts[t]=(tagCounts[t]||0)+1;}));
  const topTags=Object.entries(tagCounts).sort((a,b)=>b[1]-a[1]).slice(0,5);
  const score=G.level*50+G.boons.length*30+(won?300:0)+G.wave*20;

  const heroName=rec?.name||'the Champion';
  const outcomeHeader=won?'â­ SAGA COMPLETE':'â˜  SAGA CLOSED';
  const outcomeColor=won?'var(--gold)':'var(--red)';
  const outcomeShadow=won?'rgba(212,160,23,.6)':'rgba(224,64,64,.5)';
  const outcomeSubtext=won
    ? `All twelve Trials survived. This generation holds. ${heroName} may now rest.`
    : `Trial ${G.wave} â€” ${heroName}'s saga ends here. The thread passes to the next.`;

  return `<div class="slide-in" style="padding:24px;text-align:center">
    <div style="font-family:'Orbitron',sans-serif;font-size:22px;font-weight:900;
                color:${outcomeColor};text-shadow:0 0 20px ${outcomeShadow};margin-bottom:8px">
      ${outcomeHeader}
    </div>
    <div style="color:var(--txt2);margin-bottom:16px;font-size:12px;font-style:italic">
      ${outcomeSubtext}
    </div>
    <div style="display:inline-block;background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:14px 20px;margin-bottom:16px;text-align:left;min-width:260px">
      <div style="font-size:10px;color:var(--txt3);letter-spacing:2px;text-transform:uppercase;margin-bottom:8px">Saga Summary</div>
      <div style="display:flex;justify-content:space-between;margin:3px 0;font-size:12px"><span style="color:var(--txt3)">Trials Survived</span><span style="font-weight:700">${G.wave}/${G.maxWaves}</span></div>
      <div style="display:flex;justify-content:space-between;margin:3px 0;font-size:12px"><span style="color:var(--txt3)">Hero Level</span><span style="font-weight:700">${G.level}</span></div>
      <div style="display:flex;justify-content:space-between;margin:3px 0;font-size:12px"><span style="color:var(--txt3)">Rune-Gifts</span><span style="font-weight:700">${G.boons.length}</span></div>
      <div style="display:flex;justify-content:space-between;margin:3px 0;font-size:12px"><span style="color:var(--txt3)">Score</span><span style="font-weight:700;color:var(--gold)">${score}</span></div>
      ${rec?.traits?.length?`<div style="margin-top:8px;border-top:1px solid var(--border);padding-top:6px;display:flex;flex-wrap:wrap;gap:2px">${rec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:''}
      ${topTags.length?`<div style="margin-top:8px;display:flex;flex-wrap:wrap;gap:2px">${topTags.map(([t,c])=>`<span class="tag t-${t}">${t} Ã—${c}</span>`).join('')}</div>`:''}
    </div>
    <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
      <button class="btn btn-gold" onclick="showLegacy()">ğŸ› View Minni-HÃ¶ll</button>
      <button class="btn btn-primary" onclick="showStartScreen()">â–¶ Begin New Saga</button>
    </div>
  </div>`;
}

function renderFooter(){
  if(!G)return;
  const ftr=document.getElementById('ftr-btns'),info=document.getElementById('ftr-info');
  if(G.phase==='WAVE_PREVIEW'){
    ftr.innerHTML=`<button class="btn btn-amber rune-glow-amber" onclick="startBattle()">âš” Begin Trial ${G.wave}</button>`;
    info.textContent=`á›‹ ${G.gold} ${LEX.sagaMarks} Â· ${G.wave<G.maxWaves?'Next: Trial '+(G.wave+1):'Final Trial!'}`;
  }else if(G.phase==='BATTLE'){
    ftr.innerHTML=`<span style="color:var(--txt3);font-size:12px;animation:pulse2 1.2s infinite">âš” Battle in progress...</span>`;
    info.textContent=`Tick:${G.tick} Â· Enemies:${G.enemies.filter(e=>!e.dead).length}/${G.enemies.length}`;
  }else if(G.phase==='REWARDS'){
    ftr.innerHTML=`<span style="color:var(--txt3);font-size:12px">Choose a Rune-Gift or use the offerings.</span>`;
    info.textContent=`á›‹ ${G.gold}`;
  }else{
    ftr.innerHTML='';info.textContent='';
  }
}

// â•â•â• LEGACY SCREEN â•â•â•
let currentLegacyTab='pool';
let TREE_VIEW={mode:'legacy',showClosed:false};
function setTreeMode(mode){TREE_VIEW.mode=(mode==='all')?'all':'legacy';renderFamilyTree();}
function toggleTreeClosed(){TREE_VIEW.showClosed=!TREE_VIEW.showClosed;renderFamilyTree();}
function showLegacy(){
  closeDrawers();
  document.getElementById('legacy-screen').style.display='flex';
  setLegacyTab(currentLegacyTab);
  updateMetaHeader();
  syncChromeHeights();
}
function hideLegacy(){
  document.getElementById('legacy-screen').style.display='none';
  closeDrawers();
  syncChromeHeights();
}
function setLegacyTab(tab){
  currentLegacyTab=tab;
  ['pool','breed','fallen','tree','upgrades','codex'].forEach(t=>{
    document.getElementById('ltab-'+t).className='ltab'+(t===tab?' active':'');
  });
  const lc=document.getElementById('legacy-content');
  if(tab==='pool')lc.innerHTML=renderRetiredPool();
  else if(tab==='breed')lc.innerHTML=renderBreeding();
  else if(tab==='fallen')lc.innerHTML=renderFallenLedger();
  else if(tab==='tree')renderFamilyTree();
  else if(tab==='upgrades')lc.innerHTML=renderRunesmith();
  else if(tab==='codex')lc.innerHTML=codexHTML();
}

// â”€â”€â”€ RETIRED POOL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function evColor(k){return{hp:'#40e078',atk:'#f0a828',def:'#4878f0',spd:'#c080ff',crit:'#f0a828',eva:'#30d0c0',acc:'#30d0c0',ls:'#d070d8'}[k]||'#888';}

function toggleBreedSelect(id){
  const idx=BREED_SELECTED.indexOf(id);
  if(idx>=0)BREED_SELECTED.splice(idx,1);
  else{if(BREED_SELECTED.length>=2)BREED_SELECTED.shift();BREED_SELECTED.push(id);}
  setLegacyTab('pool');
}

function renderRetiredPool(){
  const heroes=META.retiredPool.map(id=>META.family[id]).map(r=>{if(r){const u=getBreedUses(r);if(typeof r.breedUsesMax!=='number' || r.breedUsesMax<=0){r.breedUsesMax=u.max; r.breedUsesLeft=u.left;} } return r;}).filter(r=>r && canHeroBreed(r.id));
  if(!heroes.length){
    return `<div style="text-align:center;padding:40px;color:var(--txt3)">
      <div style="font-size:32px;margin-bottom:12px">ğŸ›</div>
      <div style="font-size:13px">No memory stones yet.</div>
      <div style="font-size:11px;margin-top:6px">Complete a saga and bind a memory stone instead of pressing onward.</div>
    </div>`;
  }
  let h=`<div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
      <div>
        <div style="font-size:16px;font-weight:700;color:var(--gold)">Active Memory Stones</div>
        <div style="font-size:11px;color:var(--txt3);margin-top:2px">${heroes.length}/${poolMax()} active stones Â· Select two strands to bind</div>
      <div style="font-size:10px;color:var(--txt3);margin-top:6px">Shows stones with binds remaining. Spent stones remain visible in the Family Tree as â˜† Spent.</div>
      </div>
      <button class="btn btn-green btn-sm" onclick="setLegacyTab('breed')">âš— Bind â†’</button>
    </div>
    <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:12px">`;
  heroes.forEach(rec=>{
    const sel=BREED_SELECTED.includes(rec.id);
    const selIdx=BREED_SELECTED.indexOf(rec.id);
    const selClass=selIdx===0?' hc-parent-a':selIdx===1?' hc-parent-b':'';
    const derived=evDerived(rec.evs);
    const uses=getBreedUses(rec);
    h+=`<div class="hero-card${sel?selClass:''}" onclick="toggleBreedSelect('${rec.id}')">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:5px">
        <div>
          <div class="hc-gen">GEN ${rec.gen}${sel?' â€” STRAND '+(selIdx===0?'A':'B'):''}</div>
          <div class="hc-name">${rec.name}</div>
        </div>
        ${sel?`<div style="font-size:18px;color:${selIdx===0?'#4878f0':'var(--violet)'}">â˜…</div>`:''}
        <button onclick="removeFromRetiredPool(event,'${rec.id}')" title="Remove from pool" style="background:rgba(224,64,64,.12);border:1px solid rgba(224,64,64,.35);color:var(--red);padding:2px 6px;border-radius:4px;font-size:10px;cursor:pointer">âœ•</button>
      </div>
      <div class="hc-stats">HP:${derived.maxHP} ATK:${Math.round(derived.atk)} DEF:${Math.round(derived.def)} SPD:${derived.spd}</div>
      <div class="hc-stats">CRIT:${Math.round(derived.critChance*100)}% EVA:${Math.round(derived.evasion*100)}%</div>
      <div class="hc-stats" style="margin-top:3px">Breeds left: <span style="color:var(--gold);font-weight:800">${uses.left}/${uses.max}</span></div>
      ${rec.equippedGear&&Object.values(rec.equippedGear).some(Boolean)?`<div style="font-size:9px;color:var(--txt3);margin-top:4px">âš’ ${Object.values(rec.equippedGear).filter(Boolean).map(i=>`<span style="color:${rarityColor(i.rarity)}">${i.name}</span>`).join(', ')} bequeathed</div>`:''}
      ${rec.traits.length?`<div style="display:flex;flex-wrap:wrap;gap:2px;margin-top:5px">${rec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait" title="${gt.desc}">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:''}
      <div style="margin-top:8px">
        ${EV_KEYS.map(k=>`<div style="display:flex;align-items:center;gap:5px;margin:2px 0">
          <div style="font-size:9px;color:var(--txt3);width:28px;text-transform:uppercase">${k}</div>
          <div class="ev-bar" style="flex:1"><div class="ev-fill" style="width:${Math.round((rec.evs[k]||0)/evCap()*100)}%;background:${evColor(k)}"></div></div>
          <div style="font-size:9px;color:var(--txt3);width:22px;text-align:right">${rec.evs[k]||0}</div>
        </div>`).join('')}
      </div>
      ${rec.runResult?`<div style="font-size:10px;color:var(--txt3);margin-top:5px;border-top:1px solid var(--border);padding-top:4px">Trial ${rec.runResult.wave} Â· ${rec.runResult.boons?.length||0} Rune-Gifts Â· Lv.${rec.runResult.level||1}</div>`:''}
    </div>`;
  });
  h+=`</div></div>`;
  return h;
}

// â”€â”€â”€ BREEDING PANEL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBreeding(){
  if(BREED_SELECTED.length<2){
    return `<div style="text-align:center;padding:40px;color:var(--txt3)">
      <div style="font-size:32px;margin-bottom:12px">âš—</div>
      <div style="font-size:13px">Select two memory stones first.</div>
      <button class="btn btn-gold btn-sm" style="margin-top:14px" onclick="setLegacyTab('pool')">â† Active Stones</button>
    </div>`;
  }
  const recA=META.family[BREED_SELECTED[0]],recB=META.family[BREED_SELECTED[1]];
  if(!recA||!recB||isFallenHero(recA.id)||isFallenHero(recB.id))return `<div style="color:var(--red);padding:20px">A fallen hero cannot enter the Memory Binding Chamber. Their saga is closed.</div>`;
  const usesA=getBreedUses(recA), usesB=getBreedUses(recB);

  const cap=evCap();
  const previewEVs={};EV_KEYS.forEach(k=>previewEVs[k]=Math.min(cap,Math.round(((recA.evs[k]||0)+(recB.evs[k]||0))/2)));
  const derived=evDerived(previewEVs);
  const sharedTraits=recA.traits.filter(t=>recB.traits.includes(t));
  const allTraits=[...new Set([...recA.traits,...recB.traits])];

  let h=`<div>
    <div style="font-size:11px;color:var(--txt3);font-style:italic;margin-bottom:12px">
      You choose the next thread.
    </div>
    <div style="font-size:16px;font-weight:700;color:var(--gold);margin-bottom:16px">âš— Memory Binding Chamber</div>
    <div style="display:grid;grid-template-columns:1fr 40px 1fr;gap:10px;align-items:center;margin-bottom:20px">
      <div class="child-preview" style="background:rgba(72,120,240,.08);border-color:rgba(72,120,240,.4)">
        <div style="font-size:10px;color:#80a8ff;letter-spacing:2px;margin-bottom:5px">PARENT A</div>
        <div style="font-weight:700;font-size:14px">${recA.name}</div>
        <div style="font-size:10px;color:var(--txt3)">Gen ${recA.gen}</div><div style="font-size:10px;color:var(--txt3);margin-top:2px">Breeds left: <span style="color:#80a8ff;font-weight:800">${usesA.left}/${usesA.max}</span></div>
        <div style="margin-top:5px;display:flex;flex-wrap:wrap;gap:2px">${recA.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait">${gt.icon}</span>`:''}).join('')}</div>
      </div>
      <div style="text-align:center;font-size:20px;color:var(--violet)">âš—</div>
      <div class="child-preview" style="background:rgba(144,80,232,.08);border-color:rgba(144,80,232,.4)">
        <div style="font-size:10px;color:#c080ff;letter-spacing:2px;margin-bottom:5px">PARENT B</div>
        <div style="font-weight:700;font-size:14px">${recB.name}</div>
        <div style="font-size:10px;color:var(--txt3)">Gen ${recB.gen}</div><div style="font-size:10px;color:var(--txt3);margin-top:2px">Breeds left: <span style="color:#c080ff;font-weight:800">${usesB.left}/${usesB.max}</span></div>
        <div style="margin-top:5px;display:flex;flex-wrap:wrap;gap:2px">${recB.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait">${gt.icon}</span>`:''}).join('')}</div>
      </div>
    </div>

    <div class="child-preview" style="margin-bottom:20px">
      <div style="font-size:11px;color:var(--violet);letter-spacing:2px;margin-bottom:8px">CHILD PREVIEW (approximate)</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
        <div>
          <div style="font-size:10px;color:var(--txt3);margin-bottom:6px">DERIVED STATS</div>
          ${[['MaxHP',derived.maxHP],['ATK',Math.round(derived.atk)],['DEF',Math.round(derived.def)],['SPD',derived.spd],['Crit',Math.round(derived.critChance*100)+'%'],['Eva',Math.round(derived.evasion*100)+'%']]
            .map(([l,v])=>`<div class="srow"><span class="sl" style="font-size:11px">${l}</span><span class="sv" style="font-size:11px">${v}</span></div>`).join('')}
        </div>
        <div>
          <div style="font-size:10px;color:var(--txt3);margin-bottom:6px">EV INHERITANCE</div>
          ${EV_KEYS.map(k=>`<div style="display:flex;align-items:center;gap:4px;margin:2px 0">
            <div style="font-size:9px;color:var(--txt3);width:26px;text-transform:uppercase">${k}</div>
            <div class="ev-bar" style="flex:1"><div class="ev-fill" style="width:${Math.round(previewEVs[k]/cap*100)}%;background:${evColor(k)}"></div></div>
            <div style="font-size:9px;color:var(--txt3);width:20px;text-align:right">~${previewEVs[k]}</div>
          </div>`).join('')}
        </div>
      </div>

      <div style="margin-top:12px;border-top:1px solid var(--border);padding-top:10px">
        <div style="font-size:10px;color:var(--txt3);margin-bottom:5px">TRAIT INHERITANCE CHANCES</div>
        <div style="display:flex;flex-wrap:wrap;gap:5px">
          ${allTraits.map(tk=>{
            const gt=GTRAITS[tk];if(!gt)return '';
            const shared=sharedTraits.includes(tk);
            const ch=shared?.75:.45;
            return `<div style="background:rgba(160,80,220,.15);border:1px solid rgba(160,80,220,.3);border-radius:3px;padding:4px 8px;font-size:10px">
              <span style="color:#d090ff">${gt.icon} ${gt.name}</span>
              <span style="color:var(--txt3);margin-left:6px">${Math.round(ch*100)}%${shared?' (shared)':''}</span>
            </div>`;
          }).join('')}
          <div style="background:rgba(40,180,80,.1);border:1px solid rgba(40,180,80,.3);border-radius:3px;padding:4px 8px;font-size:10px;color:var(--green)">ğŸ§¬ Mutation ${Math.round(mutationRate()*100)}%</div>
        </div>
      </div>
    </div>

    <div style="display:flex;gap:10px;align-items:center">
      <button class="btn btn-primary" onclick="doBreed()">âš— Begin Memory Binding</button>
      <button class="btn btn-sm btn-ghost" onclick="BREED_SELECTED=[];setLegacyTab('pool')">âœ• Clear Selection</button>
    </div>
  </div>`;
  return h;
}

function doBreed(){
  if(BREED_SELECTED.length<2){alert('Select 2 heroes first.');return;}
  const a=BREED_SELECTED[0], b=BREED_SELECTED[1];
  const ua=getBreedUses(META.family[a]), ub=getBreedUses(META.family[b]);
  if(ua.left<=0||ub.left<=0){alert('One of the selected strands has no memory binding uses left.');return;}
  const childRec=breedHeroes(a,b);
  if(!childRec)return;
  consumeBreedUse(a);
  consumeBreedUse(b);
  saveMeta();
  BREED_SELECTED=[];
  const lc=document.getElementById('legacy-content');
  const derived=evDerived(childRec.evs);
  lc.innerHTML=`<div class="slide-in" style="text-align:center;padding:30px">
    <div style="font-size:22px;margin-bottom:8px">ğŸ§¬</div>
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;color:var(--violet);margin-bottom:6px">${childRec.name}</div>
    <div style="color:var(--txt3);font-size:12px;margin-bottom:18px">Generation ${childRec.gen} Â· Born of legacy</div>
    <div style="display:inline-block;background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:14px 20px;margin-bottom:18px;text-align:left;min-width:240px">
      <div style="font-size:10px;color:var(--txt3);letter-spacing:2px;margin-bottom:8px">SCARS / PATTERN</div>
      ${[['MaxHP',derived.maxHP],['ATK',Math.round(derived.atk)],['DEF',Math.round(derived.def)],['SPD',derived.spd],['Crit',Math.round(derived.critChance*100)+'%']]
        .map(([l,v])=>`<div class="srow"><span class="sl" style="font-size:12px">${l}</span><span class="sv" style="font-size:12px;color:var(--green)">${v}</span></div>`).join('')}
      ${childRec.traits.length?`<div style="margin-top:10px;border-top:1px solid var(--border);padding-top:8px;display:flex;flex-wrap:wrap;gap:3px">${childRec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:`<div style="margin-top:8px;color:var(--txt3);font-size:10px">No pattern traits inherited.</div>`}
    </div>
    <div style="display:flex;gap:10px;justify-content:center">
      <button class="btn btn-primary" onclick="hideLegacy();startWithChild('${childRec.id}')">â–¶ Continue Saga with ${childRec.name}</button>
      <button class="btn btn-sm btn-ghost" onclick="setLegacyTab('pool')">â† Back</button>
    </div>
  </div>`;
}

function inheritGearFromParent(childId,parentId){
  const parentRec=META.family[parentId];
  const childRec=META.family[childId];
  if(!parentRec||!childRec||isFallenHero(parentId))return;
  if(!parentRec.equippedGear)return;
  childRec.inheritedGear={};
  Object.entries(parentRec.equippedGear).forEach(([slot,item])=>{
    if(!item)return;
    const copy=JSON.parse(JSON.stringify(item));
    copy.sagaHistory=copy.sagaHistory||[];
    if(copy.sagaHistory.length>=3)copy.sagaHistory.shift();
    copy.sagaHistory.push(`Inherited by ${childRec.name}`);
    childRec.inheritedGear[slot]=copy;
  });
  META.family[childId]=childRec;
}

function startWithChild(heroId){
  const rec=META.family[heroId];if(!rec)return;
  if(rec.parentIds&&rec.parentIds.length){
    const bestParentId=rec.parentIds.reduce((best,pid)=>{
      const p=META.family[pid], b=META.family[best];
      const pWave=(p?.runResult?.wave||0), bWave=(b?.runResult?.wave||0);
      const pFallen=isFallenHero(pid), bFallen=isFallenHero(best);
      if(bFallen&&!pFallen)return pid;
      if(!bFallen&&pFallen)return best;
      return pWave>=bWave?pid:best;
    },rec.parentIds[0]);
    inheritGearFromParent(heroId,bestParentId);
  }
  initGame(null,rec.evs,rec.traits,rec);
}

// â”€â”€â”€ FALLEN LEDGER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderFallenLedger(){
  const fallen=META.fallenLedger.map(id=>META.family[id]).filter(Boolean).reverse();
  const totalRecovered=fallen.reduce((sum,rec)=>sum+((rec.runResult?.salvageEarned)||0),0);
  let h=`<div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
      <div>
        <div style="font-size:16px;font-weight:700;color:var(--red)">áš± SCARRED RUNES</div>
        <div style="font-size:11px;color:var(--txt3);margin-top:2px">${fallen.length} fallen heroes Â· áš±${META.salvage} Rune-Shards available Â· Total recovered from closed sagas: áš±${totalRecovered}</div>
      </div>
    </div>`;
  if(!fallen.length){
    h+=`<div style="color:var(--txt3);font-size:12px;text-align:center;padding:30px">No fallen heroes yet. The lineage lives on.</div></div>`;
    return h;
  }
  h+=`<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px">`;
  fallen.forEach(rec=>{
    const rr=rec.runResult||{};
    const sal=rr.salvageEarned||0;
    h+=`<div class="hero-card hc-dead">
      <div class="hc-gen">GEN ${rec.gen} Â· SAGA CLOSED</div>
      <div class="hc-name">â˜  ${rec.name}</div>
      <div style="font-size:10px;color:var(--txt3);font-style:italic;margin:3px 0">
        "What remained was taken by the root."
      </div>
      ${rec.traits.length?`<div style="display:flex;flex-wrap:wrap;gap:2px;margin:4px 0">${rec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait" style="font-size:9px">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:''}
      <div class="hc-stats">Trial ${rr.wave||'?'} Â· ${(rr.boons?.length||0)} Rune-Gifts Â· Lv.${rr.level||1}</div>
      ${rr.axioms?.length?`<div style="font-size:10px;color:#d050ff;margin-top:3px">Runes: ${rr.axioms.length}</div>`:''}
      <div style="margin-top:8px;font-size:10px;color:var(--salvage)">+áš±${sal} Rune-Shards recovered</div>
    </div>`;
  });
  h+=`</div></div>`;
  return h;
}

const ELITE_NAME_PREFIXES={
  midgard:['Ulf','Bjorn','Sigr','Hrafn','Dag','Leif','Tor'],
  niflheim:['Grym','Skoll','Hati','Mist','Yng','Hvel'],
  jotunheim:['Thrym','Ymir','Berg','Sten','Fjord','Hymir'],
  muspelheim:['Brand','Eldr','Askr','Surla','Logi'],
  helheim:['NÃ¡l','Garm','Hod','VÃ¡nr'],
};
const ELITE_EPITHETS_BY_OUTCOME={
  barely:['the Unbroken','the Relentless','the Patient','the Stubborn'],
  crit:['the Exposed','the Unlucky','the Keen'],
  easy:['the Persistent','the Wary','the Watchful'],
  default:['the Remembered','the Scarred','the Returned','the Enduring'],
};
function generateEliteName(archId,lastOutcome){
  const arch=ARCHETYPES.find(a=>a.id===archId);
  const realm=arch?.realmTier||'midgard';
  const prefixPool=ELITE_NAME_PREFIXES[realm]||ELITE_NAME_PREFIXES.midgard;
  const prefix=rpick(prefixPool);
  const epithets=ELITE_EPITHETS_BY_OUTCOME[lastOutcome]||ELITE_EPITHETS_BY_OUTCOME.default;
  const epithet=rpick(epithets);
  return `${prefix} ${epithet}`;
}
function recordEliteEncounter(archId,playerSurvived,wasNearDeath,critLanded){
  normalizeMeta();
  if(!META.eliteRoster[archId]){
    META.eliteRoster[archId]={name:generateEliteName(archId,'default'),survivedByPlayer:false,encounterCount:0,lastOutcome:'default'};
  }
  const entry=META.eliteRoster[archId];
  entry.encounterCount++;
  if(playerSurvived){
    entry.survivedByPlayer=true;
    let outcome='easy';
    if(wasNearDeath)outcome='barely';
    else if(critLanded)outcome='crit';
    entry.lastOutcome=outcome;
    entry.name=generateEliteName(archId,outcome);
  }
  saveMeta();
}
function checkForNamedEliteReturn(archId,wave,force){
  const ragnarÃ¶kTier=META.ragnarÃ¶kActive||0;
  if(ragnarÃ¶kTier<9)return null;
  if(!G.tierFlags||!G.tierFlags.namedElitesActive)return null;
  const entry=META.eliteRoster[archId];
  if(!entry||!entry.survivedByPlayer)return null;
  if(force)return entry;
  const chance=0.15+(ragnarÃ¶kTier>=13?0.10:0);
  if(rng()>chance)return null;
  return entry;
}

// â”€â”€â”€ FAMILY TREE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderFamilyTree(){
  const lc=document.getElementById('legacy-content');
  const family=META.family||{};
  const all=Object.values(family);
  if(!all.length){
    lc.innerHTML=`<div style="text-align:center;padding:40px;color:var(--txt3)"><div style="font-size:32px;margin-bottom:12px">ğŸŒ³</div><div>No heroes in the lineage yet.</div></div>`;
    return;
  }

  const fallenSet=new Set(META.fallenLedger||[]);
  const retiredSet=new Set(META.retiredPool||[]);
  const childrenOf={};
  all.forEach(h=>{(h.parentIds||[]).forEach(pid=>{(childrenOf[pid]||(childrenOf[pid]=[])).push(h.id);});});

  const retiredRoots=all.filter(h=>{const out=h.runResult?.outcome; return retiredSet.has(h.id)||out==='retired'||out==='victory';}).map(h=>h.id);
  const scopeSet=new Set();
  if(TREE_VIEW.mode==='legacy'){
    const stack=[...retiredRoots];
    while(stack.length){
      const id=stack.pop();
      if(scopeSet.has(id))continue;
      scopeSet.add(id);
      (childrenOf[id]||[]).forEach(cid=>stack.push(cid));
    }
  }else{ all.forEach(h=>scopeSet.add(h.id)); }

  const inScope=all.filter(h=>scopeSet.has(h.id));
  const visible=(TREE_VIEW.showClosed?inScope:inScope.filter(h=>!fallenSet.has(h.id)));
  const hiddenClosedTotal=inScope.length-visible.length;

  const memoHidden={};
  function hiddenDesc(id){
    if(memoHidden[id]!=null)return memoHidden[id];
    let n=0;
    for(const cid of (childrenOf[id]||[])){
      if(!scopeSet.has(cid))continue;
      if(!TREE_VIEW.showClosed && fallenSet.has(cid)) n++;
      n+=hiddenDesc(cid);
    }
    memoHidden[id]=n;
    return n;
  }

  const byGen={};
  visible.forEach(h=>{const g=h.gen||0;(byGen[g]||(byGen[g]=[])).push(h);});
  Object.keys(byGen).forEach(g=>byGen[g].sort((a,b)=>String(a.id||a.name).localeCompare(String(b.id||b.name))));
  const maxGen=Math.max(0,...visible.map(h=>h.gen||0));
  const NODE_W=130,NODE_H=80,GAP_X=160,GAP_Y=100,PAD=20;
  const pos={};
  for(let g=0;g<=maxGen;g++)(byGen[g]||[]).forEach((h,i)=>{pos[h.id]={x:PAD+g*GAP_X,y:PAD+i*GAP_Y};});

  const maxCol=Math.max(1,...Object.values(byGen).map(a=>a.length));
  const canvasW=PAD*2+(maxGen)*GAP_X+NODE_W;
  const canvasH=PAD*2+maxCol*GAP_Y+NODE_H;
  let svgLines='';
  visible.forEach(h=>{(h.parentIds||[]).forEach(pid=>{const pp=pos[pid],cp=pos[h.id];if(pp&&cp){const x1=pp.x+NODE_W/2,y1=pp.y+NODE_H/2,x2=cp.x+NODE_W/2,y2=cp.y+NODE_H/2;svgLines+=`<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="rgba(144,80,232,.35)" stroke-width="1.5" stroke-dasharray="4,3"/>`;}});});

  let nodes='';
  visible.forEach(h=>{
    const p=pos[h.id];if(!p)return;
    const isInPool=retiredSet.has(h.id);
    const isRetiredLike=!!(h.runResult && (h.runResult.outcome==='retired' || h.runResult.outcome==='victory'));
    const isSpentRetired=(isRetiredLike && !isInPool);
    const isFallen=fallenSet.has(h.id);
    const cls=isInPool?'tn-retired':(isSpentRetired?'tn-spent':(isFallen?'tn-dead':''));
    const statusColor=isInPool?'var(--gold)':(isSpentRetired?'var(--txt2)':(isFallen?'var(--red)':'var(--txt3)'));
    const derived=evDerived(h.evs);
    const hidden=hiddenDesc(h.id);
    nodes+=`<div class="tree-node ${cls}" style="left:${p.x}px;top:${p.y}px;width:${NODE_W}px" onclick="showHeroDetail('${h.id}')">${hidden>0?`<span class="tree-badge">â˜ +${hidden}</span>`:''}
      <div style="font-size:9px;color:${statusColor};letter-spacing:1px">G${h.gen} ${isInPool ? 'â˜… Sealed' : (isSpentRetired ? 'â˜† Spent' : (isFallen ? 'â˜  Closed' : ''))}</div>
      <div style="font-size:11px;font-weight:700;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${h.name}</div>
      <div style="font-size:9px;color:var(--txt3);margin-top:2px">ATK:${Math.round(derived.atk)} DEF:${Math.round(derived.def)}</div>
      ${h.traits.length?`<div style="margin-top:3px">${h.traits.slice(0,2).map(tk=>{const gt=GTRAITS[tk];return gt?`<span style="font-size:10px">${gt.icon}</span>`:''}).join('')}</div>`:''}
    </div>`;
  });

  lc.innerHTML=`<div>
    <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:10px;flex-wrap:wrap;margin-bottom:14px">
      <div>
        <div style="font-size:16px;font-weight:700;color:var(--gold)">ğŸŒ³ Family Tree</div>
        <div style="font-size:11px;color:var(--txt3);margin-top:2px">Showing ${visible.length} heroes (${hiddenClosedTotal} Closed hidden) across ${maxGen+1} generations</div>
        ${TREE_VIEW.mode==='legacy'?`<div style="font-size:10px;color:var(--txt3);margin-top:2px">Legacy View: retired lines + descendants</div>`:''}
      </div>
      <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
        <div style="display:flex;border:1px solid var(--border2);border-radius:999px;overflow:hidden">
          <button class="btn btn-sm ${TREE_VIEW.mode==='legacy'?'btn-gold':'btn-ghost'}" onclick="setTreeMode('legacy')" style="border:none;border-radius:0">Legacy</button>
          <button class="btn btn-sm ${TREE_VIEW.mode==='all'?'btn-gold':'btn-ghost'}" onclick="setTreeMode('all')" style="border:none;border-radius:0">All</button>
        </div>
        <button class="btn btn-sm ${TREE_VIEW.showClosed?'btn-danger':'btn-ghost'}" onclick="toggleTreeClosed()">${TREE_VIEW.showClosed?'Hide Closed':'Show Closed'}</button>
      </div>
      <div style="font-size:10px;color:var(--txt3)"><span style="color:var(--gold)">â˜…</span> Sealed &nbsp; <span style="color:var(--txt2)">â˜†</span> Spent &nbsp; <span style="color:var(--red)">â˜ </span> Closed &nbsp; Click node for details</div>
    </div>
    <div style="position:relative;overflow:auto;background:var(--bg2);border:1px solid var(--border);border-radius:6px;min-height:200px">
      <svg style="position:absolute;top:0;left:0;width:${canvasW}px;height:${canvasH}px;pointer-events:none">${svgLines}</svg>
      <div style="position:relative;width:${canvasW}px;height:${canvasH}px">${nodes}</div>
    </div>
    <div id="hero-detail-panel" style="margin-top:14px"></div>
  </div>`;
}

function generateSagaPage(rec) {
  if (!rec || !rec.runResult) {
    return `${rec?.name || 'Unknown'} â€” Saga unwritten.`;
  }
  const rr      = rec.runResult;
  const outcome = rr.outcome;
  const wave    = rr.wave    || '?';
  const level   = rr.level   || 1;
  const boonCount  = rr.boons?.length  || 0;
  const axiomCount = rr.axioms?.length || 0;

  const tagCounts = {};
  (rr.boons || []).forEach(boonId => {
    const boon = BOONS.find(b => b.id === boonId);
    if (boon) boon.tags.forEach(t => { tagCounts[t] = (tagCounts[t] || 0) + 1; });
  });
  const topTag = Object.entries(tagCounts).sort((a, b) => b[1] - a[1])[0]?.[0] || null;

  const topTrait = rec.traits?.[0] ? GTRAITS[rec.traits[0]]?.name : null;

  const gearItems = rec.equippedGear ? Object.values(rec.equippedGear).filter(Boolean) : [];
  const gearNote  = gearItems.length
    ? `Left behind ${gearItems.map(i => i.name).join(' and ')}.`
    : '';

  let harvestNote = '';
  if (rr.harvest) {
    if (rr.harvest.startsWith('scar:')) {
      const sk = rr.harvest.split(':')[1];
      harvestNote = `Scar of ${GTRAITS[sk]?.name || 'the fallen'} endures.`;
    } else if (rr.harvest.startsWith('relic:')) {
      harvestNote = 'Mastery preserved as Relic.';
    }
  }

  const tierNote = rec.ragnarÃ¶kStamp ? `Root Depth ${rec.ragnarÃ¶kStamp} witnessed.` : '';
  const relicNote = rec.relicType ? `Mastery sealed as ${rec.relicType.replace('relic_','').replace(/_/g,' ')}.` : '';

  const outcomePhrase = {
    'retired': `Chose to seal the saga at Trial ${wave}.`,
    'victory': `Survived all twelve trials.`,
    'fallen':  `Fell at Trial ${wave}.`,
  }[outcome] || `Saga ended at Trial ${wave}.`;

  const parts = [
    outcomePhrase,
    topTag    ? `Carried the ${topTag} path.`           : null,
    axiomCount > 0 ? `${axiomCount} Rune Law${axiomCount > 1 ? 's' : ''} learned.` : null,
    topTrait  ? `Blood of ${topTrait}.`                 : null,
    gearNote  || null,
    relicNote || harvestNote || null,
    tierNote  || null,
  ].filter(Boolean);

  return parts.join(' ');
}

function showHeroDetail(id){
  const rec=META.family[id];if(!rec)return;
  const derived=evDerived(rec.evs);
  const rr=rec.runResult||{};
  const sagaPage=generateSagaPage(rec);
  const isRetired=META.retiredPool.includes(id);
  const isFallen=META.fallenLedger.includes(id);
  const isRetiredLike=!!(rec.runResult && (rec.runResult.outcome==='retired' || rec.runResult.outcome==='victory'));
  const status=isRetired?'Sealed â˜…':isFallen?'Closed â˜ ':isRetiredLike?'Spent â˜†':'Active';
  const statusColor=isRetired?'var(--gold)':isFallen?'var(--red)':'var(--cyan)';
  const gearItems=rec.equippedGear?Object.entries(rec.equippedGear).filter(([s,item])=>item):[];
  document.getElementById('hero-detail-panel').innerHTML=`<div class="slide-in" style="background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:16px">
    <div style="display:flex;justify-content:space-between;align-items:flex-start">
      <div>
        <div style="font-size:10px;color:var(--txt3)">Generation ${rec.gen} Â· <span style="color:${statusColor}">${status}</span></div>
        <div style="font-size:18px;font-weight:700;margin-top:2px">${rec.name}</div>
      </div>
      <button onclick="document.getElementById('hero-detail-panel').innerHTML=''" style="background:none;border:none;color:var(--txt3);cursor:pointer;font-size:16px">âœ•</button>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-top:12px">
      <div>
        <div style="font-size:10px;color:var(--txt3);margin-bottom:5px">DERIVED STATS</div>
        ${[['HP',derived.maxHP],['ATK',Math.round(derived.atk)],['DEF',Math.round(derived.def)],['SPD',derived.spd],['CRIT',Math.round(derived.critChance*100)+'%'],['EVA',Math.round(derived.evasion*100)+'%']]
          .map(([l,v])=>`<div class="srow"><span class="sl" style="font-size:11px">${l}</span><span class="sv" style="font-size:11px">${v}</span></div>`).join('')}
      </div>
      <div>
        <div style="font-size:10px;color:var(--txt3);margin-bottom:5px">EV PROFILE</div>
        ${EV_KEYS.map(k=>`<div style="display:flex;align-items:center;gap:4px;margin:2px 0">
          <div style="font-size:9px;color:var(--txt3);width:26px;text-transform:uppercase">${k}</div>
          <div class="ev-bar" style="flex:1"><div class="ev-fill" style="width:${Math.round((rec.evs[k]||0)/evCap()*100)}%;background:${evColor(k)}"></div></div>
          <div style="font-size:9px;color:var(--txt3);width:20px;text-align:right">${rec.evs[k]||0}</div>
        </div>`).join('')}
      </div>
      <div>
        <div style="font-size:10px;color:var(--txt3);margin-bottom:5px">TRAITS</div>
        ${rec.traits.length?rec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<div class="gtrait" style="display:flex;margin:3px 0">${gt.icon} ${gt.name}</div>`:''}).join(''):`<div style="color:var(--txt3);font-size:11px">None</div>`}
        ${rr.wave?`<div style="margin-top:8px;border-top:1px solid var(--border);padding-top:6px">
          <div style="font-size:10px;color:var(--txt3)">Saga: Trial ${rr.wave} Â· ${(rr.boons?.length||0)} Rune-Gifts Â· Lv.${rr.level||1}</div>
          ${rr.axioms?.length?`<div style="font-size:10px;color:#d050ff;margin-top:2px">Runes: ${rr.axioms.length}</div>`:''}
        </div>`:''}
      </div>
    </div>
    <div style="margin-top:10px;font-size:10px;color:var(--txt3)">Primary Strand & Secondary Strand: ${rec.parentIds?.length?rec.parentIds.map(pid=>META.family[pid]?.name||'Unknown').join(' Ã— '):'Founder thread'}</div>
    <div style="margin-top:12px;border-top:1px solid var(--border);padding-top:10px">
      <div style="font-size:9px;color:var(--txt3);letter-spacing:2px;margin-bottom:4px">SAGA PAGE</div>
      <div style="font-size:11px;color:var(--txt2);font-style:italic;line-height:1.6">
        "${sagaPage}"
      </div>
    </div>
    ${gearItems.length?`
      <div style="margin-top:10px;border-top:1px solid var(--border);padding-top:8px">
        <div style="font-size:9px;color:var(--txt3);letter-spacing:2px;margin-bottom:5px">BEQUEATHED GEAR</div>
        ${gearItems.map(([slot,item])=>`
          <div style="font-size:10px;color:${rarityColor(item.rarity)};margin:3px 0">
            âš’ ${item.name}
            ${item.sagaHistory?.length?`<span style="color:var(--txt3);font-style:italic"> â€” "${item.sagaHistory[item.sagaHistory.length-1]}"</span>`:''}
            ${item.passiveBonus?`<span style="color:var(--green)"> Â· ${item.passiveBonus.label}</span>`:''}
          </div>
        `).join('')}
      </div>
    `:''}
  </div>`;
}

const CODEX_ENTRIES=[
  {id:'weaver',term:'The Weaver of May Be',subtitle:'The Unnamed Fourth Norn',body:'UrÃ°r keeps what was. VerÃ°andi keeps what is. Skuld keeps what shall be. I am the unsanctioned fourth: dvergar master-smith, rune-carver, and weaver of possibility. I do not foretell. I trace what may be, then temper it into Minni.',unlockedBy:'always'},
  {id:'minni',term:'Minni',subtitle:'Memory as architecture',body:'Minni is not sentiment. It is load-bearing memory: pattern, scar, and tested structure carried forward between generations. Every run records stress and response. What survives becomes material for the next attempt.',unlockedBy:'always'},
  {id:'yggdrasil',term:'Yggdrasil',subtitle:'The World Tree',body:'The great ash that binds the realms is rotting at the root. Each generation runs twelve Trials through that pressure. RagnarÃ¶k Tiers measure the wider decay of the world around those Trials.',unlockedBy:'always'},
  {id:'allfather',term:'Allfather',subtitle:'Odin, watcher at the edge of this craft',body:'Odin bartered eye and body for runes, and he watches this work with interest. But he is not the loom. He offers hints, gifts, and wagers; I keep the tools and make the cuts.',unlockedBy:'always'},
  {id:'valhalla',term:'Valhalla',subtitle:'A hall among many claims on the dead',body:'Valhalla trains its chosen for the final battle. Whether any fallen thread reaches that hall, or is consumed below, remains disputed. I log outcomes; I trust patterns over promises.',unlockedBy:'always'},
  {id:'saga',term:'Saga',subtitle:"A single generation's thread",body:"A saga here is one generation of twelve Trials. It begins hot, takes strain, then either fails, retires into Minni-HÃ¶ll, or reaches the deepest carve point.",unlockedBy:'always'},
  {id:'rune',term:'Rune',subtitle:'Letter, tool, and pressure pattern',body:'A rune is language and mechanism at once. In these Trials, rune-gifts are functional edits to combat structure. Every chosen line reveals another branch of what may be.',unlockedBy:'always'},
  {id:'norns',term:'The Norns',subtitle:'UrÃ°r, VerÃ°andi, Skuld',body:'The three sisters keep a strict tapestry: past fixed, present measured, future constrained. Skuld appears here as Debt, the hard edge of what shall be. My work is not to replace them, but to carve a lawful branch beside their weave.',unlockedBy:'always'},
  {id:'minniholl',term:'Minni-HÃ¶ll',subtitle:'Hall of Memory',body:'When a thread retires, it is cut from the current run and set as a Memory Stone in Minni-HÃ¶ll. From there, strands can be bound, tempered, and reused in future generations.',unlockedBy:'firstRetire'},
  {id:'skuldsDebt',term:"Skuld's Debt",subtitle:'Future as constraint',body:'Ash choices carry debt. You gain immediate force, but Skuld marks the line and demands repayment in later battles. Debt is not punishment; it is structural pressure.',unlockedBy:'ashDebt'},
  {id:'wyrd',term:'Wyrd',subtitle:'Binding threads without certainty',body:'Wyrd is woven causality, not blood purity. Memory Binding joins a Primary Strand and Secondary Strand, tempering scars and pattern into a new thread. No outcome is guaranteed; only tested possibilities persist.',unlockedBy:'firstBreed'},
  {id:'dvergar',term:'Dvergar',subtitle:'Smiths of impossible tools',body:'The dvergar forged chains for wolves and spears for gods. I inherit that craft: heat, measure, quench, and inscription. Rune-work is metallurgy applied to fate.',unlockedBy:'firstRetire'},
  {id:'fimbulwinter',term:'Fimbulwinter',subtitle:'The long freeze before collapse',body:'When decay deepens, warmth fails and tempo slows. Tier 1 marks this stage clearly: endurance and timing become harder materials than damage.',unlockedBy:'tier11'},
  {id:'eitr',term:'Eitr',subtitle:'World-venom in the grain',body:'Eitr is poison and catalyst. From Tier 5 it enters the air, and by Tier 13 it saturates everything: enemies, gifts, and risk calculations. Corruption and leverage become the same substance.',unlockedBy:'tier13'},
  {id:'nidhoggr',term:'NÃ­Ã°hÃ¶ggr',subtitle:'Gnawer at the deepest root',body:"NÃ­Ã°hÃ¶ggr is no rumor. The pressure under every Trial is its bite. By Tier 13, the creature's pressure is an active condition you must hold and survive.",unlockedBy:'tier15'},
  {id:'runeMayBe',term:'Rune of What May Be',subtitle:'Why Tier 15 matters',body:'RagnarÃ¶k Tier 15 is the deepest reachable root: maximum world-decay, minimum false branches. Hold NÃ­Ã°hÃ¶ggr there and carve the Rune of What May Be into the source code of the world. This is the point of all prior generations.',unlockedBy:'tier15'},
  {id:'ragnarÃ¶k',term:'RagnarÃ¶k Tiers',subtitle:'Global decay over repeated generations',body:'Trials are per generation. RagnarÃ¶k Tiers are cumulative world deterioration across generations. You are not just surviving twelve fights; you are descending a failing system toward a final carve point.',unlockedBy:'tier1'},
  {id:'rtier1',term:'RagnarÃ¶k Tier 1 â€” Fimbulwinter Begins',subtitle:'Phase I: The Harbingers',body:'Cold arrives before its season. The descent slows and enemies endure longer. Mechanical expression: hero SPD -5; enemy HP +10%.',unlockedBy:'tier1'},
  {id:'rtier2',term:'RagnarÃ¶k Tier 2 â€” Fimbulwinter Deepens',subtitle:'Oaths Break in Frost',body:'Order frays and aggression bleeds into early trials. Mechanical expression: Enraged/Frenzied can appear in Block 1.',unlockedBy:'tier2'},
  {id:'rtier3',term:'RagnarÃ¶k Tier 3 â€” Third Winter / Fenrirâ€™s Chain Weakens',subtitle:'Constraint Fails',body:'The old bindings loosen. Archetypes begin showing deeper behaviors. Mechanical expression: tier-2 archetype behavior flags activate.',unlockedBy:'tier3'},
  {id:'rtier4',term:'RagnarÃ¶k Tier 4 â€” Fenrir Breaks Free',subtitle:'The Wolf Runs',body:'The dead refuse stillness and elite foes awaken when cornered. Mechanical expression: Draugr echo chance and elite second phase enabled.',unlockedBy:'tier4'},
  {id:'rtier5',term:'RagnarÃ¶k Tier 5 â€” JÃ¶rmungandr Rises',subtitle:'Venom on the Wind',body:'Poison becomes atmosphere and bosses gain sharper signatures. Mechanical expression: toxic air starts at Trial 5; DoT bonus +10%; boss signatures on.',unlockedBy:'tier5'},
  {id:'rtier6',term:'RagnarÃ¶k Tier 6 â€” Naglfar Sets Sail',subtitle:'More Ships, More Dead',body:'Waves crowd the shoreline. Mechanical expression: +1 slot/body cap baseline; Horde-Call can roll.',unlockedBy:'tier6'},
  {id:'rtier7',term:'RagnarÃ¶k Tier 7 â€” Loki Breaks Free',subtitle:'Bargains with Hooks',body:'Deals become dangerous and chance costs more. Mechanical expression: cursed bargains enabled; reroll growth override +4.',unlockedBy:'tier7'},
  {id:'rtier8',term:'RagnarÃ¶k Tier 8 â€” Surtr Marches / BifrÃ¶st Shatters',subtitle:'Fire at Run Start',body:'The world enters burning-state immediately. Mechanical expression: Muspelheim tags and ember sparks from Trial 1; starting gold reduced.',unlockedBy:'tier8'},
  {id:'rtier9',term:'RagnarÃ¶k Tier 9 â€” Gods Summon the Einherjar',subtitle:'Gjallarhorn',body:'The remembered dead answer the call. Mechanical expression: named elite returns activate; kills can drop marks.',unlockedBy:'tier9'},
  {id:'rtier10',term:'RagnarÃ¶k Tier 10 â€” VÃ­grÃ­Ã°r: Plain of Battle',subtitle:'Open War',body:'Elites appear outside their old lanes and pace accelerates. Mechanical expression: elites-on-any-wave chance; hero +SPD with lighter enemy SPD ramp.',unlockedBy:'tier10'},
  {id:'rtier11',term:'RagnarÃ¶k Tier 11 â€” The Gods Fall',subtitle:'No Guardians Left',body:'Survival becomes self-forged. Mechanical expression: further hero SPD penalty, all-wave chill tag, sustain/regen boon bonus.',unlockedBy:'tier11'},
  {id:'rtier12',term:'RagnarÃ¶k Tier 12 â€” Surtr Burns the Nine Realms',subtitle:'Ash and Venom',body:'Corruption surges and scarcity deepens. Mechanical expression: higher root-touched chance, toxic air damage 2, stronger DoT, more gold loss.',unlockedBy:'tier12'},
  {id:'rtier13',term:'RagnarÃ¶k Tier 13 â€” NÃ­Ã°hÃ¶ggr Ascends',subtitle:'Full Saturation',body:'The Gnawer rises into open air. Mechanical expression: toxic air from Trial 1, max DoT bonus, stronger root-touched stats, guaranteed elite returns on Trials 10â€“11.',unlockedBy:'tier13'},
  {id:'rtier14',term:'RagnarÃ¶k Tier 14 â€” The Binding',subtitle:'Hold the Pattern',body:'You do not win cleanly; you hold shape against collapse. Mechanical expression: speed acceleration persists, scarcity tightens.',unlockedBy:'tier14'},
  {id:'rtier15',term:'RagnarÃ¶k Tier 15 â€” The Rune of What May Be',subtitle:'Fourth Norn Carving',body:'At the deepest root, Minni becomes architecture. Mechanical expression: highest wave scaling and final watcher-gift trigger.',unlockedBy:'tier15'},
 ];

function unlockCodexEntry(id){
  normalizeMeta();
  if(!META.codexUnlocked.includes(id)){META.codexUnlocked.push(id);saveMeta();}
}
function checkCodexUnlocks(){
  const tier=META.ragnarÃ¶kTier||0;
  if(tier>=1)unlockCodexEntry('ragnarÃ¶k');
  if(tier>=1)unlockCodexEntry('fimbulwinter');
  if(tier>=5)unlockCodexEntry('eitr');
  if(tier>=13)unlockCodexEntry('nidhoggr');
  if(tier>=15)unlockCodexEntry('runeMayBe');
  for(let n=1;n<=Math.min(15,tier);n++)unlockCodexEntry('rtier'+n);
  if(META.retiredPool&&META.retiredPool.length>0){unlockCodexEntry('minniholl');unlockCodexEntry('einherjar');unlockCodexEntry('vÃ¶lva');unlockCodexEntry('dvergar');}
  if(META.family&&Object.keys(META.family).some(id=>{const r=META.family[id];return r&&r.parentIds&&r.parentIds.length>0;}))unlockCodexEntry('wyrd');
}

function brEsc(s){return String(s??'').replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}
function brChip(t){return `<span class="br-chip">${brEsc(t)}</span>`;}
function brRarityBadge(r){return `<span class="br-rar rar-${brEsc(r)}">${brEsc(r)}</span>`;}
function brTable({id,columns,rows,rowClass,rowSearchText}){
  const head=`<thead><tr>${columns.map(c=>`<th>${brEsc(c.label)}</th>`).join('')}</tr></thead>`;
  const body=(rows||[]).map((row,i)=>{
    const cls=rowClass?rowClass(row,i):'';
    const search=rowSearchText?rowSearchText(row,i):Object.values(row||{}).join(' ');
    return `<tr data-br-row data-br="${brEsc(id||'tbl')}" data-br-search="${brEsc(search)}" class="${cls||''}">${columns.map(c=>`<td>${c.render?c.render(row,i):brEsc(row[c.key])}</td>`).join('')}</tr>`;
  }).join('');
  return `<table class="br-table">${head}<tbody>${body||`<tr><td colspan="${columns.length}">No entries.</td></tr>`}</tbody></table>`;
}
function brSection({id,title,noteHTML,bodyHTML,open=true}){
  return `<details class="br-section" id="${brEsc(id)}" ${open?'open':''}><summary><span class="br-h">${brEsc(title)}</span></summary>${noteHTML?`<div class="br-note">${noteHTML}</div>`:''}<div class="br-body">${bodyHTML||''}</div></details>`;
}
function brApplySearch(q){
  q=(q||'').trim().toLowerCase();
  document.querySelectorAll('[data-br-row]').forEach(tr=>{
    const hay=(tr.getAttribute('data-br-search')||'').toLowerCase();
    tr.style.display=(!q||hay.includes(q))?'':'none';
  });
}
function brSetAll(open){document.querySelectorAll('.br-section').forEach(d=>d.open=!!open);}
function brStringify(v){if(v==null)return '';if(typeof v==='string')return v; if(typeof v==='number'||typeof v==='boolean')return String(v); if(Array.isArray(v))return v.map(brStringify).join(', '); try{return JSON.stringify(v);}catch(e){return String(v);}}
function brFlagClass(group,id){const f=BR_FLAGS[group]?.[id]; if(!f) return ''; return f.isNew?'br-new-row':(f.changed?'br-changed-row':'');}
function brFlagNote(group,id){const f=BR_FLAGS[group]?.[id]; return f&&f.note?` <em style="color:var(--txt3)">${brEsc(f.note)}</em>`:'';}
function brFmtNum(n){return (typeof n==='number'&&Number.isFinite(n))?String(Math.round(n*100)/100):'â€”';}
function brExplainRagnarokTier(t){
  const tmp={tierFlags:{},hero:{},waveFlags:{}};
  try{ if(t&&typeof t.apply==='function')t.apply(tmp); }catch(e){ return 'Effect: (see apply())'; }
  const out=Object.entries(tmp.tierFlags||{}).map(([k,v])=>`${k}=${typeof v==='number'?brFmtNum(v):String(v)}`);
  return out.length?out.join('; '):'No direct tierFlags diff';
}

const BR_FLAGS={
  boons:{
    vanguard:{changed:true,note:'Now triggers only on HP damage and grants less Shield.'},
    eternal_hunger:{changed:true,note:'Lifesteal reduced and overheal conversion capped per battle.'},
    ax_harvest:{changed:true,note:'Kill heal reduced.'},
    ax_fortress:{changed:true,note:'Higher shield threshold and internal cooldown.'},
  }
};

function codexLoreHTML(){
  const unlocked=new Set(META.codexUnlocked||[]);
  const visible=CODEX_ENTRIES.filter(e=>unlocked.has(e.id));
  const locked=CODEX_ENTRIES.filter(e=>!unlocked.has(e.id));
  let h=`<div style="padding:10px 0"><div style="font-size:10px;color:var(--txt3);margin-bottom:12px;font-style:italic">Terms revealed as your Minni lattice discovers them. ${locked.length>0?`${locked.length} entry${locked.length>1?'s':''} yet to be found.`:'All entries revealed.'}</div><div style="display:flex;flex-direction:column;gap:10px">`;
  visible.forEach(entry=>{ h+=`<div style="background:var(--bg2);border:1px solid var(--border2);border-radius:5px;padding:12px"><div style="display:flex;justify-content:space-between;align-items:baseline;margin-bottom:2px"><div style="font-family:'Orbitron',sans-serif;font-size:13px;font-weight:900;color:var(--violet)">${entry.term}</div><div style="font-size:9px;color:var(--txt3);font-style:italic">${entry.subtitle}</div></div><div style="font-size:11px;color:var(--txt2);line-height:1.7;margin-top:6px">${entry.body}</div></div>`; });
  if(locked.length>0){ h+=`<div style="border:1px dashed var(--border);border-radius:5px;padding:12px;text-align:center"><div style="font-size:11px;color:var(--txt3);font-style:italic">${locked.length} entry${locked.length>1?'s':''} locked. Continue the saga to discover them.</div><div style="margin-top:6px;display:flex;flex-wrap:wrap;gap:6px;justify-content:center">${locked.map(e=>`<div style="font-size:10px;color:var(--border2);background:var(--bg2);border:1px solid var(--border);border-radius:3px;padding:3px 8px">???</div>`).join('')}</div></div>`; }
  h+=`</div></div>`;
  return h;
}

function codexBalanceHTML(){
  const boonsByR=['common','uncommon','rare','epic','legendary','axiom'].map(r=>{
    const rs=BOONS.filter(b=>b.rarity===r);
    const table=brTable({id:`boons-${r}`,rows:rs,rowClass:r=>brFlagClass('boons',r.id),rowSearchText:r=>`${r.id} ${r.name} ${r.rarity} ${(r.tags||[]).join(' ')} ${r.desc}`,
      columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>`${brRarityBadge(r.rarity)} ${brEsc((r.icon||'')+' '+r.name)}`},{label:'Tags',render:r=>(r.tags||[]).map(brChip).join(' ')},{label:'Description / Effect',render:r=>`${brEsc(r.desc||'')}${brFlagNote('boons',r.id)}`}]});
    return `<div style="margin:0 0 8px"><div style="font-size:11px;color:var(--txt3);margin:0 0 4px">${r.toUpperCase()} (${rs.length})</div>${table}</div>`;
  }).join('');

  const gearRows=Object.entries(GEAR_TEMPLATES||{}).map(([id,g])=>({id,slot:g.slot,baseName:g.baseName,rarity:g.rarity,affixesText:(g.affixes||[]).map(a=>a.label||`${a.stat}:${a.value}`).join('; '),costBase:gearCost({rarity:g.rarity,notches:0}),loreNote:g.loreNote||'',flavor:g.flavor||''}));
  const archRows=(ARCHETYPES||[]).map(a=>({
    id:a.id,name:`${a.displayName||a.name||a.id}${a.norseName?` / ${a.norseName}`:''}`,realm:a.realm||'â€”',
    base:`HP ${a.base?.hp??'â€”'} ATK ${a.base?.atk??'â€”'} DEF ${a.base?.def??'â€”'} SPD ${a.base?.spd??'â€”'} Crit ${a.base?.cc??'â€”'} / ${a.base?.cd??'â€”'}`,
    scaling:`HP ${a.scale?.hp??'â€”'} ATK ${a.scale?.atk??'â€”'} DEF ${a.scale?.def??'â€”'} SPD ${a.scale?.spd??'â€”'}`,
    trait:`${a.trait||'â€”'}${a.td?` â€” ${a.td}`:''}`,
    behavior:a.behavior||'â€”'
  }));
  const trialRows=Object.entries(TRIAL_CONFIG||{}).map(([k,v])=>({trial:k,...v,notes:Object.entries(v||{}).filter(([kk])=>!['slotsMin','slotsMax','bodyCap','minorTraitsMin','minorTraitsMax','majorTraitsMax','allowEliteTrait'].includes(kk)).map(([kk,vv])=>`${kk}:${brStringify(vv)}`).join('; ')}));
  const sigRows=Object.entries(BOSS_SIGNATURES||{}).map(([k,v])=>({key:k,name:v.name,desc:v.desc}));
  const traitRows=Object.entries(GTRAITS||{}).filter(([k])=>!(k in (SCARS||{}))).map(([id,v])=>({id,name:v.name,desc:v.desc}));
  const scarRows=Object.entries(SCARS||{}).map(([id,v])=>({id,name:v.name,desc:v.desc}));
  const aspectRows=(ASPECTS||[]).map(a=>({aspect:a,icon:ASPECT_ICON[a]||'âœ¦',thresholds:(ASPECT_THRESH||[]).join(' / ')}));
  const mapRows=Object.entries(TAG_ASPECT||{}).map(([tag,aspect])=>({tag,aspect}));
  const ragRows=(RAGNARÃ–K_TIERS||[]).map(t=>({tier:t.tier,name:t.name,omen:t.omen,effect:brExplainRagnarokTier(t)}));

  const toc=[['br-combat','Combat'],['br-ev','Base/EV'],['br-boons','Boons'],['br-gear','Gear'],['br-arch','Archetypes'],['br-wave','Wave Traits'],['br-trial','Trial Config'],['br-boss','Boss Signatures'],['br-bargain','Cursed Bargains'],['br-traits','Traits'],['br-scars','Scars'],['br-tactics','Tactics'],['br-relics','Resolve Relics'],['br-debts','Debts'],['br-runesmith','Runesmith'],['br-aspects','Aspects'],['br-rag','RagnarÃ¶k'],['br-status','Status']];

  return `<div class="br-panel"><div class="br-toolbar"><input class="br-search" placeholder="Search balance tables..." oninput="brApplySearch(this.value)"><button class="btn btn-sm btn-ghost" onclick="brSetAll(true)">Expand All</button><button class="btn btn-sm btn-ghost" onclick="brSetAll(false)">Collapse All</button></div><div class="br-toc">${toc.map(([id,n])=>`<a href="#${id}">${n}</a>`).join('')}</div>
  ${brSection({id:'br-combat',title:'Combat System Overview',noteHTML:'RuneSaga combat mixes deterministic stats with proc hooks (boons, traits, statuses, gear and tier flags). This panel is generated from active data objects so tuning changes immediately appear here.',bodyHTML:''})}
  ${brSection({id:'br-ev',title:'Base Stats & EV System',noteHTML:`Current EV cap: <strong>${evCap()}</strong>. EV gains scale by trial progress, hero level, generation and active RagnarÃ¶k tier.`,bodyHTML:''})}
  ${brSection({id:'br-boons',title:'Boons',bodyHTML:boonsByR})}
  ${brSection({id:'br-gear',title:'Gear Templates',bodyHTML:brTable({id:'gear',rows:gearRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Slot',render:r=>brEsc(r.slot)},{label:'Base Name',render:r=>`${brRarityBadge(r.rarity)} ${brEsc(r.baseName)}`},{label:'Affixes',render:r=>brEsc(r.affixesText)},{label:'Base Cost',render:r=>`á›‹${brEsc(r.costBase)}`},{label:'Lore/Flavor',render:r=>brEsc([r.loreNote,r.flavor].filter(Boolean).join(' Â· '))}]})})}
  ${brSection({id:'br-arch',title:'Enemy Archetypes',bodyHTML:brTable({id:'arch',rows:archRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(r.name)},{label:'Realm',render:r=>brEsc(r.realm)},{label:'Base Stats',render:r=>brEsc(r.base)},{label:'Scaling',render:r=>brEsc(r.scaling)},{label:'Trait',render:r=>brEsc(r.trait)},{label:'Behavior',render:r=>brEsc(r.behavior)}]})})}
  ${brSection({id:'br-wave',title:'Wave Traits',bodyHTML:brTable({id:'wtraits',rows:WAVE_TRAITS||[],rowSearchText:r=>`${r.id} ${r.name} ${r.desc}`,columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(r.name)},{label:'Description',render:r=>brEsc(r.desc)}]})})}
  ${brSection({id:'br-trial',title:'Trial Configuration',bodyHTML:brTable({id:'trialcfg',rows:trialRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'Trial #',render:r=>brEsc(r.trial)},{label:'slotsMin-max',render:r=>`${brEsc(r.slotsMin)}-${brEsc(r.slotsMax)}`},{label:'bodyCap',render:r=>brEsc(r.bodyCap)},{label:'minorTraitsMin-max',render:r=>`${brEsc(r.minorTraitsMin)}-${brEsc(r.minorTraitsMax)}`},{label:'majorTraitsMax',render:r=>brEsc(r.majorTraitsMax)},{label:'allowEliteTrait',render:r=>brEsc(r.allowEliteTrait)},{label:'notes',render:r=>brEsc(r.notes||'â€”')}]})})}
  ${brSection({id:'br-boss',title:'Boss Signatures',bodyHTML:brTable({id:'bosssig',rows:sigRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'Key',render:r=>`<code>${brEsc(r.key)}</code>`},{label:'Name',render:r=>brEsc(r.name)},{label:'Description',render:r=>brEsc(r.desc)}]})})}
  ${brSection({id:'br-bargain',title:'Cursed Bargains',bodyHTML:brTable({id:'cb',rows:CURSED_BARGAINS||[],rowSearchText:r=>`${r.id} ${r.name} ${r.desc}`,columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(`${r.icon||''} ${r.name}`)},{label:'Cost',render:r=>`á›‹${brEsc(r.cost)}${r.isFree?' (free)':''}`},{label:'Description',render:r=>brEsc(r.desc)},{label:'Notes',render:r=>brEsc(r.isFree?'isFree=true':'â€”')}]})})}
  ${brSection({id:'br-traits',title:'Genetic Traits',bodyHTML:brTable({id:'traits',rows:traitRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(r.name)},{label:'Description',render:r=>brEsc(r.desc)}]})})}
  ${brSection({id:'br-scars',title:'Scars',bodyHTML:brTable({id:'scars',rows:scarRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(r.name)},{label:'Description',render:r=>brEsc(r.desc)}]})})}
  ${brSection({id:'br-tactics',title:'Tactics',bodyHTML:brTable({id:'tactics',rows:TACTICS||[],rowSearchText:r=>`${r.id} ${r.name} ${r.desc} ${r.kind}`,columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(`${r.icon||''} ${r.name}`)},{label:'Cost',render:r=>`á›‹${brEsc(r.cost)}`},{label:'Kind',render:r=>brEsc(r.kind)},{label:'Description',render:r=>brEsc(r.desc)}]})})}
  ${brSection({id:'br-relics',title:'Resolve Relics',bodyHTML:brTable({id:'relics',rows:RESOLVE_RELICS||[],rowSearchText:r=>`${r.id} ${r.name} ${r.desc} ${brStringify(r.mults)}`,columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(`${r.icon||''} ${r.name}`)},{label:'Description',render:r=>brEsc(r.desc)},{label:'Multipliers',render:r=>brEsc(Object.entries(r.mults||{}).map(([k,v])=>`${k}:${v}`).join('; '))}]})})}
  ${brSection({id:'br-debts',title:'Debts',bodyHTML:brTable({id:'debts',rows:DEBTS||[],rowSearchText:r=>`${r.id} ${r.name} ${r.desc} ${brStringify(r.battleStart)}`,columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(`${r.icon||''} ${r.name}`)},{label:'Description',render:r=>brEsc(r.desc)},{label:'Battle Start',render:r=>brEsc((r.battleStart||[]).map(b=>`${b.st}Ã—${b.sk||1} ${b.dur||''}s`).join('; ')||'â€”')},{label:'Apply note',render:r=>brEsc(typeof r.apply==='function' ? 'has apply()' : 'â€”')}]})})}
  ${brSection({id:'br-runesmith',title:'Runesmith Upgrades',bodyHTML:brTable({id:'runesmith',rows:RUNESMITH_UPGRADES||[],rowSearchText:r=>`${r.id} ${r.name} ${r.baseDesc}`,columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(`${r.icon||''} ${r.name}`)},{label:'Cost',render:r=>`áš±${brEsc(r.cost)}`},{label:'Description',render:r=>brEsc(typeof r.describe==='function'?r.describe():r.baseDesc)}]})})}
  ${brSection({id:'br-aspects',title:'Aspects',bodyHTML:brTable({id:'aspects',rows:aspectRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'Aspect',render:r=>brEsc(`${r.icon} ${r.aspect}`)},{label:'Thresholds (ranks)',render:r=>brEsc(r.thresholds)}]})+`<div style="height:8px"></div>`+brTable({id:'tagAspect',rows:mapRows,rowSearchText:r=>`${r.tag} ${r.aspect}`,columns:[{label:'Tag',render:r=>brChip(r.tag)},{label:'Aspect',render:r=>brEsc(`${ASPECT_ICON[r.aspect]||'âœ¦'} ${r.aspect}`)}]})})}
  ${brSection({id:'br-rag',title:'RagnarÃ¶k Tiers',bodyHTML:brTable({id:'rag',rows:ragRows,rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'Tier',render:r=>brEsc(r.tier)},{label:'Name',render:r=>brEsc(r.name)},{label:'Omen',render:r=>brEsc(r.omen)},{label:'Effect',render:r=>brEsc(r.effect)}]})})}
  ${brSection({id:'br-status',title:'Status Effects',bodyHTML:brTable({id:'status',rows:Object.entries(STATUS||{}).map(([id,s])=>({id,name:s.name,desc:s.desc})),rowSearchText:r=>Object.values(r).join(' '),columns:[{label:'ID',render:r=>`<code>${brEsc(r.id)}</code>`},{label:'Name',render:r=>brEsc(r.name)},{label:'Description',render:r=>brEsc(r.desc)}]})})}
  </div>`;
}

function setCodexView(v){
  META.codexView=(v==='balance')?'balance':'lore';
  saveMeta();
  setLegacyTab('codex');
}

function codexHTML(){
  checkCodexUnlocks();
  const view=(META.codexView||'lore');
  const loreActive=view==='lore';
  const balActive=view==='balance';
  return `<div class="br-codex-wrap"><div class="br-codex-top"><div class="br-codex-title">ğŸ“– Codex</div><div class="br-toggle"><button class="br-tbtn ${loreActive?'active':''}" onclick="setCodexView('lore')">Lore</button><button class="br-tbtn ${balActive?'active':''}" onclick="setCodexView('balance')">Balance Review</button></div></div>${loreActive?codexLoreHTML():codexBalanceHTML()}</div>`;
}


const RUNESMITH_UPGRADES=[
  {id:'evCap',name:'Stronger Pattern',icon:'ğŸ§¬',baseDesc:'Raise EV cap by +10',cost:30,describe:()=>`Raise EV cap by +10 (currently ${evCap()})`},
  {id:'imprintChance',name:'Echo Binding Mastery',icon:'ğŸ’«',baseDesc:'+15% Echo Binding success chance',cost:25,describe:()=>`+15% Echo Binding success chance (currently ${Math.round(imprintChance()*100)}%)`},
  {id:'poolSize',name:'Wider Pool',icon:'ğŸ›',baseDesc:'+2 retired pool slots',cost:20,describe:()=>`+2 retired pool slots (currently ${poolMax()})`},
  {id:'mutationRate',name:'Mutation Catalyst',icon:'âš¡',baseDesc:'+3% mutation chance',cost:20,describe:()=>`+3% mutation chance (currently ${Math.round(mutationRate()*100)}%)`},
  {id:'nursery',name:'Nursery Program',icon:'ğŸ‘¶',baseDesc:'+15% chance retired heroes have 2 memory binding uses',cost:25,describe:()=>`+15% chance retired heroes have 2 memory binding uses (currently +${Math.round((META.upgrades.nursery||0)*15)}%)`},
];

// â”€â”€â”€ UPGRADES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderRunesmith(){
  const ups=RUNESMITH_UPGRADES.map(u=>({...u,desc:(typeof u.describe==='function'?u.describe():u.baseDesc)}));
  const unlocked=[...META.unlockedTraits];
  const locked=GTRAIT_KEYS.filter(k=>!unlocked.includes(k));
  let h=`<div>
    <div style="font-size:16px;font-weight:700;color:var(--gold);margin-bottom:4px">Legacy Runesmith</div>
    <div style="font-size:11px;color:var(--txt3);margin-bottom:16px">Spend Relics from fallen heroes to permanently improve your lineage.</div>
    <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(240px,1fr));gap:10px;margin-bottom:20px">
      ${ups.map(u=>`<div style="background:var(--bg2);border:1px solid var(--border2);border-radius:5px;padding:12px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px">
          <div style="font-weight:700;font-size:13px">${u.icon} ${u.name}</div>
          <div style="font-size:10px;font-weight:700;color:var(--salvage)">áš±${u.cost}</div>
        </div>
        <div style="font-size:11px;color:var(--txt2);margin-bottom:8px">${u.desc}</div>
        <div style="font-size:10px;color:var(--txt3);margin-bottom:8px">Rank: ${META.upgrades[u.id]||0}</div>
        <button class="btn btn-salvage btn-sm${META.salvage<u.cost?' sb-disabled':''}" onclick="buyUpgrade('${u.id}',${u.cost})">Purchase</button>
      </div>`).join('')}
    </div>`;
  if(locked.length){
    h+=`<div style="font-size:14px;font-weight:700;margin-bottom:10px;color:var(--cyan)">ğŸ§¬ Unlock Mutation Traits</div>
      <div style="font-size:11px;color:var(--txt3);margin-bottom:10px">Spend Relics to add new traits to your mutation pool. These can appear during memory binding.</div>
      <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:8px">
        ${locked.map(tk=>{
          const gt=GTRAITS[tk];if(!gt)return '';
          const disabled=META.salvage<15;
          return `<div style="background:var(--bg2);border:1px solid var(--border2);border-radius:4px;padding:10px">
            <div style="font-weight:700;font-size:12px;color:#d090ff">${gt.icon} ${gt.name}</div>
            <div style="font-size:10px;color:var(--txt2);margin:3px 0">${gt.desc}</div>
            <button class="btn btn-sm" style="margin-top:6px;background:rgba(200,60,255,.1);border:1px solid rgba(200,60,255,.3);color:#d090ff;${disabled?'opacity:.4;cursor:not-allowed':''}" onclick="unlockTrait('${tk}')">áš±15 Unlock</button>
          </div>`;
        }).join('')}
      </div>`;
  }
  h+=`<div style="margin-top:20px;border-top:1px solid var(--border);padding-top:16px">
      <div style="font-size:14px;font-weight:700;margin-bottom:10px;color:var(--amber)">ğŸ’¾ Save Data</div>
      <div style="display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn btn-sm btn-amber" onclick="doExport()">ğŸ“¤ Export Save</button>
        <button class="btn btn-sm btn-ghost" onclick="doImport()">ğŸ“¥ Import Save</button>
        <button class="btn btn-sm btn-danger" onclick="doResetMeta()">ğŸ—‘ Reset All Data</button>
      </div>
    </div>
  </div>`;
  return h;
}
function buyUpgrade(id,cost){if(META.salvage<cost)return;META.salvage-=cost;META.upgrades[id]=(META.upgrades[id]||0)+1;saveMeta();setLegacyTab('upgrades');updateMetaHeader();}
function unlockTrait(tk){if(META.salvage<15)return;META.salvage-=15;META.unlockedTraits.add(tk);saveMeta();setLegacyTab('upgrades');updateMetaHeader();}
function doExport(){
  const s=exportSave();
  const ta=document.createElement('textarea');ta.value=s;document.body.appendChild(ta);ta.select();
  document.execCommand('copy');document.body.removeChild(ta);
  alert('Save data copied to clipboard!');
}
function doImport(){
  const s=prompt('Paste save data:');
  if(s&&importSave(s)){alert('Save imported successfully!');setLegacyTab('upgrades');updateMetaHeader();}
  else if(s)alert('Invalid save data.');
}
function doResetMeta(){
  if(!confirm('Reset ALL legacy data? This cannot be undone.'))return;
  localStorage.removeItem(META_KEY);
  META={legacyEssence:0,salvage:0,retiredPool:[],fallenLedger:[],family:{},upgrades:{evCap:0,imprintChance:0,poolSize:0,mutationRate:0,nursery:0},
    unlockedTraits:new Set(['serrated','aegis','skirmisher','venomkiss','gambler','spite','ironblood','swift_born','lucky','resilient']),nextHeroId:1,
    ragnarÃ¶kTier:0,ragnarÃ¶kActive:0,eliteRoster:{},relics:0,hasSeenOpening:false,houseName:null,aspects:{},scarTokens:{},codexUnlocked:['weaver','minni','yggdrasil','allfather','valhalla','saga','rune','norns']};
  saveMeta();setLegacyTab('upgrades');updateMetaHeader();
}

// â•â•â• OVERLAY HELPERS â•â•â•
function showOverlayContent(html){
  document.getElementById('overlay-content').innerHTML=html;
  document.getElementById('overlay').style.display='flex';
}
function hideOverlay(){document.getElementById('overlay').style.display='none';}

function showAllFatherGift(){
  const owned=new Set(G.boons.map(b=>b.id));
  const axioms=BOONS.filter(b=>b.rarity==='axiom'&&!owned.has(b.id));
  const offered=rshuffle(axioms).slice(0,3);

  if(!offered.length){
    resumeAfterAllFatherGift();
    return;
  }

  const html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:16px;font-weight:900;
                color:var(--gold);margin-bottom:8px">á›Ÿ THE ALLFATHER'S LAST GIFT</div>
    <div style="font-size:11px;color:var(--txt2);font-style:italic;margin-bottom:14px">
      "He has nothing left to withhold."
    </div>
    <div style="font-size:11px;color:var(--txt3);margin-bottom:14px">
      Choose one Rune Law. This is given freely â€” the cost is what comes next in the saga.
    </div>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px">
      ${offered.map(b=>`
        <div class="boon-card rc-axiom" onclick="acceptAllFatherGift('${b.id}')">
          <div style="font-size:9px;color:#d050ff;margin-bottom:4px">RUNE LAW</div>
          <div><span style="font-size:14px">${b.icon}</span>
               <span class="boon-name">${b.name.replace('RUNE: ','')}</span></div>
          <div class="boon-desc" style="margin-top:3px">${b.desc}</div>
        </div>
      `).join('')}
    </div>
  `;
  showOverlayContent(html);
}

function acceptAllFatherGift(boonId){
  const boon=BOONS.find(b=>b.id===boonId);
  if(!boon)return;
  G.boons.push(boon);
  applyBoonEffectsOnPick(boon);
  addLog(`á›Ÿ A watcher-gift accepted: ${boon.name}`,'laxiom');
  hideOverlay();
  resumeAfterAllFatherGift();
}

function resumeAfterAllFatherGift(){
  G.phase='BATTLE';
  applyEnemyStartTraits();
  applyBattleStartTactics();
  if(G.waveFlags.heroStartVuln){
    applyStatus(G.hero,'vulnerable',1,G.waveFlags.heroStartVuln);
    addLog(`  ğŸ¯ Marked Prey: Vulnerable (${G.waveFlags.heroStartVuln}s)`,'lstatus');
  }
  addLog(`âš” Trial ${G.wave} â€” ${G.enemies.length} enemies!`,'lwave');
  NarrationEngine.reset();
  const waveStartLine=MYTH_LINES.waveStart[G.wave];
  if(waveStartLine)NarrationEngine.fire('waveStart',waveStartLine,'lstatus');
  G.enemies.forEach(e=>addLog(`  ${e.icon} ${e.displayName||e.name} HP:${e.hp} ATK:${e.atk} DEF:${e.def}`,'lstatus'));
  renderAll();
  if(G.interval)clearInterval(G.interval);
  G.interval=setInterval(combatTick,100/G.speed);
}


function resolveRoadside(){
  if(!G||!G.roadside)return;
  if(G.roadside.used && typeof G.roadside.used[G.wave] !== 'undefined')G.roadside.used[G.wave]=true;
  G.roadsideAvailable=false;
  hideOverlay();
  renderAll();
}
function getResolveRelicOffers(){
  const chosen=new Set((G.roadside.resolveRelics||[]).map(r=>r.id));
  const tagCounts={};
  (G.boons||[]).forEach(b=>(b.tags||[]).forEach(t=>tagCounts[t]=(tagCounts[t]||0)+1));
  const top=Object.entries(tagCounts).sort((a,b)=>b[1]-a[1]).map(x=>x[0]);
  const wanted=[];
  top.forEach(t=>{
    if(['Sustain'].includes(t))wanted.push('root_cup');
    else if(['Tempo'].includes(t))wanted.push('wolf_step');
    else if(['Bulwark','Shield'].includes(t))wanted.push('fired_ward');
    else if(['Bleed'].includes(t))wanted.push('carvers_edge');
    else if(['Poison'].includes(t))wanted.push('eitr_kiln');
    else if(['Crit'].includes(t))wanted.push('sootglass_eye');
  });
  wanted.push('fired_ward','root_cup');
  const offers=[];
  wanted.forEach(id=>{if(offers.length<3&&!offers.some(o=>o.id===id)&&!chosen.has(id)){const r=RESOLVE_RELICS.find(x=>x.id===id);if(r)offers.push(r);}});
  const pool=rshuffle(RESOLVE_RELICS.filter(r=>!chosen.has(r.id)&&!offers.some(o=>o.id===r.id)));
  while(offers.length<3&&pool.length)offers.push(pool.shift());
  return offers;
}
function applyRandomSacrifice(){
  const opts=[];
  const gearSlots=Object.entries(G.hero.gear||{}).filter(([k,v])=>v);
  if(gearSlots.length)opts.push('gear');
  if((G.hero.traits||[]).length)opts.push('trait');
  if((G.gold||0)>0)opts.push('gold');
  if((G.hero.hp||0)>1)opts.push('hp');
  opts.push('reroll');
  const pick=rpick(opts);
  if(pick==='gear'){
    const [slot,item]=rpick(gearSlots);
    G.hero.gear[slot]=null;
    applyGearMaxHPDelta(G.hero,item,null);
    addLog(`âš±ï¸ Sacrifice: Lost ${slot} â€” ${item.name}.`,'lstatus');
  }else if(pick==='trait'){
    const idx=ri(0,G.hero.traits.length-1); const tk=G.hero.traits[idx]; G.hero.traits.splice(idx,1);
    if(tk==='ironblood')G.hero.def=Math.max(0,G.hero.def-5);
    if(tk==='swift_born')G.hero.spd=Math.max(1,G.hero.spd-8);
    if(tk==='lucky')G.hero.critChance=Math.max(0,G.hero.critChance-0.04);
    if(tk==='resilient'){G.hero.maxHP=Math.max(1,G.hero.maxHP-25);G.hero.hp=Math.min(G.hero.hp,G.hero.maxHP);}
    if(tk==='gambler'){G.hero.critChance=Math.max(0,G.hero.critChance-0.05);G.hero.def=Math.max(0,G.hero.def+2);}
    if(tk==='vampiric_b')G.hero.lifesteal=Math.max(0,G.hero.lifesteal-0.03);
    addLog(`âš±ï¸ Sacrifice: Lost trait ${GTRAITS[tk]?.name||tk}.`,'lstatus');
  }else if(pick==='gold'){
    const loss=(G.gold>=10)?Math.max(10,Math.floor(G.gold*0.15)):Math.floor(G.gold*0.15);
    G.gold=Math.max(0,G.gold-loss); addLog(`âš±ï¸ Sacrifice: Lost á›‹${loss}.`,'lstatus');
  }else if(pick==='hp'){
    const loss=Math.max(1,Math.floor(G.hero.hp*0.20)); G.hero.hp=Math.max(1,G.hero.hp-loss); addLog(`âš±ï¸ Sacrifice: Bled ${loss} HP.`,'lstatus');
  }else if(pick==='reroll'){
    G.rerollCost+=12; addLog(`âš±ï¸ Sacrifice: Reroll cost rises by 12.`,'lstatus');
  }
}
function chooseRoadsideClay(){
  const offers=getResolveRelicOffers();
  const html=`<div style="font-family:'Orbitron',sans-serif;font-size:16px;font-weight:900;color:var(--amber);margin-bottom:8px">ğŸ§± CLAY â€” Strengthen your resolve</div>
  <div style="font-size:11px;color:var(--txt2);margin-bottom:10px">Choose what you carry from the fire.</div>
  <div style="display:flex;flex-direction:column;gap:8px">${offers.map(r=>`<div class="imprint-card" onclick="takeResolveRelic('${r.id}')"><div style="font-weight:800">${r.icon} ${r.name}</div><div style="font-size:10px;color:var(--txt2)">${r.desc}</div></div>`).join('')}</div>`;
  showOverlayContent(html);
}
function takeResolveRelic(id){
  const r=RESOLVE_RELICS.find(x=>x.id===id); if(!r)return;
  if(!G.roadside.resolveRelics.some(x=>x.id===id))G.roadside.resolveRelics.push(JSON.parse(JSON.stringify(r)));
  Object.entries(r.mults||{}).forEach(([k,v])=>{G.roadside.resolveMult[k]=Math.max(G.roadside.resolveMult[k]||1,v);});
  addLog(`ğŸ§± ${r.name} taken from the fire.`,'laxiom');
  resolveRoadside();
}
function chooseRoadsideAsh(){
  G.roadside.goldMult*=1.25; G.roadside.essenceMult*=1.20;
  const used=new Set((G.roadside.debts||[]).map(d=>d.id));
  const debtPool=DEBTS.filter(d=>!used.has(d.id));
  if(debtPool.length){
    const d=rpick(debtPool);
    if(typeof d.apply==='function')d.apply(G);
    G.roadside.debts.push({id:d.id,name:d.name,icon:d.icon,desc:d.desc,battleStart:(d.battleStart||[]).map(x=>({...x}))});
    unlockCodexEntry('skuldsDebt');
    addLog(`âš±ï¸ ${d.name} â€” ${d.desc}`,'laxiom');
  }
  applyRandomSacrifice();
  resolveRoadside();
}
function showRoadsideFire(){
  if(!G||!G.roadsideAvailable)return;
  const html=`<div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;color:var(--amber);margin-bottom:8px">ğŸ”¥ THE WEAVER'S ROADSIDE FIRE</div>
    <div style="font-size:12px;color:var(--txt2);margin-bottom:12px">I tend the roadside kiln and offer three workings: Water, Clay, or Ash.</div>
    <div style="display:flex;flex-direction:column;gap:8px">
      <button class="btn" onclick="resolveRoadside();retireHero(G.wave-1)">ğŸ’§ Water â€” Quench this generation.</button>
      <button class="btn" onclick="chooseRoadsideClay()">ğŸ§± Clay â€” Temper the living pattern.</button>
      <button class="btn" onclick="chooseRoadsideAsh()">âš±ï¸ Ash â€” Accept Skuld's Debt.</button>
      <button class="btn btn-sm btn-ghost" onclick="resolveRoadside()">Keep Walking</button>
    </div>`;
  NarrationEngine.fire('generic',MYTH_LINES.roadside,'lstatus');
  showOverlayContent(html);
}

function showRetireConfirm(){
  const rec=G.hero.record;
  const earnedEVs=computeEarnedEVs(G.wave);
  let html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:16px;font-weight:900;color:var(--gold);margin-bottom:8px">ğŸ› BIND THIS MEMORY STONE?</div>
    <p style="color:var(--txt2);font-size:12px;margin-bottom:14px">End your saga at Trial ${G.wave} and add <strong style="color:var(--gold)">${rec?.name||'your hero'}</strong> to the Memory Stones for future memory binding.</p>
    <div style="background:var(--bg2);border:1px solid var(--border);border-radius:5px;padding:10px;margin-bottom:14px;text-align:left">
      <div style="font-size:10px;color:var(--txt3);margin-bottom:5px">EARNED EVs THIS SAGA</div>
      ${EV_KEYS.map(k=>`<div class="srow"><span class="sl" style="font-size:11px">${k.toUpperCase()}_EV</span><span class="sv sdp" style="font-size:11px">+${earnedEVs[k]||0}</span></div>`).join('')}
      <div style="margin-top:8px;font-size:11px;color:var(--gold)">+${Math.floor(G.gold*.35)+G.wave*4} Minni</div>
    </div>
    <div style="display:flex;gap:10px">
      <button class="btn btn-gold" style="flex:1" onclick="hideOverlay();retireHero()">ğŸ› Bind to Minni-HÃ¶ll</button>
      <button class="btn btn-sm btn-ghost" style="flex:1" onclick="hideOverlay()">âš” Keep Fighting</button>
    </div>`;
  showOverlayContent(html);
}

function startNewRunFromOverlay(){
  const seed=(document.getElementById('seed-input')?.value||'').trim();
  hideOverlay();
  startFirstHero(seed||null);
}

// â•â•â• CONTROLS â•â•â•
function cycleSpeed(){
  if(!G)return;
  const speeds=[1,2,4];
  const idx=speeds.indexOf(G.speed);
  G.speed=speeds[(idx+1)%speeds.length];
  document.getElementById('btn-speed').textContent=`${G.speed}Ã— Speed`;
  if(G.interval){
    clearInterval(G.interval);
    if(G.phase==='BATTLE')G.interval=setInterval(combatTick,100/G.speed);
  }
}
function confirmReset(){
  if(G&&G.phase==='BATTLE')clearInterval(G.interval);
  G=null;
  updateDifficultyUI();
  showStartScreen();
}

// â•â•â• LOG â•â•â•
function fxHpImpact({crit=false,big=false}={}){
  const el = document.getElementById('hero-hp-bar');
  if(!el) return;
  el.classList.remove('hp-crit','bar-boom');
  void el.offsetWidth;
  if(crit || big) el.classList.add('hp-crit','bar-boom');
}

function fxEnemyImpact(enemyId,{crit=false,big=false}={}){
  const el = document.getElementById('enemy-hp-bar-'+enemyId);
  if(!el) return;
  el.classList.remove('hp-crit','bar-boom');
  void el.offsetWidth;
  if(crit || big) el.classList.add('hp-crit','bar-boom');
}

function addLog(msg,cls=""){
  const log = document.getElementById("combat-log");
  if(!log) return;
  const nearBottom = (log.scrollHeight - log.scrollTop - log.clientHeight) < 60;

  const div = document.createElement("div");
  div.className = cls || 'lhit';
  div.innerHTML = msg;
  log.appendChild(div);

  while(log.children.length>400)log.removeChild(log.firstChild);
  if(nearBottom) log.scrollTop = log.scrollHeight;
}
function clearLog(){document.getElementById('combat-log').innerHTML='';}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RESPONSIVE DRAWERS + CHROME HEIGHT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function syncChromeHeights(){
  const hd=document.getElementById('header');
  const ft=document.getElementById('footer');
  if(hd){
    const h=Math.ceil(hd.getBoundingClientRect().height);
    document.documentElement.style.setProperty('--header-h',h+'px');
  }
  if(ft){
    const f=Math.ceil(ft.getBoundingClientRect().height);
    document.documentElement.style.setProperty('--footer-h',f+'px');
  }
}
function closeDrawers(){document.body.classList.remove('drawer-hero','drawer-right');}
function toggleDrawer(which){
  const cls=(which==='hero')?'drawer-hero':'drawer-right';
  const isOn=document.body.classList.contains(cls);
  closeDrawers();
  if(!isOn)document.body.classList.add(cls);
  syncChromeHeights();
}
function applyResponsiveLayout(){
  syncChromeHeights();
  if(!window.matchMedia('(max-width: 980px)').matches)closeDrawers();
}
document.addEventListener('keydown',(e)=>{if(e.key==='Escape')closeDrawers();});
window.addEventListener('resize',applyResponsiveLayout);
window.addEventListener('orientationchange',()=>setTimeout(applyResponsiveLayout,150));

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COLLAPSIBLE COMBAT LOG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setCombatLogCollapsed(collapsed){
  UI.logCollapsed=!!collapsed;
  saveUI();
  const wrap=document.getElementById('log-wrap');
  const btn=document.getElementById('btn-log-toggle');
  if(UI.logCollapsed){
    wrap.classList.add('collapsed');
    if(btn)btn.textContent='Expand';
  }else{
    wrap.classList.remove('collapsed');
    if(btn)btn.textContent='Collapse';
    const log=document.getElementById('combat-log');
    log.scrollTop=log.scrollHeight;
  }
  syncChromeHeights();
}
function toggleCombatLog(){setCombatLogCollapsed(!UI.logCollapsed);}

// â•â•â• INIT â•â•â•
window.onload=()=>{
  loadMeta();
  loadUI();
  if(typeof UI.difficulty!=='number')UI.difficulty=1;
  Object.values(META.family).forEach(h=>{if(!h.evs)h.evs=emptyEVs();});
  // Ensure retired heroes have memory binding uses; remove spent/missing from pool
  Object.values(META.family).forEach(h=>{
    if(h && h.runResult && (h.runResult.outcome==='retired' || h.runResult.outcome==='victory')){
      if(typeof h.breedUsesMax!=='number' || h.breedUsesMax<=0) h.breedUsesMax=1;
      if(typeof h.breedUsesLeft!=='number') h.breedUsesLeft=h.breedUsesMax;
    }
  });
  if(Array.isArray(META.retiredPool)){
    META.retiredPool=META.retiredPool.filter(id=>{
      const r=META.family[id];
      if(!r) return false;
      const u=getBreedUses(r);
      return u.left>0;
    });
  }
  saveMeta();
  const small=window.matchMedia('(max-width: 420px)').matches;
  if(small&&localStorage.getItem(UI_KEY)===null){
    UI.logCollapsed=true;
    saveUI();
  }
  setCombatLogCollapsed(UI.logCollapsed);
  updateDifficultyUI();
  showStartScreen();
  setTimeout(applyResponsiveLayout,0);
};


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V5 PATCH â€” Aspects + Memory Binding Actions + Fallen Scars/Relics
// Naming â€” Generations + Blended Children
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// --- Add SCAR traits (risk/reward) ---
const SCARS = {
    frayed_nerves:{name:'Frayed Nerves',icon:'âš¡',desc:'+12 SPD; start battle Vulnerable (1.5s).',color:'#c080ff'},
    panic_surge:{name:'Panic Surge',icon:'ğŸ’¢',desc:'Start battle +2 Momentum; first attack âˆ’15% accuracy.',color:'#b090ff'},
    silent_step:{name:'Silent Step',icon:'ğŸ©°',desc:'+10% Evasion; âˆ’4% Crit Chance.',color:'#9bb0ff'},
    shallow_breath:{name:'Shallow Breath',icon:'ğŸ«',desc:'+8 SPD; healing received âˆ’20%.',color:'#9f88cc'},
    cold_iron:{name:'Cold Iron',icon:'ğŸ§Š',desc:'+8 DEF; âˆ’4% Crit Chance.',color:'#80a8ff'},
    scarred_plate:{name:'Scarred Plate',icon:'ğŸ§±',desc:'+10 DEF; âˆ’10 SPD.',color:'#8fa2c6'},
    iron_reflex:{name:'Iron Reflex',icon:'ğŸ›¡ï¸',desc:'Enemy crit bonus damage vs you âˆ’50%; âˆ’10 Max HP.',color:'#96b4d8'},
    shattered_guard:{name:'Shattered Guard',icon:'ğŸ§·',desc:'Start battle +18 Shield (shield offhand only); âˆ’4 DEF.',color:'#7fa0ff'},
    brittle_edge:{name:'Brittle Edge',icon:'ğŸ©¶',desc:'+8% Crit; crits apply Marked (2s); âˆ’20 Max HP.',color:'#e8c048'},
    grave_salt:{name:'Grave Salt',icon:'ğŸœƒ',desc:'+8 ATK; âˆ’12 Max HP.',color:'#ff7070'},
    death_oath:{name:'Death Oath',icon:'â˜ ï¸',desc:'First hit applies Marked (3s); start battle Weak (2s).',color:'#ff8a70'},
    thin_margin:{name:'Thin Margin',icon:'ğŸ©¸',desc:'+15% dmg vs <30% HP enemies; below 30% HP, healing received âˆ’35%.',color:'#ff9660'},
    bitter_blood:{name:'Bitter Blood',icon:'â˜£ï¸',desc:'Poison damage +25%; lifesteal effectiveness âˆ’50%.',color:'#79cf7e'},
    eitr_cough:{name:'Eitr Cough',icon:'ğŸ¤¢',desc:'On hit 15%: +1 Poison (3s); start battle Weak (2s).',color:'#70d870'},
    open_wound:{name:'Open Wound',icon:'ğŸ©¹',desc:'Bleed damage +25%; if Bleeding, lose 1 HP/sec.',color:'#ff6a6a'},
    coin_scar:{name:'Coin Scar',icon:'ğŸª™',desc:'Marks gained +15%; rerolls cost +5.',color:'#d9b45a'},
};

(function(){
  Object.assign(GTRAITS, SCARS);
  for(const k of Object.keys(SCARS)){
    if(Array.isArray(GTRAIT_KEYS) && !GTRAIT_KEYS.includes(k)) GTRAIT_KEYS.push(k);
    // Make scars unlockable via mutation only after discovered; so do NOT auto-add to unlockedTraits here.
  }
})();

// --- Aspects (lineage identity) ---
const ASPECTS = ['Steel','Gale','Venom','Execution','Axiom'];
const ASPECT_ICON = {Steel:'ğŸ›¡',Gale:'ğŸŒª',Venom:'ğŸ',Execution:'ğŸº',Axiom:'áš±'};
const ASPECT_COLOR = {Steel:'#78a8ff',Gale:'#c080ff',Venom:'#70d870',Execution:'#f0a828',Axiom:'#d050ff'};
const ASPECT_THRESH = [0, 60, 140, 260]; // rank 0..3

const TAG_ASPECT = {
  Bulwark:'Steel', Shield:'Steel', Thorns:'Steel', Sustain:'Steel',
  Tempo:'Gale',
  Bleed:'Venom', Poison:'Venom',
  Crit:'Execution', Execute:'Execution',
  Axiom:'Axiom', Arcane:'Axiom'
};

const TRAIT_ASPECT = {
  serrated:'Venom', venomkiss:'Venom',
  aegis:'Steel', ironblood:'Steel', tenacious:'Steel', spite:'Steel', resilient:'Steel',
  swift_born:'Gale', skirmisher:'Gale',
  lucky:'Execution', gambler:'Execution', predatory:'Execution', executioner_b:'Execution', vampiric_b:'Venom',
  frayed_nerves:'Gale', panic_surge:'Gale', silent_step:'Gale', shallow_breath:'Gale', cold_iron:'Steel', scarred_plate:'Steel', iron_reflex:'Steel', shattered_guard:'Steel', brittle_edge:'Execution', grave_salt:'Execution', death_oath:'Execution', thin_margin:'Execution', bitter_blood:'Venom', eitr_cough:'Venom', open_wound:'Venom', coin_scar:'Axiom',
};

function aspectRankFromXp(xp){
  const x = Math.max(0, Math.floor(xp||0));
  if(x >= ASPECT_THRESH[3]) return 3;
  if(x >= ASPECT_THRESH[2]) return 2;
  if(x >= ASPECT_THRESH[1]) return 1;
  return 0;
}
function aspectNextThreshold(rank){
  const r = Math.max(0, Math.min(3, rank|0));
  return ASPECT_THRESH[Math.min(3, r+1)] || ASPECT_THRESH[3];
}
function getAspectState(aspect){
  normalizeMeta();
  return META.aspects[aspect] || {xp:0,rank:0};
}
function getAspectRank(aspect){
  return getAspectState(aspect).rank|0;
}


const ASPECT_BLESSINGS={
  Steel:{hpPctPerRank:0.03,defPerRank:2},
  Gale:{spdPerRank:2,evasionPerRank:0.02},
  Venom:{lifestealPerRank:0.0075,dotTickTakenReductionPerRank:0.07},
  Execution:{critChancePerRank:0.02,critDmgPerRank:0.08},
  Axiom:{accuracyPerRank:0.02,critDmgPerRank:0.04},
};

function computeHouseBlessings(){
  const steelR=getAspectRank('Steel'), galeR=getAspectRank('Gale'), venomR=getAspectRank('Venom'), executionR=getAspectRank('Execution'), axiomR=getAspectRank('Axiom');
  const Steel={rank:steelR,hpPct:steelR*ASPECT_BLESSINGS.Steel.hpPctPerRank,defAdd:steelR*ASPECT_BLESSINGS.Steel.defPerRank};
  const Gale={rank:galeR,spdAdd:galeR*ASPECT_BLESSINGS.Gale.spdPerRank,evasionAdd:galeR*ASPECT_BLESSINGS.Gale.evasionPerRank};
  const Venom={rank:venomR,lifestealAdd:venomR*ASPECT_BLESSINGS.Venom.lifestealPerRank,dotTakenMul:Math.max(0.65,1-(venomR*ASPECT_BLESSINGS.Venom.dotTickTakenReductionPerRank))};
  const Execution={rank:executionR,critChanceAdd:executionR*ASPECT_BLESSINGS.Execution.critChancePerRank,critDmgAdd:executionR*ASPECT_BLESSINGS.Execution.critDmgPerRank};
  const Axiom={rank:axiomR,accuracyAdd:axiomR*ASPECT_BLESSINGS.Axiom.accuracyPerRank,critDmgAdd:axiomR*ASPECT_BLESSINGS.Axiom.critDmgPerRank};
  const totals={
    hpPct:Steel.hpPct,
    defAdd:Steel.defAdd,
    spdAdd:Gale.spdAdd,
    evasionAdd:Gale.evasionAdd,
    lifestealAdd:Venom.lifestealAdd,
    dotTakenMul:Venom.dotTakenMul,
    critChanceAdd:Execution.critChanceAdd,
    critDmgAdd:Execution.critDmgAdd + Axiom.critDmgAdd,
    accuracyAdd:Axiom.accuracyAdd,
  };
  return {Steel,Gale,Venom,Execution,Axiom,totals};
}

function formatHouseBlessingsSummary(bless){
  const t=(bless&&bless.totals)?bless.totals:computeHouseBlessings().totals;
  return `HP+${Math.round(t.hpPct*100)}% DEF+${Math.round(t.defAdd)} SPD+${Math.round(t.spdAdd)} EVA+${Math.round(t.evasionAdd*100)}% LS+${(t.lifestealAdd*100).toFixed(2)}% Crit+${Math.round(t.critChanceAdd*100)}% CD+${Math.round(t.critDmgAdd*100)}% Acc+${Math.round(t.accuracyAdd*100)}% DoTÃ—${t.dotTakenMul.toFixed(2)}`;
}

function houseBlessingsTooltip(bless){
  const b=bless||computeHouseBlessings();
  return [
    `Steel R${b.Steel.rank}: +${Math.round(b.Steel.hpPct*100)}% HP, +${Math.round(b.Steel.defAdd)} DEF`,
    `Gale R${b.Gale.rank}: +${Math.round(b.Gale.spdAdd)} SPD, +${Math.round(b.Gale.evasionAdd*100)}% EVA`,
    `Venom R${b.Venom.rank}: +${(b.Venom.lifestealAdd*100).toFixed(2)}% LS, DoTÃ—${b.Venom.dotTakenMul.toFixed(2)}`,
    `Execution R${b.Execution.rank}: +${Math.round(b.Execution.critChanceAdd*100)}% Crit, +${Math.round(b.Execution.critDmgAdd*100)}% Crit Dmg`,
    `Axiom R${b.Axiom.rank}: +${Math.round(b.Axiom.accuracyAdd*100)}% Accuracy, +${Math.round(b.Axiom.critDmgAdd*100)}% Crit Dmg`,
  ].join(' | ');
}

function applyHouseBlessingsToHero(hero){
  if(!hero)return;
  const bless=computeHouseBlessings();
  const t=bless.totals;
  const oldMax=Math.max(1,Math.floor(hero.maxHP||1));
  const oldHp=Math.max(0,Math.floor(hero.hp||oldMax));
  hero.maxHP=Math.max(1,Math.floor(oldMax*(1+t.hpPct)));
  const delta=hero.maxHP-oldMax;
  hero.hp=Math.max(1,Math.min(hero.maxHP,oldHp+delta));
  hero.def=(hero.def||0)+t.defAdd;
  hero.spd=(hero.spd||0)+t.spdAdd;
  hero.evasion=(hero.evasion||0)+t.evasionAdd;
  hero.lifesteal=(hero.lifesteal||0)+t.lifestealAdd;
  hero.critChance=(hero.critChance||0)+t.critChanceAdd;
  hero.critDmg=(hero.critDmg||0)+t.critDmgAdd;
  hero.accuracy=(hero.accuracy||0)+t.accuracyAdd;
  hero.houseBlessings=bless;
  hero.dotResistMul_fromBlessings=t.dotTakenMul;
}
function addAspectXP(aspect, amount){
  normalizeMeta();
  if(!ASPECTS.includes(aspect)) aspect = 'Steel';
  const st = META.aspects[aspect] || (META.aspects[aspect] = {xp:0,rank:0});
  const prevRank = aspectRankFromXp(st.xp);
  st.xp = Math.max(0, Math.floor((st.xp||0) + (amount||0)));
  st.rank = aspectRankFromXp(st.xp);
  if(st.rank > prevRank){
    try{ addLog(`ğŸ› LINEAGE ASCENDS: ${ASPECT_ICON[aspect]||'âœ¦'} ${aspect} Rank ${st.rank}!`,'laxiom'); }catch(e){}
  }
}
function computeRunAspectScores(){
  const s = {Steel:0,Gale:0,Venom:0,Execution:0,Axiom:0};
  if(!G) return s;
  // Boon tags
  (G.boons||[]).forEach(b=>{
    (b.tags||[]).forEach(t=>{
      const a = TAG_ASPECT[t];
      if(a) s[a] += 4;
    });
    if(b.rarity==='axiom') s.Axiom += 10;
    if(b.rarity==='legendary') s.Axiom += 2;
  });
  // Scars / Pattern currently expressed
  const tr = (G.hero && G.hero.traits) ? G.hero.traits : (G.hero && G.hero.record && G.hero.record.traits) ? G.hero.record.traits : [];
  (tr||[]).forEach(tk=>{
    const a = TRAIT_ASPECT[tk];
    if(a) s[a] += 3;
  });
  return s;
}
function pickTopAspects(scores){
  const entries = Object.entries(scores||{}).sort((a,b)=>b[1]-a[1]);
  const top = entries[0] && entries[0][1]>0 ? entries[0][0] : 'Steel';
  const second = entries[1] && entries[1][1]>0 ? entries[1][0] : null;
  return [top, second];
}
function awardAspectXPFromRun(outcome){
  if(!G) return;
  normalizeMeta();
  const scores = computeRunAspectScores();
  const [a1,a2] = pickTopAspects(scores);
  const base = (8 + (G.wave||1)*3 + Math.floor((G.level||1)*2));
  const mult = (outcome==='victory') ? 1.8 : (outcome==='retired') ? 1.0 : 0.6;
  const xp1 = Math.floor(base*mult);
  const xp2 = Math.floor(base*0.55*mult);
  addAspectXP(a1, xp1);
  if(a2) addAspectXP(a2, xp2);
  // Axiom spillover if any axioms in run
  const ax = (G.boons||[]).filter(b=>b.rarity==='axiom').length;
  if(ax>0) addAspectXP('Axiom', Math.floor((8+ax*8)*mult));
  // Persist
  try{ saveMeta(); updateMetaHeader(); }catch(e){}
}

// --- Generations + blended naming ---
function baseGivenFromFull(full){
  if(!full) return rpick(NAME_PREFIXES);
  // Try to find the first capitalized chunk
  const first = full.split(' ')[0] || '';
  const clean = first.replace(/[^A-Za-z]/g,'');
  return clean || rpick(NAME_PREFIXES);
}
function capName(s){
  if(!s) return s;
  return s.charAt(0).toUpperCase() + s.slice(1);
}
function blendCandidates(nameA, nameB){
  const A = baseGivenFromFull(nameA);
  const B = baseGivenFromFull(nameB);
  const cuts = [[3,3],[4,3],[3,4],[2,3]];
  const out = [];
  for(const [p,s] of cuts){
    const pA = A.slice(0, Math.min(p, A.length));
    const sB = B.slice(Math.max(0, B.length-s));
    out.push(capName(pA + sB));
    const pB = B.slice(0, Math.min(p, B.length));
    const sA = A.slice(Math.max(0, A.length-s));
    out.push(capName(pB + sA));
  }
  // Seeded fallback
  out.push(capName(A.slice(0,4) + rpick(NAME_SUFFIXES)));
  // Unique + sane lengths
  const uniq = [];
  for(const c of out){
    const v = (c||'').replace(/[^A-Za-z]/g,'');
    if(v.length<4) continue;
    if(!uniq.includes(v)) uniq.push(v);
  }
  return uniq.length ? uniq : [capName(rpick(NAME_PREFIXES)+rpick(NAME_SUFFIXES))];
}
function birthEpithet(aspect, flags){
  if(flags && flags.spliceScar) return 'the Scarred Heir';
  if(flags && flags.spliceRelic) return 'the Bound';
  if(flags && flags.mutated) return 'the Unshaped';
  const map = {
    Steel:'the Shieldbearer',
    Gale:'the Stormswift',
    Venom:'the Serpentblood',
    Execution:'the Wolfbitten',
    Axiom:'the Runebound'
  };
  return map[aspect] || 'the Ascendant';
}
function pickGivenForAspect(cands, aspect){
  const idxMap = {Steel:0,Gale:1,Venom:2,Execution:3,Axiom:4};
  const idx = idxMap[aspect] ?? 0;
  return cands[idx % cands.length];
}

// Override genName while keeping signature
function genName(gen, aspectOrTag, parentNames, flags){
  normalizeMeta();
  const house = META.houseName || genHouseName();
  const aspect = (ASPECTS.includes(aspectOrTag)) ? aspectOrTag : (TAG_ASPECT[aspectOrTag] || 'Steel');

  if(gen===0){
    const given = capName(rpick(NAME_PREFIXES) + rpick(NAME_SUFFIXES));
    return `${given} the First of House ${house}`;
  }
  const pA = parentNames && parentNames[0] ? parentNames[0] : '';
  const pB = parentNames && parentNames[1] ? parentNames[1] : '';
  const cands = blendCandidates(pA, pB);
  const given = pickGivenForAspect(cands, aspect);
  const epi = birthEpithet(aspect, flags);
  return `${given} ${epi} of House ${house}`;
}

// Override mkHeroRecord to store lineage metadata
function mkHeroRecord(name,gen,parentIds,evs,traits){
  normalizeMeta();
  return {
    id: mkHeroId(),
    name,
    gen: (typeof gen==='number'?gen:0),
    parentIds: parentIds || [],
    evs: {...(evs||emptyEVs())},
    traits: [...(traits||[])],
    runResult: null,
    house: META.houseName || '',
    birthAspect: 'Steel',
    birthFlags: {},
  };
}

function genHouseName(){
  // short & punchy: Prefix+Suffix, then title-case
  const raw = (rpick(NAME_PREFIXES) + rpick(NAME_SUFFIXES)).replace(/[^A-Za-z]/g,'');
  return capName(raw);
}
function normalizeMeta(){
  if(typeof META !== 'object' || !META) META = {};
  if(!META.houseName || typeof META.houseName !== 'string') META.houseName = genHouseName();
  if(!META.aspects || typeof META.aspects !== 'object') META.aspects = {};
  for(const a of ASPECTS){
    if(!META.aspects[a]) META.aspects[a] = {xp:0,rank:0};
    META.aspects[a].xp = Math.max(0, Math.floor(META.aspects[a].xp||0));
    META.aspects[a].rank = aspectRankFromXp(META.aspects[a].xp);
  }
  META.relics = Math.max(0, Math.floor(META.relics||0));
  if(typeof META.ragnarÃ¶kTier !== 'number') META.ragnarÃ¶kTier = 0;
  if(typeof META.ragnarÃ¶kActive !== 'number') META.ragnarÃ¶kActive = 0;
  if(!META.eliteRoster || typeof META.eliteRoster !== 'object') META.eliteRoster = {};
  if(typeof META.hasSeenOpening !== 'boolean') META.hasSeenOpening = false;
  if(!META.scarTokens || typeof META.scarTokens !== 'object') META.scarTokens = {};
  if(!Array.isArray(META.lineageScarPool)) META.lineageScarPool = [];
  if(!META.codexUnlocked||!Array.isArray(META.codexUnlocked))META.codexUnlocked=['yggdrasil','allfather','valhalla','saga','rune','norns'];
  if(META.codexView!=='balance') META.codexView='lore';
  if(typeof META.bindingCounter!=='number') META.bindingCounter=0;
  for(const k of Object.keys(META.scarTokens)){
    META.scarTokens[k] = Math.max(0, Math.floor(META.scarTokens[k]||0));
    if(META.scarTokens[k] <= 0) delete META.scarTokens[k];
  }
}

// --- Scar/Relic inventory helpers ---
const LINEAGE_SCAR_INHERIT_CHANCE = 0.20;

function totalScarTokens(){
  normalizeMeta();
  return Object.values(META.scarTokens||{}).reduce((a,b)=>a+(b||0),0);
}
function scarTokenCount(k){
  normalizeMeta();
  return (META.scarTokens && META.scarTokens[k]) ? META.scarTokens[k] : 0;
}
function addScarToken(k, n){
  normalizeMeta();
  META.scarTokens[k] = Math.max(0, (META.scarTokens[k]||0) + (n||0));
  if(META.scarTokens[k] <= 0) delete META.scarTokens[k];
}

// --- Apply trait stat effects (wrap original) ---
(function(){
  const _applyPatternTraitStats = applyPatternTraitStats;
  applyPatternTraitStats = function(h){
    _applyPatternTraitStats(h);
    if(!h || !h.traits) return;
    if(h.traits.includes('frayed_nerves')) h.spd += 12;
    if(h.traits.includes('panic_surge')) h.spd += 6;
    if(h.traits.includes('silent_step')){h.evasion=Math.min(0.6,h.evasion+0.10);h.critChance=Math.max(0,h.critChance-0.04);} 
    if(h.traits.includes('shallow_breath')) h.spd += 8;

    if(h.traits.includes('cold_iron')){ h.def += 8; h.critChance = Math.max(0, Math.min(0.9, h.critChance - 0.04)); }
    if(h.traits.includes('scarred_plate')){ h.def += 10; h.spd = Math.max(5,h.spd-10); }
    if(h.traits.includes('iron_reflex')){ h.maxHP = Math.max(30, h.maxHP - 10); h.hp = Math.min(h.hp, h.maxHP); }
    if(h.traits.includes('shattered_guard')) h.def = Math.max(0,h.def-4);

    if(h.traits.includes('brittle_edge')){ h.critChance = Math.min(0.9, h.critChance + 0.08); h.maxHP = Math.max(30, h.maxHP - 20); h.hp = Math.min(h.hp, h.maxHP); }
    if(h.traits.includes('grave_salt')){ h.atk += 8; h.maxHP=Math.max(30,h.maxHP-12); h.hp=Math.min(h.hp,h.maxHP);} 
    if(h.traits.includes('thin_margin')) h.flags.thinMargin=true;

    if(h.traits.includes('bitter_blood')) h.flags.bitterBlood=true;
  };
})();

// --- Fallen scar/relic choice systems ---
const SCAR_KEYS = ['frayed_nerves','panic_surge','silent_step','shallow_breath','cold_iron','scarred_plate','iron_reflex','shattered_guard','brittle_edge','grave_salt','death_oath','thin_margin','bitter_blood','eitr_cough','open_wound','coin_scar'];

const SCAR_DEF={
  frayed_nerves:{aspect:'Gale',flavorReason:'The pressure never let up.'},
  panic_surge:{aspect:'Gale',flavorReason:'Every opening move came from panic.'},
  silent_step:{aspect:'Gale',flavorReason:'You learned to live between strikes.'},
  shallow_breath:{aspect:'Gale',flavorReason:'Breathing became measured and thin.'},
  cold_iron:{aspect:'Steel',flavorReason:'The cold found the gaps.'},
  scarred_plate:{aspect:'Steel',flavorReason:'Armor thickened, movement slowed.'},
  iron_reflex:{aspect:'Steel',flavorReason:'You flinched before the killing blow.'},
  shattered_guard:{aspect:'Steel',flavorReason:'A shield memory remained, cracked but stubborn.'},
  brittle_edge:{aspect:'Execution',flavorReason:'Striking harder was never the answer.'},
  grave_salt:{aspect:'Execution',flavorReason:'Aggression left no room for defense.'},
  death_oath:{aspect:'Execution',flavorReason:'The first cut became a vow.'},
  thin_margin:{aspect:'Execution',flavorReason:'You only trusted the edge of defeat.'},
  bitter_blood:{aspect:'Venom',flavorReason:'Mercy tasted like poison.'},
  eitr_cough:{aspect:'Venom',flavorReason:'Each breath carried eitr.'},
  open_wound:{aspect:'Venom',flavorReason:'Old wounds refused to close.'},
  coin_scar:{aspect:'neutral',flavorReason:'The Order always takes its cut.'},
};

function deriveScarCandidates(){
  const all=[...SCAR_KEYS];
  const aspect=(G&&G.hero&&G.hero.record&&G.hero.record.birthAspect)||'Steel';
  const byAspect=all.filter(k=>(SCAR_DEF[k]?.aspect||'neutral')===aspect);
  const aspectPick=(byAspect.length?rpick(byAspect):rpick(all));

  const es=(G&&Array.isArray(G.enemies))?G.enemies:[];
  const w={}; all.forEach(k=>w[k]=1);
  if(es.some(e=>e.archId==='frost'||e.realmTier==='niflheim')){w.cold_iron+=3;w.scarred_plate+=2;}
  if(es.some(e=>e.archId==='assassin'||e.beh==='burst')){w.iron_reflex+=3;w.thin_margin+=2;}
  if(es.some(e=>e.archId==='shaman'||e.archId==='bombardier')){w.eitr_cough+=2;w.bitter_blood+=2;}
  if(G&&G.waveFlags&&G.waveFlags.toxicAir){w.open_wound+=2;w.bitter_blood+=2;}
  const causePool=all.filter(k=>k!==aspectPick);
  const causePick=rwgt(causePool,k=>w[k]||1);

  const strayPool=all.filter(k=>k!==aspectPick&&k!==causePick);
  const strayPick=strayPool.length?rpick(strayPool):rpick(all);

  return [
    {key:aspectPick,label:'Aspect Memory'},
    {key:causePick,label:'Cause of Death'},
    {key:strayPick,label:'Stray Memory'},
  ];
}

const SCAR_REASON_TEXT={
  frayed_nerves:SCAR_DEF.frayed_nerves.flavorReason,
  panic_surge:SCAR_DEF.panic_surge.flavorReason,
  silent_step:SCAR_DEF.silent_step.flavorReason,
  shallow_breath:SCAR_DEF.shallow_breath.flavorReason,
  cold_iron:SCAR_DEF.cold_iron.flavorReason,
  scarred_plate:SCAR_DEF.scarred_plate.flavorReason,
  iron_reflex:SCAR_DEF.iron_reflex.flavorReason,
  shattered_guard:SCAR_DEF.shattered_guard.flavorReason,
  brittle_edge:SCAR_DEF.brittle_edge.flavorReason,
  grave_salt:SCAR_DEF.grave_salt.flavorReason,
  death_oath:SCAR_DEF.death_oath.flavorReason,
  thin_margin:SCAR_DEF.thin_margin.flavorReason,
  bitter_blood:SCAR_DEF.bitter_blood.flavorReason,
  eitr_cough:SCAR_DEF.eitr_cough.flavorReason,
  open_wound:SCAR_DEF.open_wound.flavorReason,
  coin_scar:SCAR_DEF.coin_scar.flavorReason,
};

function showFallenScarChoice(heroId,salvageEarned){
  const rec=META.family[heroId];
  if(!rec){showStartScreen();return;}
  normalizeMeta();

  const candidates=deriveScarCandidates();
  const html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;
                color:var(--red);margin-bottom:8px">â˜  SAGA CLOSED</div>
    <div style="font-size:13px;color:var(--txt2);margin-bottom:4px">
      ${rec.name} fell at Trial ${rec.runResult?.wave||'?'}.
    </div>
    <div style="font-size:11px;color:var(--txt3);font-style:italic;margin-bottom:16px">
      "The saga passed to the next."
    </div>
    <div style="font-size:12px;font-weight:700;color:var(--txt);margin-bottom:10px">
      What did this saga teach the blood?
    </div>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:16px">
      ${candidates.map((c)=>{const scarKey=c.key;const lbl=c.label;
        const gt=GTRAITS[scarKey];
        return `
          <div class="imprint-card" onclick="acceptScar('${heroId}','${scarKey}')">
            <div style="font-size:9px;color:var(--txt3);letter-spacing:1px;margin-bottom:3px">${lbl}</div>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="font-weight:800;color:#d090ff">${gt?.icon||'ğŸ©¹'} ${gt?.name||scarKey}</div>
              <div style="font-size:9px;color:var(--salvage)">SCAR TOKEN +1</div>
            </div>
            <div style="font-size:10px;color:var(--txt2);margin-top:4px">${gt?.desc||''}</div>
            <div style="font-size:9px;color:var(--txt3);font-style:italic;margin-top:3px">
              ${SCAR_REASON_TEXT[scarKey]||''}
            </div>
          </div>
        `;
      }).join('')}
    </div>
    <div style="font-size:10px;color:var(--txt3);border-top:1px solid var(--border);padding-top:8px">
      áš±${salvageEarned} Rune-Shards recovered. Fallen heroes cannot be bound or bequeath gear.
    </div>
  `;
  showOverlayContent(html);
}

function acceptScar(heroId,scarKey){
  const rec=META.family[heroId];
  if(!rec)return;
  normalizeMeta();
  addScarToken(scarKey,1);
  if(!META.lineageScarPool.includes(scarKey))META.lineageScarPool.push(scarKey);
  try{META.unlockedTraits.add(scarKey);}catch(e){}
  if(rec.runResult)rec.runResult.harvest='scar:'+scarKey;
  META.family[heroId]=rec;
  saveMeta();
  updateMetaHeader();
  hideOverlay();
  try{addLog(`ğŸ©¹ Scar etched: ${GTRAITS[scarKey]?.name||scarKey} â€” the blood remembers.`,'laxiom');}catch(e){}
  showStartScreen();
}

const TAG_RELIC_MAP={
  Bleed:{key:'relic_bleed_mastery',label:'Blood-Rite Mastery',icon:'ğŸ©¸',desc:'When Spliced: child has 90% chance to inherit a Bleed-related trait.'},
  Poison:{key:'relic_eitr_touch',label:'Eitr-Touch',icon:'â˜ ',desc:'When Spliced: child has 90% chance to inherit a Poison-related trait.'},
  Crit:{key:'relic_keen_eye',label:'Keen-Eye Technique',icon:'ğŸ¯',desc:'When Spliced: child inherits +5 bonus Crit EV.'},
  Tempo:{key:'relic_stormswift',label:'Stormswift Legacy',icon:'âš¡',desc:'When Spliced: child inherits +5 bonus SPD EV.'},
  Bulwark:{key:'relic_ironwall',label:'Iron-Wall Lineage',icon:'ğŸ›¡',desc:'When Spliced: child inherits +5 bonus DEF EV.'},
  Axiom:{key:'relic_rune_law',label:'Rune Law Fragment',icon:'áš¢',desc:'When Spliced: child has 70% chance to start with an Axiom boon in the first draft.'},
  Execute:{key:'relic_wolf_oath',label:'Wolf-Oath',icon:'ğŸº',desc:'When Spliced: child has 90% chance to inherit an Execute-related trait.'},
  Sustain:{key:'relic_lifeline',label:'Life-Root Binding',icon:'ğŸ’š',desc:'When Spliced: child inherits +5 bonus HP EV.'},
};

function deriveRelicCandidates(rec){
  const tagCounts={};
  (rec.runResult?.boons||[]).forEach(boonId=>{
    const boon=BOONS.find(b=>b.id===boonId);
    if(boon)boon.tags.forEach(t=>{tagCounts[t]=(tagCounts[t]||0)+1;});
  });
  const topTags=Object.entries(tagCounts).sort((a,b)=>b[1]-a[1]).slice(0,3).map(([tag])=>tag);
  const results=topTags.map(tag=>TAG_RELIC_MAP[tag]).filter(Boolean);
  const allOptions=Object.values(TAG_RELIC_MAP);
  while(results.length<3){
    const fallback=allOptions.find(r=>!results.some(x=>x.key===r.key));
    if(fallback)results.push(fallback);else break;
  }
  return results.slice(0,3);
}

function showRetireRelicChoice(rec,essence){
  const candidates=deriveRelicCandidates(rec);
  const html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;
                color:var(--gold);margin-bottom:8px">ğŸ› MEMORY BOUND</div>
    <div style="font-size:13px;color:var(--txt2);margin-bottom:4px">
      ${rec.name} â€” Trial ${rec.runResult?.wave||'?'} Â· Lv.${rec.runResult?.level||1}
    </div>
    <div style="font-size:11px;color:var(--txt3);font-style:italic;margin-bottom:16px">
      "Let the blood carry the rest."
    </div>
    <div style="font-size:12px;font-weight:700;color:var(--txt);margin-bottom:10px">
      What does this saga leave behind?
    </div>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:14px">
      ${candidates.map(r=>`
        <div class="imprint-card" style="border-color:rgba(212,160,23,.4)" onclick="acceptRelic('${rec.id}','${r.key}')">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:800;color:var(--gold)">${r.icon} ${r.label}</div>
            <div style="font-size:9px;color:var(--amber)">RELIC +1</div>
          </div>
          <div style="font-size:10px;color:var(--txt2);margin-top:4px">${r.desc}</div>
          <div style="font-size:9px;color:var(--txt3);font-style:italic;margin-top:3px">Usable in Splice during memory binding to lock this mastery into a child.</div>
        </div>
      `).join('')}
    </div>
    <div style="font-size:10px;color:var(--green)">+${essence} Minni Â· This memory stone can be used in binding.</div>
  `;
  showOverlayContent(html);
}

function showBequeathChoice(rec,essence){
  if(!G||!G.hero||!G.hero.gear){proceedAfterBequeath(rec,essence);return;}
  const gearSlots=Object.entries(G.hero.gear).filter(([slot,item])=>item!==null);
  if(!gearSlots.length){proceedAfterBequeath(rec,essence);return;}
  const html=`
    <div style="font-family:'Orbitron',sans-serif;font-size:16px;font-weight:900;color:var(--gold);margin-bottom:8px">âš’ WHAT REMAINS</div>
    <div style="font-size:11px;color:var(--txt2);margin-bottom:14px">Choose one item to pass into your Minni lattice. It will be available to the next thread bound from ${rec.name}.</div>
    <div style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px">
      ${gearSlots.map(([slot,item])=>{
        const waveBonus=Math.min(3,Math.floor((rec.runResult?.wave||1)/6));
        const primaryStatLabel={weapon:'ATK',armor:'DEF',talisman:'EVA'}[slot]||slot;
        return `<div class="imprint-card" style="border-color:${rarityBorderColor(item.rarity)}" onclick="bequeathGear('${rec.id}','${slot}',${waveBonus})">
          <div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:800;color:${rarityColor(item.rarity)}">${item.name}</div><div style="font-size:9px;color:var(--txt3)">${item.rarity.toUpperCase()}</div></div>
          <div style="font-size:10px;color:var(--txt2);margin-top:3px">${(item.affixes||[]).map(a=>a.label).join(' Â· ')||'No affixes'}</div>
          ${item.sagaHistory?.length?`<div style="font-size:9px;color:var(--txt3);font-style:italic;margin-top:3px">"${item.sagaHistory[item.sagaHistory.length-1]}"</div>`:''}
          ${item.notches>0?`<div style="font-size:9px;color:var(--amber);margin-top:2px">${item.notches} Notch${item.notches>1?'es':''}${item.sundered?' â€” SUNDERED':''}</div>`:''}
          ${waveBonus>0?`<div style="font-size:9px;color:var(--green);margin-top:2px">Legacy bonus: +${waveBonus} ${primaryStatLabel} for the next wielder</div>`:''}
        </div>`;
      }).join('')}
    </div>
    <button class="btn btn-sm btn-ghost" style="width:100%" onclick="skipBequeath('${rec.id}',${essence})">Bequeath nothing â€” carry on</button>
  `;
  showOverlayContent(html);
}
function gearSlotPrimaryStat(slot){return {weapon:'atk',armor:'def',talisman:'evasion'}[slot]||'atk';}
function bequeathGear(heroId,slot,waveBonus){
  const rec=META.family[heroId];
  const item=(G&&G.hero&&G.hero.gear)?G.hero.gear[slot]:null;
  if(!rec||!item){proceedAfterBequeath(rec,META.legacyEssence);return;}
  item.sagaHistory=item.sagaHistory||[];
  if(item.sagaHistory.length>=3)item.sagaHistory.shift();
  item.sagaHistory.push(`Last wielded by ${rec.name}, Trial ${rec.runResult?.wave||'?'}`);
  const primaryStat=gearSlotPrimaryStat(slot);
  if(waveBonus>0)item.passiveBonus={stat:primaryStat,value:waveBonus,label:`+${waveBonus} legacy (${rec.name})`};
  item.forgedBy=heroId; item.forgedByName=rec.name;
  rec.equippedGear=rec.equippedGear||{};
  rec.equippedGear[slot]=JSON.parse(JSON.stringify(item));
  META.family[heroId]=rec;
  saveMeta();
  hideOverlay();
  addLog(`âš’ ${item.name} bequeathed. It will find the next worthy hand.`,'laxiom');
  proceedAfterBequeath(rec,META.legacyEssence);
}
function skipBequeath(heroId,essence){hideOverlay();proceedAfterBequeath(META.family[heroId],essence);}
function proceedAfterBequeath(rec,essence){
  const axiomBoons=G?G.boons.filter(b=>b.rarity==='axiom'):[];
  if(axiomBoons.length>0)showImprintOffer(rec,axiomBoons,essence);
  else showRetireSummary(rec,essence,null);
}

function acceptRelic(heroId,relicKey){
  const rec=META.family[heroId];
  if(!rec)return;
  normalizeMeta();
  META.relics+=1;
  rec.relicType=relicKey;
  if(rec.runResult)rec.runResult.harvest='relic:'+relicKey;
  META.family[heroId]=rec;
  saveMeta();
  updateMetaHeader();
  hideOverlay();
  try{addLog(`ğŸ—¿ Relic forged: ${relicKey} â€” the mastery endures.`,'laxiom');}catch(e){}
  showBequeathChoice(rec,META.legacyEssence);
}

// --- Memory Binding actions state ---
let BREED_ACTION = {mode:'none', spliceKind:'relic', traitKey:null, scarKey:null};
function resetBreedAction(){ BREED_ACTION = {mode:'none', spliceKind:'relic', traitKey:null, scarKey:null}; }

function stabilizeCost(){
  const c = 15 - getAspectRank('Steel')*2;
  return Math.max(6, c|0);
}
function catalyzeCost(){
  const c = 15 - getAspectRank('Gale')*2;
  return Math.max(6, c|0);
}
function setBreedAction(mode){
  if(mode===BREED_ACTION.mode){ resetBreedAction(); }
  else{
    BREED_ACTION.mode = mode;
    if(mode!=='splice'){ BREED_ACTION.spliceKind='relic'; BREED_ACTION.traitKey=null; BREED_ACTION.scarKey=null; }
  }
  setLegacyTab('breed');
}
function setSpliceKind(kind){
  BREED_ACTION.spliceKind = kind;
  BREED_ACTION.traitKey = null;
  BREED_ACTION.scarKey = null;
  setLegacyTab('breed');
}
function setSpliceTrait(tk){
  BREED_ACTION.traitKey = tk;
  setLegacyTab('breed');
}
function setSpliceScar(sk){
  BREED_ACTION.scarKey = sk;
  setLegacyTab('breed');
}

function breedingActionsHTML(){
  normalizeMeta();
  const mode = BREED_ACTION.mode;
  const hasEss = (META.legacyEssence||0) >= stabilizeCost();
  const hasSal = (META.salvage||0) >= catalyzeCost();
  const hasRel = (META.relics||0) > 0;
  const scars = Object.keys(META.scarTokens||{}).filter(k=>scarTokenCount(k)>0);

  const btn = (lbl, m, ok, extra) => `
    <button class="btn btn-sm ba-btn ${mode===m?'active':''} ${ok?'':'disabled'}" onclick="${ok?`setBreedAction('${m}')`:`alert('Not enough resources.')`}">
      ${lbl} ${extra||''}
    </button>
  `;

  let html = `
    <div style="margin:10px 0 16px">
      <div class="sec-title">Memory Binding Actions</div>
      <div class="breed-actions">
        ${btn(`ğŸ§Š Stabilize <span style="color:var(--gold);font-family:'Share Tech Mono',monospace">á›‹${stabilizeCost()}</span>`, 'stabilize', hasEss)}
        ${btn(`âš¡ Catalyze <span style="color:var(--salvage);font-family:'Share Tech Mono',monospace">áš±${catalyzeCost()}</span>`, 'catalyze', hasSal)}
        ${btn(`ğŸ§¬ Splice <span style="color:var(--amber);font-family:'Share Tech Mono',monospace">${(hasRel?`ğŸ—¿${META.relics}`:'')}${(scars.length?` Â· ğŸ©¹${totalScarTokens()}`:'')}</span>`, 'splice', (hasRel||scars.length>0))}
      </div>
  `;

  if(mode==='stabilize'){
    html += `<div class="breed-subpanel">
      <div style="font-weight:800;color:var(--gold);margin-bottom:4px">Stabilize</div>
      <div style="font-size:11px;color:var(--txt2)">Lower EV variance, higher inheritance reliability, lower mutation chance.</div>
    </div>`;
  }else if(mode==='catalyze'){
    html += `<div class="breed-subpanel">
      <div style="font-weight:800;color:var(--salvage);margin-bottom:4px">Catalyze</div>
      <div style="font-size:11px;color:var(--txt2)">Higher EV variance and mutation chance. More likely to produce an unexpected thread.</div>
    </div>`;
  }else if(mode==='splice'){
    const a = BREED_SELECTED[0], b = BREED_SELECTED[1];
    const recA = META.family[a], recB = META.family[b];
    const parentTraits = [...new Set([...(recA?.traits||[]), ...(recB?.traits||[])])];
    html += `<div class="breed-subpanel">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <div style="font-weight:900;color:#d090ff">Splice</div>
        <div style="font-size:10px;color:var(--txt3)">Choose a Relic-lock or implant a Scar.</div>
      </div>
      <div style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:8px">
        ${hasRel?`<span class="choice-pill ${BREED_ACTION.spliceKind==='relic'?'active':''}" onclick="setSpliceKind('relic')">ğŸ—¿ Relic Lock</span>`:''}
        ${scars.length?`<span class="choice-pill ${BREED_ACTION.spliceKind==='scar'?'active':''}" onclick="setSpliceKind('scar')">ğŸ©¹ Scar Implant</span>`:''}
      </div>
    `;

    if(BREED_ACTION.spliceKind==='relic'){
      html += `<div style="font-size:11px;color:var(--txt2);margin-bottom:6px">Consume <strong>1 Relic</strong> to lock a strand pattern into the new thread (high chance).</div>
      <div style="display:flex;flex-wrap:wrap;gap:6px">`;
      if(!hasRel) html += `<div style="color:var(--txt3);font-size:11px">No Relics available.</div>`;
      else if(!parentTraits.length) html += `<div style="color:var(--txt3);font-size:11px">Primary Strand & Secondary Strand have no traits to lock.</div>`;
      else{
        html += parentTraits.map(tk=>{
          const gt = GTRAITS[tk];
          const on = (BREED_ACTION.traitKey===tk);
          return `<span class="choice-pill ${on?'active':''}" onclick="setSpliceTrait('${tk}')">${gt?gt.icon:''} ${gt?gt.name:tk}</span>`;
        }).join('');
      }
      html += `</div>`;
    }else{
      html += `<div style="font-size:11px;color:var(--txt2);margin-bottom:6px">Consume <strong>1 Scar Token</strong> to implant that scar into the child (guaranteed).</div>
      <div style="display:flex;flex-wrap:wrap;gap:6px">`;
      if(!scars.length) html += `<div style="color:var(--txt3);font-size:11px">No scar tokens available.</div>`;
      else{
        html += scars.map(sk=>{
          const gt = GTRAITS[sk];
          const on = (BREED_ACTION.scarKey===sk);
          return `<span class="choice-pill ${on?'active':''}" onclick="setSpliceScar('${sk}')">${gt?gt.icon:''} ${gt?gt.name:sk} Ã—${scarTokenCount(sk)}</span>`;
        }).join('');
      }
      html += `</div>`;
    }

    html += `</div>`;
  }

  html += `</div>`;
  return html;
}

// --- Trait inheritance bonus by aspect rank ---
function traitInheritBonus(tk){
  const a = TRAIT_ASPECT[tk];
  if(!a) return 0;
  return getAspectRank(a) * 0.03; // up to +9%
}

// Override breedHeroes to accept memory binding action options + naming flags
function breedHeroes(idA, idB, opts){
  const recA = META.family[idA], recB = META.family[idB];
  if(!recA || !recB) return null;
  normalizeMeta();

  const action = (opts && opts.mode) ? opts.mode : 'none';
  const spliceKind = opts ? opts.spliceKind : null;

  META.bindingCounter = Math.max(0, Math.floor((META.bindingCounter||0)+1));
  const rngSeed = `${META.houseName||'House'}|${META.bindingCounter}|${idA}|${idB}|${action}|${spliceKind||''}|${opts?.traitKey||''}|${opts?.scarKey||''}`;
  const LR = mkLocalRng(rngSeed);

  let VAR = 5;
  let mutMult = 1.0;
  let inheritAdd = 0.0;
  let mutBoostChance = 0.08;

  if(action==='stabilize'){ VAR = 2; mutMult = 0.55; inheritAdd = 0.10; mutBoostChance = 0.06; }
  else if(action==='catalyze'){ VAR = 8; mutMult = 1.75; inheritAdd = -0.05; mutBoostChance = 0.18; }

  const cap = evCap();
  const childGen = Math.max(recA.gen||0, recB.gen||0) + 1;
  const accelPct = Math.max(0, Math.min(0.18, 0.02 * Math.min(childGen, 8)));
  const childEVs = {};
  EV_KEYS.forEach(k=>{
    let val = Math.round(((recA.evs[k]||0)+(recB.evs[k]||0))/2 + LR.lri(-VAR, VAR));
    if(LR.lrng() < mutBoostChance) val += LR.lri(5, 12);
    val = Math.round(val + (cap - val) * accelPct);
    childEVs[k] = Math.min(cap, Math.max(0, val));
  });

  const allParentTraits = [...new Set([...(recA.traits||[]), ...(recB.traits||[])])];
  const sharedTraits = (recA.traits||[]).filter(t=> (recB.traits||[]).includes(t));
  const childTraits = [];
  for(const t of allParentTraits){
    const baseChance = (sharedTraits.includes(t) ? 0.75 : 0.45) + inheritAdd + traitInheritBonus(t);
    if(LR.lrng() < Math.min(0.95, Math.max(0.05, baseChance))) childTraits.push(t);
  }

  let mutated = false;
  if(LR.lrng() < (mutationRate() * mutMult)){
    const unlocked = [...META.unlockedTraits];
    const available = unlocked.filter(t=>!childTraits.includes(t));
    if(available.length){
      const mut = LR.lrpick(available);
      childTraits.push(mut);
      mutated = true;
      try{ addLog(`ğŸ§¬ MUTATION! New trait emerged: ${GTRAITS[mut]?.name||mut}!`,'laxiom'); }catch(e){}
    }
  }

  let spliceRelic = false, spliceScar = false;
  if(action==='splice' && opts){
    if(spliceKind==='relic' && opts.traitKey){
      spliceRelic = true;
      const t = opts.traitKey;
      if(allParentTraits.includes(t) && LR.lrng() < 0.90 && !childTraits.includes(t)) childTraits.push(t);
      if(allParentTraits.includes(t) && LR.lrng() < 0.25 && !childTraits.includes(t)) childTraits.push(t);
    }else if(spliceKind==='scar' && opts.scarKey){
      spliceScar = true;
      const sk = opts.scarKey;
      if(!childTraits.includes(sk)) childTraits.push(sk);
      if(!META.lineageScarPool.includes(sk))META.lineageScarPool.push(sk);
    }
  }

  const maxTraits = TRAIT_MAX_BASE;
  let finalTraits = [...new Set(childTraits)];
  if(finalTraits.length > maxTraits){
    const keep = [];
    if(spliceScar && opts && opts.scarKey) keep.push(opts.scarKey);
    if(spliceRelic && opts && opts.traitKey) keep.push(opts.traitKey);
    const out = [];
    for(const k of keep){ if(k && finalTraits.includes(k) && !out.includes(k)) out.push(k); }
    for(const k of finalTraits){ if(out.length>=maxTraits) break; if(!out.includes(k)) out.push(k); }
    finalTraits = out.slice(0, maxTraits);
  }else{
    finalTraits = finalTraits.slice(0, maxTraits);
  }

  if(action==='splice'&&opts&&opts.spliceKind==='relic'&&opts.traitKey){
    const relicEVBonus={
      relic_keen_eye:{ev:'crit',bonus:5},
      relic_stormswift:{ev:'spd',bonus:5},
      relic_ironwall:{ev:'def',bonus:5},
      relic_lifeline:{ev:'hp',bonus:5},
    };
    const relicBonus=relicEVBonus[opts.traitKey];
    if(relicBonus){
      childEVs[relicBonus.ev]=Math.min(cap,(childEVs[relicBonus.ev]||0)+relicBonus.bonus);
    }
  }

  const topEvK = EV_KEYS.reduce((a,b)=> (childEVs[a]||0) > (childEVs[b]||0) ? a : b);
  const evAspectMap = {hp:'Steel',def:'Steel',ls:'Venom',atk:'Execution',crit:'Execution',spd:'Gale',eva:'Gale',acc:'Execution'};
  let birthAspect = evAspectMap[topEvK] || 'Steel';
  if(finalTraits.some(t=>TRAIT_ASPECT[t]==='Axiom')) birthAspect = 'Axiom';

  const genNum = childGen;
  const childName = genName(genNum, birthAspect, [recA.name, recB.name], {mutated, spliceRelic, spliceScar});
  const childRec = mkHeroRecord(childName, genNum, [recA.id, recB.id], childEVs, finalTraits);
  childRec.birthAspect = birthAspect;
  childRec.birthFlags = {catalyzed: action==='catalyze', mutated, spliceRelic, spliceScar};
  childRec.evAccelPct = accelPct;

  META.family[childRec.id] = childRec;
  saveMeta();
  return childRec;
}

// Override doBreed to apply costs + splice inventory
(function(){
  const _doBreed = doBreed;
  doBreed = function(){
    if(BREED_SELECTED.length<2){alert('Select 2 heroes first.');return;}
    normalizeMeta();
    const a = BREED_SELECTED[0], b = BREED_SELECTED[1];
    const ua = getBreedUses(META.family[a]), ub = getBreedUses(META.family[b]);
    if(ua.left<=0||ub.left<=0){alert('One of the selected strands has no memory binding uses left.');return;}

    const mode = BREED_ACTION.mode;
    const opts = {mode:'none'};

    // Pay costs / consume inventory
    if(mode==='stabilize'){
      const c = stabilizeCost();
      if((META.legacyEssence||0) < c){ alert("Not enough Minni for Stabilize."); return; }
      META.legacyEssence -= c;
      opts.mode = 'stabilize';
    }else if(mode==='catalyze'){
      const c = catalyzeCost();
      if((META.salvage||0) < c){ alert('Not enough Rune-Shards for Catalyze.'); return; }
      META.salvage -= c;
      opts.mode = 'catalyze';
    }else if(mode==='splice'){
      opts.mode = 'splice';
      opts.spliceKind = BREED_ACTION.spliceKind;
      if(BREED_ACTION.spliceKind==='relic'){
        if((META.relics||0) <= 0){ alert('No Relics available.'); return; }
        if(!BREED_ACTION.traitKey){ alert('Choose a strand pattern to lock.'); return; }
        META.relics -= 1;
        opts.traitKey = BREED_ACTION.traitKey;
      }else{
        if(!BREED_ACTION.scarKey){ alert('Choose a scar token to implant.'); return; }
        if(scarTokenCount(BREED_ACTION.scarKey) <= 0){ alert('That scar token is not available.'); return; }
        addScarToken(BREED_ACTION.scarKey, -1);
        opts.scarKey = BREED_ACTION.scarKey;
      }
    }

    const childRec = breedHeroes(a, b, opts);
    if(!childRec) return;

    const bestParentId=[a,b].reduce((best,pid)=>{
      const p=META.family[pid], bRec=META.family[best];
      const pWave=(p?.runResult?.wave||0), bWave=(bRec?.runResult?.wave||0);
      const pF=isFallenHero(pid), bF=isFallenHero(best);
      if(bF&&!pF)return pid;
      if(!bF&&pF)return best;
      return pWave>=bWave?pid:best;
    },a);
    inheritGearFromParent(childRec.id,bestParentId);

    consumeBreedUse(a);
    consumeBreedUse(b);
    saveMeta();
    BREED_SELECTED = [];
    resetBreedAction();

    const lc=document.getElementById('legacy-content');
    const derived=evDerived(childRec.evs);
    lc.innerHTML=`<div class="slide-in" style="text-align:center;padding:30px">
      <div style="font-size:11px;color:var(--violet);font-style:italic;
              letter-spacing:1px;margin-bottom:8px">You tighten the weave.</div>
      <div style="font-size:22px;margin-bottom:8px">ğŸ§¬</div>
      <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;color:var(--violet);margin-bottom:6px">${childRec.name}</div>
      <div style="color:var(--txt3);font-size:12px;margin-bottom:18px">Generation ${childRec.gen} Â· ${ASPECT_ICON[childRec.birthAspect]||'âœ¦'} ${childRec.birthAspect} lineage</div>
      <div style="display:inline-block;background:var(--bg2);border:1px solid var(--border2);border-radius:6px;padding:14px 20px;margin-bottom:18px;text-align:left;min-width:240px">
        <div style="font-size:10px;color:var(--txt3);letter-spacing:2px;margin-bottom:8px">SCARS / PATTERN</div>
        ${[['MaxHP',derived.maxHP],['ATK',Math.round(derived.atk)],['DEF',Math.round(derived.def)],['SPD',derived.spd],['Crit',Math.round(derived.critChance*100)+'%']].map(([l,v])=>`<div class="srow"><span class="sl" style="font-size:12px">${l}</span><span class="sv" style="font-size:12px;color:var(--green)">${v}</span></div>`).join('')}
        ${childRec.traits.length?`<div style="margin-top:10px;border-top:1px solid var(--border);padding-top:8px;display:flex;flex-wrap:wrap;gap:3px">${childRec.traits.map(tk=>{const gt=GTRAITS[tk];return gt?`<span class="gtrait">${gt.icon} ${gt.name}</span>`:''}).join('')}</div>`:`<div style="margin-top:8px;color:var(--txt3);font-size:10px">No pattern traits inherited.</div>`}
        ${childRec.inheritedGear&&Object.values(childRec.inheritedGear).some(Boolean)?`<div style="margin-top:8px;border-top:1px solid var(--border);padding-top:8px;text-align:left"><div style="font-size:9px;color:var(--txt3);letter-spacing:2px;margin-bottom:4px">INHERITED GEAR</div>${Object.values(childRec.inheritedGear).filter(Boolean).map(item=>`<div style="font-size:10px;color:${rarityColor(item.rarity)};margin:2px 0">âš’ ${item.name}${item.passiveBonus?`<span style="color:var(--green)"> Â· ${item.passiveBonus.label}</span>`:''}</div>`).join('')}</div>`:''}
      </div>
      <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
        <button class="btn btn-primary" onclick="hideLegacy();startWithChild('${childRec.id}')">You choose the next thread â€” Continue as ${childRec.name}</button>
        <button class="btn btn-sm" style="background:var(--bg2);border:1px solid var(--border2);color:var(--txt3)" onclick="setLegacyTab('pool')">â† Back</button>
      </div>
    </div>`;
  };
})();

// Inject memory binding actions UI into Memory Binding tab (wrap renderBreeding)
(function(){
  const _renderBreeding = renderBreeding;
  renderBreeding = function(){
    const base = _renderBreeding();
    if(BREED_SELECTED.length<2) return base;
    // Insert after the "Memory Binding Chamber" title
    const needle = `âš— Memory Binding Chamber</div>`;
    if(base.includes(needle)){
      return base.replace(needle, needle + breedingActionsHTML());
    }
    // fallback: prepend
    return breedingActionsHTML() + base;
  };
})();

// --- Runesmith tab: show Generations + Aspects + inventory ---
function aspectsHTML(){
  normalizeMeta();
  const rows = ASPECTS.map(a=>{
    const st = getAspectState(a);
    const next = aspectNextThreshold(st.rank);
    const prev = ASPECT_THRESH[st.rank] || 0;
    const pct = (st.rank>=3) ? 100 : Math.max(0, Math.min(100, ((st.xp - prev) / Math.max(1, (next - prev))) * 100));
    return `<div class="aspect-row">
      <div style="width:86px;font-size:11px;font-weight:800;color:${ASPECT_COLOR[a]||'#aaa'}">${ASPECT_ICON[a]||'âœ¦'} ${a}</div>
      <div class="aspect-bar"><div class="aspect-fill" style="width:${pct}%;background:${ASPECT_COLOR[a]||'#777'}"></div></div>
      <div style="width:80px;text-align:right;font-family:'Share Tech Mono',monospace;font-size:10px;color:var(--txt3)">R${st.rank} Â· ${st.xp}${st.rank>=3?'':' / '+next}</div>
    </div>`;
  }).join('');
  return `<div style="background:rgba(20,18,40,.55);border:1px solid var(--border2);border-radius:8px;padding:12px;margin-bottom:14px">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div style="font-weight:900;color:var(--gold)">á›Ÿ House ${META.houseName}</div>
      <div style="font-size:10px;color:var(--txt3)">Relics: ğŸ—¿${META.relics} Â· Scar Tokens: ğŸ©¹${totalScarTokens()}</div>
    </div>
    <div style="font-size:10px;color:var(--txt3);margin-top:4px">
      RagnarÃ¶k: ${rootDepthIcon(META.ragnarÃ¶kTier)} Tier ${META.ragnarÃ¶kTier || 0} unlocked
      ${META.ragnarÃ¶kTier > 0 ? `Â· "${rootDepthLabel(META.ragnarÃ¶kTier)}"` : 'Â· No tier unlocked yet'}
    </div>
    <div style="font-size:10px;color:var(--txt3);margin-bottom:8px">Rename House:</div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px">
      <input id="house-name-input" value="${(META.houseName||'')}" style="flex:1;min-width:180px;background:var(--bg2);border:1px solid var(--border2);color:var(--txt);padding:8px 10px;border-radius:6px;font-size:12px;font-family:'Share Tech Mono',monospace;outline:none">
      <button class="btn btn-sm btn-amber" onclick="setHouseNameFromInput()">Save</button>
    </div>
    <div class="sec-title" style="margin-top:0">Lineage Aspects</div>
    ${rows}
    <div style="margin-top:10px;border-top:1px solid var(--border);padding-top:8px">
      <div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:4px">Aspect Blessings (Always Active)</div>
      <div style="font-size:10px;color:var(--txt3);line-height:1.5">
        ğŸ›¡ Steel: +3% Max HP / rank, +2 DEF / rank<br>
        ğŸŒª Gale: +2 SPD / rank, +2% Evasion / rank<br>
        ğŸ Venom: +0.75% Lifesteal / rank, -7% Bleed/Poison tick damage taken / rank<br>
        ğŸº Execution: +2% Crit Chance / rank, +8% Crit Damage / rank<br>
        áš± Axiom: +2% Accuracy / rank, +4% Crit Damage / rank
      </div>
      <div style="font-size:10px;color:var(--txt2);margin-top:6px"><strong>Current Blessings:</strong> ${formatHouseBlessingsSummary(computeHouseBlessings())}</div>
    </div>
    <div style="font-size:10px;color:var(--txt3);margin-top:8px">Earn Aspect XP by retiring or winning. Each family develops a distinct identity over generations. (Venom aspect lore: Venom (Eitr))</div>
  </div>`;
}
function setHouseNameFromInput(){
  const el = document.getElementById('house-name-input');
  if(!el) return;
  const v = (el.value||'').trim().replace(/[^A-Za-z0-9_-]/g,'').slice(0,18);
  if(!v){ alert('Family name cannot be empty.'); return; }
  normalizeMeta();
  META.houseName = v;
  saveMeta();
  setLegacyTab('upgrades');
}

(function(){
  const _renderRunesmith = renderRunesmith;
  renderRunesmith = function(){
    const base = _renderRunesmith();
    // Insert our house/aspects panel at the top of the tab
    const needle = `<div style="font-size:16px;font-weight:700;color:var(--gold);margin-bottom:4px">Legacy Runesmith</div>`;
    if(base.includes(needle)){
      return base.replace(needle, aspectsHTML() + needle);
    }
    return aspectsHTML() + base;
  };
})();


function rootDepthIcon(tier){
  // Returns a colored áš¢ rune representing RagnarÃ¶k depth
  const t=Math.max(0,Math.min(15,tier||0));
  let color;
  if(t===0) color='var(--txt3)';
  else if(t<=3) color='#c8cce8';
  else if(t<=7) color='var(--amber)';
  else if(t<=11) color='#c07810';
  else color='#8a1010';
  const glow=t>=12?';text-shadow:0 0 6px rgba(180,20,20,.5)':'';
  return `<span style="color:${color}${glow};font-size:14px">áš¢</span>`;
}

function rootDepthLabel(tier){
  if(!tier||tier===0) return '';
  const TIER_NAMES=[
    '',
    'Fimbulwinter Begins','Fimbulwinter Deepens','Third Winter / Fenrirâ€™s Chain Weakens',
    'Fenrir Breaks Free','JÃ¶rmungandr Rises','Naglfar Sets Sail',
    'Loki Breaks Free','Surtr Marches / BifrÃ¶st Shatters','Gods Summon the Einherjar',
    'VÃ­grÃ­Ã°r: Plain of Battle','The Gods Fall','Surtr Burns the Nine Realms',
    'NÃ­Ã°hÃ¶ggr Ascends','The Binding','The Rune of What May Be'
  ];
  return TIER_NAMES[tier]||`Tier ${tier}`;
}

function updateRootDepthHeader(){
  const el=document.getElementById('hdr-root-depth');
  if(!el)return;
  const tier=META.ragnarÃ¶kActive||0;
  if(tier===0){el.innerHTML='';el.title='';return;}
  const tierDef=(typeof RAGNARÃ–K_TIERS!=='undefined')?RAGNARÃ–K_TIERS[tier-1]:null;
  const tierName=rootDepthLabel(tier);
  const omen=tierDef?.omen||'';
  el.innerHTML=`${rootDepthIcon(tier)} <span style="font-family:'Share Tech Mono',monospace;font-size:10px">R${tier}</span>`;
  el.title=`${tierName}
"${omen}"`;
  el.style.cursor='help';
}

function showOpeningNarrative(){
  // Mark as seen immediately so a crash during the overlay doesn't re-show it
  META.hasSeenOpening=true;
  saveMeta();

  const lines=[
    'UrÃ°r, VerÃ°andi, and Skuld keep a fixed tapestry: what was, what is, what must be.',
    'I am the unnamed Fourth Norn â€” dvergar smith, rune-carver, and weaver of what may be. Unsanctioned. Uninvited. Still working.',
    "I do not own fate. I temper Minni, bind memory to memory, and test alternate branches inside each generation's twelve Trials.",
    "At the deepest root, Skuld stands as Debt: future as iron constraint. Reach RagnarÃ¶k Tier 15, hold NÃ­Ã°hÃ¶ggr, and carve the Rune of What May Be into the world's source code.",
  ];

  const lineHTML=lines.map((l,i)=>`
    <p style="
      color:${i===3?'var(--txt)':'var(--txt2)'};
      font-size:${i===3?'13px':'12px'};
      line-height:1.8;
      margin-bottom:${i===3?'0':'14px'};
      font-weight:${i===3?'700':'400'};
      opacity:0;
      animation: fadeInLine .6s ease forwards;
      animation-delay:${(i+1)*1.1}s;
    ">${l}</p>
  `).join('');

  const html=`
    <div style="text-align:center;padding:8px 0 20px">
      <div style="
        font-size:28px;
        color:var(--txt3);
        margin-bottom:28px;
        opacity:0;
        animation: fadeInLine 1.2s ease forwards;
        animation-delay:.2s;
      ">áš¢</div>
      <div style="text-align:left;margin-bottom:28px">
        ${lineHTML}
      </div>
      <button id="opening-begin-btn" class="btn btn-primary" disabled style="
        opacity:0;
        animation: fadeInLine .6s ease forwards;
        animation-delay:${(lines.length+1)*1.1}s;
        padding:10px 32px;
        font-size:14px;
      " onclick="hideOverlay();showStartScreen()">Begin</button>
    </div>
  `;

  if(!document.getElementById('narrative-style')){
    const style=document.createElement('style');
    style.id='narrative-style';
    style.textContent=`@keyframes fadeInLine { from{opacity:0;transform:translateY(4px)} to{opacity:1;transform:none} }`;
    document.head.appendChild(style);
  }

  showOverlayContent(html);
  const enableAfter=((lines.length+1)*1.1+0.65)*1000;
  setTimeout(()=>{
    const btn=document.getElementById('opening-begin-btn');
    if(btn) btn.disabled=false;
  },enableAfter);
}

// --- Show house on start screen (override) ---
function showStartScreen(){
  normalizeMeta();

  // Gate: show opening narrative on first ever launch
  if(!META.hasSeenOpening){
    showOpeningNarrative();
    return;
  }

  closeDrawers();

  const hasRetired=META.retiredPool&&META.retiredPool.length>0;
  const retiredCount=META.retiredPool?META.retiredPool.length:0;
  const fallenCount=META.fallenLedger?META.fallenLedger.length:0;
  const activeTier=META.ragnarÃ¶kActive||0;
  const maxTier=META.ragnarÃ¶kTier||0;
  const tierName=rootDepthLabel(activeTier);
  const tierOmen=(typeof RAGNARÃ–K_TIERS!=='undefined'&&activeTier>0)
    ? ((RAGNARÃ–K_TIERS[activeTier-1]&&RAGNARÃ–K_TIERS[activeTier-1].omen)||'') : '';

  let html=`
    <div style="text-align:center;margin-bottom:4px">
      <div style="font-family:'Orbitron',sans-serif;font-size:20px;font-weight:900;
                  color:var(--violet);text-shadow:0 0 20px rgba(144,80,232,.6)">áš  RUNESAGA</div>
    </div>

    <div style="background:rgba(212,160,23,.06);border:1px solid rgba(212,160,23,.2);
                border-radius:6px;padding:10px 14px;margin:10px 0 14px;text-align:left">
      <div style="font-family:'Orbitron',sans-serif;font-size:13px;font-weight:900;
                  color:var(--gold);letter-spacing:1px">á›Ÿ House ${META.houseName}</div>
      <div style="font-size:10px;color:var(--txt3);margin-top:4px;font-family:'Share Tech Mono',monospace">
        ${fallenCount} saga${fallenCount!==1?'s':''} closed Â· ${retiredCount} thread${retiredCount!==1?'s':''} endure
      </div>
      ${activeTier>0?`
        <div style="margin-top:6px;display:flex;align-items:center;gap:6px">
          ${rootDepthIcon(activeTier)}
          <span style="font-size:11px;font-weight:700;color:var(--amber)">${tierName}</span>
        </div>
        ${tierOmen?`<div style="font-size:10px;color:var(--txt3);font-style:italic;margin-top:3px">"${tierOmen}"</div>`:''}
      `:`
        <div style="font-size:10px;color:var(--txt3);margin-top:4px;font-style:italic">
          The root is uncharted. No depth selected.
        </div>
      `}
    </div>
  `;

  if(hasRetired){
    html+=`
      <div style="background:rgba(64,224,120,.06);border:1px solid rgba(64,224,120,.2);
                  border-radius:5px;padding:8px 12px;margin-bottom:12px;font-size:11px;color:var(--txt2)">
        ğŸ› ${retiredCount} hero${retiredCount!==1?'es':''} await in Minni-HÃ¶ll. The lattice grows stronger.
      </div>
    `;
  }

  if(maxTier>0){
    html+=`
      <div style="margin-bottom:14px">
        <div style="font-size:10px;color:var(--txt3);letter-spacing:1px;text-transform:uppercase;
                    margin-bottom:6px">RagnarÃ¶k Decay â€” Choose world depth</div>
        <div style="display:flex;align-items:center;gap:10px">
          <button class="btn btn-sm btn-ghost" onclick="adjustRagnarÃ¶kActive(-1)"
                  ${activeTier<=0?'disabled style="opacity:.4"':''}>â—€</button>
          <div style="flex:1;text-align:center">
            ${rootDepthIcon(activeTier)}
            <span style="font-family:'Share Tech Mono',monospace;font-size:12px;
                         color:var(--gold);margin-left:6px">${activeTier===0?'Surface (Tier 0)':`Tier ${activeTier}: ${tierName}`}</span>
          </div>
          <button class="btn btn-sm btn-ghost" onclick="adjustRagnarÃ¶kActive(1)"
                  ${activeTier>=maxTier?'disabled style="opacity:.4"':''}>â–¶</button>
        </div>
        ${activeTier>0?`
          <div style="font-size:10px;color:var(--txt3);text-align:center;margin-top:4px;font-style:italic">
            "You descend the root."
          </div>
        `:''}
      </div>
    `;
  }

  html+=`

    <div style="margin-bottom:14px">
      <label style="font-size:11px;color:var(--txt3);display:block;margin-bottom:6px;letter-spacing:1px;text-transform:uppercase">Difficulty (enemy stats)</label>
      <div style="display:flex;align-items:center;gap:10px">
        <input id="start-diff" type="range" min="0" max="2" step="0.1"
          value="${Number(UI.difficulty??1)}"
          oninput="onDifficultyInput(this.value,'start')"
          style="flex:1;accent-color:var(--amber)">
        <span id="start-diff-val" style="font-family:'Share Tech Mono',monospace;font-size:12px;color:var(--gold)">x${Number(UI.difficulty??1).toFixed(1)}</span>
      </div>
      <div style="font-size:10px;color:var(--txt3);margin-top:4px">0 = trivial Â· 1 = default Â· 2 = brutal</div>
    </div>
    <div style="margin-bottom:14px">
      <button class="btn btn-sm btn-ghost" style="width:100%;font-size:10px"
              onclick="document.getElementById('seed-wrap').style.display=(document.getElementById('seed-wrap').style.display==='none'?'block':'none')">
        Advanced â–¾
      </button>
      <div id="seed-wrap" style="display:none;margin-top:8px">
        <label style="font-size:10px;color:var(--txt3);display:block;margin-bottom:4px;
                       letter-spacing:1px;text-transform:uppercase">Saga Seed (optional)</label>
        <input id="seed-input" type="text" placeholder="Leave blank for random"
          style="width:100%;background:var(--bg2);border:1px solid var(--border2);
                 color:var(--txt);padding:8px 12px;border-radius:4px;font-size:12px;
                 font-family:'Share Tech Mono',monospace;text-align:center;outline:none">
      </div>
    </div>

    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <button class="btn btn-primary" style="flex:2;min-width:180px;padding:11px"
              onclick="startNewRunFromOverlay()">â–¶ Begin New Saga</button>
      <button class="btn btn-gold" style="flex:1;min-width:120px;padding:11px"
              onclick="hideOverlay();showLegacy()">á›Ÿ Minni-HÃ¶ll</button>
    </div>
  `;

  showOverlayContent(html);
  updateDifficultyUI();
  syncChromeHeights();
}

function adjustRagnarÃ¶kActive(delta){
  normalizeMeta();
  const maxTier=META.ragnarÃ¶kTier||0;
  const prevTier=META.ragnarÃ¶kActive||0;
  META.ragnarÃ¶kActive=Math.max(0,Math.min(maxTier,prevTier+delta));
  saveMeta();
  updateRootDepthHeader();
  showStartScreen();
}

// --- Ensure founder record uses house + aspect naming ---
function startFirstHero(){
  normalizeMeta();
  const founder=mkHeroRecord(genName(0,'Steel',null,null),0,[],emptyEVs(),[]);
  founder.birthAspect='Steel';
  founder.birthFlags={};
  let inheritedScar=null;
  if((founder.traits||[]).length===0 && META.lineageScarPool.length && rng()<LINEAGE_SCAR_INHERIT_CHANCE){
    inheritedScar=rpick(META.lineageScarPool);
    if(inheritedScar)founder.traits=[inheritedScar];
  }
  META.family[founder.id]=founder;
  saveMeta();
  initGame(null,emptyEVs(),[],founder);
  if(inheritedScar)addLog(`Lineage Memory: inherited scar â€” ${GTRAITS[inheritedScar]?.name||inheritedScar}.`,'laxiom');
}

// --- Award aspect XP on retire/victory/fallen, and show fallen harvest ---
(function(){
  const _retireHero = retireHero;
  retireHero = function(){
    try{ awardAspectXPFromRun('retired'); }catch(e){}
    _retireHero();
    // ensure persisted
    try{ saveMeta(); }catch(e){}
  };

  const _pickBoon = pickBoon;
  pickBoon = function(id){
    const wasFinal = !!(G && G.wave>=G.maxWaves);
    _pickBoon(id);
    if(wasFinal && G && G.phase==='VICTORY'){
      try{ awardAspectXPFromRun('victory'); }catch(e){}
    }
  };

  const _heroFell = heroFell;
  heroFell = function(){
    _heroFell();
    try{ awardAspectXPFromRun('fallen'); }catch(e){}
    // Offer harvest choice overlay
    try{
      const rec = (G && G.hero && G.hero.record) ? G.hero.record : null;
      if(rec && rec.id){
        const saved = META.family[rec.id];
        const sal = saved?.runResult?.salvageEarned || 0;
        showFallenScarChoice(rec.id, sal);
      }
    }catch(e){}
  };
})();

// --- Re-assert a clean onload so normalizeMeta is always applied first ---
window.onload = ()=>{
  loadMeta();
  normalizeMeta();
  Object.values(META.family||{}).forEach(h=>{
    if(!h.evs) h.evs=emptyEVs();
    if(!h.traits) h.traits=[];
    if(!h.birthAspect) h.birthAspect='Steel';
    if(!h.birthFlags) h.birthFlags={};
  });
  if(Array.isArray(META.retiredPool)){
    META.retiredPool=META.retiredPool.filter(id=>{
      const r=META.family[id];
      if(!r) return false;
      return getBreedUses(r).left>0;
    });
  }
  saveMeta();
  const small=window.matchMedia('(max-width: 420px)').matches;
  if(small&&localStorage.getItem(UI_KEY)===null){
    UI.logCollapsed=true;
    saveUI();
  }
  loadUI();
  if(typeof UI.difficulty!=='number') UI.difficulty=1;
  setCombatLogCollapsed(UI.logCollapsed);
  updateDifficultyUI();
  updateRootDepthHeader();
  showStartScreen(); // Handles opening narrative gate internally
  setTimeout(applyResponsiveLayout,0);
};


// --- V5: Memory Binding-use calculation considers Catalyze + Gale Aspect ---
function calcBreedUsesForRetire(rec){
  normalizeMeta();
  const n = (META.upgrades && META.upgrades.nursery) ? META.upgrades.nursery : 0;
  let p2 = 0.10 + n*0.07;
  if(n>=5) p2 += 0.05;
  // small randomness per retire
  if(rng()<0.12) p2 += 0.08;
  // Catalyzed births tend to be more "fertile"
  if(rec && rec.birthFlags && rec.birthFlags.catalyzed) p2 += 0.12;
  // Gale aspect subtly increases second-breed odds across the house
  p2 += getAspectRank('Gale') * 0.02;
  // Stabilized (not tracked) would lower, but we keep it simple.
  p2 = Math.max(0.02, Math.min(0.85, p2));
  return (rng() < p2) ? 2 : 1;
}

</script>
</body>
</html>
